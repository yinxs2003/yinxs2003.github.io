---
title: 算法-Mysql索引面试题
date: 2021-03-02
toc: true
tags: 概念
categories: 
- 技术
---

### 索引概念、索引模型

#### **Q：你能说说什么是索引吗？**

A：索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据

#### **Q:那么索引具体采用的哪种数据结构呢？** 

A：常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树

#### Q：**既然你提到InnoDB使用的B+ 树的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？**

A：这道题考的是B+ Tree索引和Hash索引区别？

哈希索引适合等值查询，但是无法进行范围查询 

哈希索引没办法利用索引完成排序 

哈希索引不支持多列联合索引的最左匹配规则 

如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

### 聚簇索引、非聚簇索引

#### Q：刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？

A：InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值

#### Q：那这两者有什么区别吗？ 

A：聚簇索引：索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。

而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引

#### Q：那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？

A：聚簇索引查询会更快

#### Q：为什么呢？ 

A：因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询（回表）

#### Q：刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？

A：（额、这个问题我回答的不好，后来我自己查资料才知道，通过覆盖索引也可以只查询一次）

> 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。
>
> 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。
>
> 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。
>
> 当我们通过SQL语句：select key2 from covering_index_sample where key1 = 'keytest';的时候，就可以通过覆盖索引查询，无需回表。

#### Q：如何使用覆盖索引

之前我们已经建立了表student，那么现在出现的业务需求中要求根据名称获取学生的年龄，并且该搜索场景非常频繁，那么先在我们删除掉之前以字段name建立的普通索引，**以name和age两个字段建立联合索引**，sql命令与建立后的索引树结构如下

```sql
ALTER TABLE student DROP INDEX I_name;
ALTER TABLE student ADD INDEX I_name_age(name, age);
```

![img](/images/combine_index.png)

那在我们再次执行如下sql后

```sql
SELECT age FROM student WHERE name = '小李'；
```

流程为：

1. 在name,age联合索引树上找到名称为小李的节点
2. 此时节点索引里包含信息age 直接返回 12

#### Q:如何确定数据库成功使用了覆盖索引呢？

当发起一个索引覆盖查询时，在explain的extra列可以看到using index的信息

### 联合索引、最左前缀匹配

#### Q：不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？

A：我们一般对于查询概率比较高，经常作为where条件的字段设置索引

#### Q： 那你们有用过联合索引吗？ 

A：用过呀，我们有对一些表中创建过联合索引

#### Q：那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？ 

A：我们把识别度最高的字段放到最前面

#### Q：为什么这么做呢？

A：（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。

#### Q： 那你知道最左前缀匹配吗？

A：（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则

