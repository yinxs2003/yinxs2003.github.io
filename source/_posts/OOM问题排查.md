---
title: OOM常见原因分析
date: 2020-07-06 10:40:30
tags: jvm
---

Java服务出现OOM，最常见的原因是：

1. 内存确实分配过小，内存确实不够用；
2. 某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽；
3. 某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接；更具体的，可以按照以下步骤，使用以下工具排查。

<!--more-->

# OOM常见原因分析

##  **确认是不是内存本身就分配过小** 

 jmap -heap 10765 

 ![image](/images/oom.png) 

 如上图，可以查看新生代，老生代堆内存的分配大小以及使用情况，看是否本身分配过小。 

## 找到最耗内存的对象

 jmap -histo:live 10765 | more 

 ![image](/images/OOM2.png) 

 需要说明的是，jmap -histo:live 会执行一次FGC，如果仍无法定位，可dump内存，通过Java内存分析工具MAT**（Memory Analyzer Tool**）线下进行分析。 

 上图中占内存最多的对象是RingBufferLogEvent，共占用内存18M，属于正常使用范围。如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放 

例如：
1.申请完资源后，未调用close()或dispose()释放资源；
2.消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多； 

##  **确认是否是资源耗尽**工具 

1. pstree 
2. netstat 

查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM。这里介绍另一种方法，通过/proc/${PID}/fd 和 /proc/${PID}/task 

 ![image](/images/oom3.png) 

如上图，sshd共占用了四个句柄
（1）0 -> 标准输入；
（2）1 -> 标准输出；
（3）2 -> 标准错误输出；
（4）3 -> socket（容易想到是监听端口）；

sshd只有一个主线程PID为9339，并没有多线程。所以，只要

ll /proc/${PID}/fd | wc -l
ll /proc/${PID}/task | wc -l （效果等同pstree -p | wc -l）
就能知道进程打开的句柄数和线程数。