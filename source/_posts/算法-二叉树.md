---
title: 算法-二叉树
date: 2020-11-05
toc: true
tags: 算法
categories: 
- 技术
---

二叉树需要声明一个Node节点，包含节点得值，以及左右两个子节点

Node节点代码如下

```JAVA
package com.code.note.tree;

public class Node<T extends Comparable>{
    T value;
    Node left;
    Node right;

    Node(T value) {
        this.value = value;
    }
}

```

<!--more-->

BinaryTree代码如下

```java
package com.code.note.tree;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class BinaryTree<T extends Comparable> {
    private Node<T> root;

    public void put(T value) {
        root = put(root, value);
    }

    private Node put(Node<T> x, T value) {
        if (x == null) {
            return new Node(value);
        }
        int cmp = value.compareTo(x.value);
        if (cmp < 0) {
            x.left = put(x.left, value);
        } else if (cmp > 0) {
            x.right = put(x.right, value);
        } else {
            return x;
        }

        return x;
    }
    
    // 打印二叉树
    public void print() {
        BTreePrinter.printNode(root);
    }

    public void traverse() {
        traverse(root);
    }

    // 计算节点个数
    public int count() {
        return count(root);
    }

    private int count(Node x) {
        if (x == null) {
            return 0;
        }
        return 1 + count(x.left) + count(x.right);
    }

    // 遍历
    private void traverse(Node node) {
        // 前序遍历
        if (node == null) return;
        log.info("{}", node.value);
        traverse(node.left);
        // 中序遍历
        traverse(node.right);
        // 后序遍历
    }

    //反转二叉树
    public void reverse() {
        reverse(root);
    }

    private void reverse(Node x) {

        if (x == null) return;

        Node tmp = x.left;
        x.left = x.right;
        x.right = tmp;

        reverse(x.left);
        reverse(x.right);

    }

    // 树得深度
    public int getDepth() {
        return getDepth(root);
    }

    private int getDepth(Node x) {
        if (x == null) return 0;
        return 1 + Math.max(getDepth(x.left), getDepth(x.right));
    }
}
```

以图形的格式打印二叉树

```java
package com.code.note.tree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BTreePrinter {

    public static <T extends Comparable<?>> void printNode(Node<T> root) {
        int maxLevel = BTreePrinter.maxLevel(root);

        printNodeInternal(Collections.singletonList(root), 1, maxLevel);
    }

    private static <T extends Comparable<?>> void printNodeInternal(List<Node<T>> nodes, int level, int maxLevel) {
        if (nodes.isEmpty() || BTreePrinter.isAllElementsNull(nodes))
            return;

        int floor = maxLevel - level;
        int endgeLines = (int) Math.pow(2, (Math.max(floor - 1, 0)));
        int firstSpaces = (int) Math.pow(2, (floor)) - 1;
        int betweenSpaces = (int) Math.pow(2, (floor + 1)) - 1;

        BTreePrinter.printWhitespaces(firstSpaces);

        List<Node<T>> newNodes = new ArrayList<Node<T>>();
        for (Node<T> node : nodes) {
            if (node != null) {
                System.out.print(node.value);
                newNodes.add(node.left);
                newNodes.add(node.right);
            } else {
                newNodes.add(null);
                newNodes.add(null);
                System.out.print(" ");
            }

            BTreePrinter.printWhitespaces(betweenSpaces);
        }
        System.out.println("");

        for (int i = 1; i <= endgeLines; i++) {
            for (int j = 0; j < nodes.size(); j++) {
                BTreePrinter.printWhitespaces(firstSpaces - i);
                if (nodes.get(j) == null) {
                    BTreePrinter.printWhitespaces(endgeLines + endgeLines + i + 1);
                    continue;
                }

                if (nodes.get(j).left != null)
                    System.out.print("/");
                else
                    BTreePrinter.printWhitespaces(1);

                BTreePrinter.printWhitespaces(i + i - 1);

                if (nodes.get(j).right != null)
                    System.out.print("\\");
                else
                    BTreePrinter.printWhitespaces(1);

                BTreePrinter.printWhitespaces(endgeLines + endgeLines - i);
            }

            System.out.println("");
        }

        printNodeInternal(newNodes, level + 1, maxLevel);
    }

    private static void printWhitespaces(int count) {
        for (int i = 0; i < count; i++)
            System.out.print(" ");
    }

    private static <T extends Comparable<?>> int maxLevel(Node<T> node) {
        if (node == null)
            return 0;

        return Math.max(BTreePrinter.maxLevel(node.left), BTreePrinter.maxLevel(node.right)) + 1;
    }

    private static <T> boolean isAllElementsNull(List<T> list) {
        for (Object object : list) {
            if (object != null)
                return false;
        }

        return true;
    }
}
```



测试用例

```java
package com.code.note.tree;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Slf4j
public class BinaryTreeTest {
    public static void main(String[] args) {

        BinaryTree<Integer> binaryTree = new BinaryTree<Integer>();
        binaryTree.put(3);
        binaryTree.put(5);
        binaryTree.put(1);
        binaryTree.put(2);

        binaryTree.put(10);


        binaryTree.traverse();

        int count = binaryTree.count();
        log.info("count:{}", count);

        int depth = binaryTree.getDepth();
        log.info("depth:{}", depth);


        // 翻转二叉树
        binaryTree.print();
        binaryTree.reverse();
        binaryTree.print();

    }
}
```

测试结果

```3
1
2
5
10
5
3
[main] INFO com.code.note.tree.BinaryTreeTest - 3
   3       
  / \   
 /   \  
 1   5   
  \   \ 
  2   10 
                
   3       
  / \   
 /   \  
 5   1   
/   /   
10   2   
```

