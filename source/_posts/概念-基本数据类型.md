---
title: 概念-基本数据类型
date: 2021-03-03
toc: true
tags: 概念
categories: 
- 技术
---

### 基本数据类型枚举

1. 数字类型：byte，short，int，long
2. 浮点型：float，double
3. 布尔类型：boolean
4. 字符型：char

计算机内存的最小存储单元是字节（byte），**一个字节就是一个8位二进制数，即8个bit**。它的二进制表示范围从`00000000~11111111`，换算成十进制是`0～255`，换算成十六进制是`00 ~ ff`。其中最高位是符号位，所以数据范围是`-128～127`，即`-2^7～2^8 - 1`

一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。

### 每个字节占大小

不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：

以下一个方块代表一个字节（byte），一个字节有8位（bits），所以byte大小是

```ascii
       ┌───┐
  byte │   │
       └───┘
       ┌───┬───┐
 short │   │   │
       └───┴───┘
       ┌───┬───┬───┬───┐
   int │   │   │   │   │
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
  long │   │   │   │   │   │   │   │   │
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┬───┬───┐
 float │   │   │   │   │
       └───┴───┴───┴───┘
       ┌───┬───┬───┬───┬───┬───┬───┬───┐
double │   │   │   │   │   │   │   │   │
       └───┴───┴───┴───┴───┴───┴───┴───┘
       ┌───┬───┐
  char │   │   │
       └───┴───┘
```

`byte`恰好就是一个字节，而`long`和`double`需要8个字节。

### 32位JVM和64位JVM基本类型大小区别

那么问题来了32位jvm和64位jvm各个基本类型所占用字节数相同吗？

下面是32位系统与64位系统各数据类型对比：除了*与long随操作系统子长变化而变化外，其他的都固定不变(32位和64位相比)

| 数据类型          | 说明             | 32位字节数 | 64位字节数 | 取值范围                            |
| ----------------- | ---------------- | ---------- | ---------- | ----------------------------------- |
| bool              | 布尔型           | 1          | 1          | true，false                         |
| char              | 字符型           | 1          | 1          | -128~127                            |
| unsigned char     | 无符号字符型     | 1          | 1          | 0~255                               |
| short             | 短整型           | 2          | 2          | -32768~32767                        |
| unsigned short    | 无符号短整型     | 2          | 2          | 0~65535                             |
| int               | 整型             | 4          | 4          | -2147483648~2147483647              |
| unsigned int      | 无符号整型       | 4          | 4          | 0~4294967295                        |
| **long**          | **长整型**       | **4**      | **8**      | **–**                               |
| **unsigned long** | **无符号长整型** | **4**      | **8**      | **–**                               |
| long long         | 长整型           | 8          | 8          | -2^64~2^64-1                        |
| float             | 单精度浮点数     | 4          | 4          | 范围-2^128~2^128精度为6~7位有效数字 |
| double            | 双精度浮点数     | 8          | 8          | 范围-2^1024~2^1024精度为15~16位     |
| long double       | 扩展精度浮点数   | 8          | 8          | 范围-2^1024~2^1024精度为15~16位     |
| *                 | 地址             | 4          | 8          | -                                   |

### 对于long和double的特殊规则

考虑到Java语言的内存模型，对非volatile的long或double的单个写操作会当成两个分离的写操作进行处理，每个操作处理32位。这会导致这样的情况：一个线程会看到由某个写操作写入的64位值的头32位和由另一个写操作写入的后32位。

对volatile的long和double值读操作和写操作总是原子性的。

对引用的读操作和写操作总是原子行的。

**所以我们鼓励程序员将共享的64位声明称volatile的**。