---
title: 算法-八大排序算法之堆排序
date: 2021-04-07
toc: true
tags: 算法
categories: 
- 技术
---

### 题目描述

```java
给你一个整数数组 nums，请你将该数组升序排列。 

示例 1：

输入：nums = [5,2,3,1]

输出：[1,2,3,5]



示例 2：

输入：nums = [5,1,1,2,0,0]

输出：[0,0,1,1,2,5]
```

### 堆排序的性质

1. 堆是一颗满二叉树
2. 子节点和父节点下标关系：leftChild = parent * 2 + 1
3. 构建大顶堆是上浮操作，上浮操作是选择子节点中较大的节点，并和parent节点比较，子节点较大则交换子节点和parent节点
4. 不稳定排序，时间复杂度O(nlogn)

### 如何实现

使用堆排序进行排序操作，堆排序可以分成两个步骤

1. 构建大顶堆，应该是从第向上执行遍历（上浮），所以循环从数组末尾向前循环
2. 打印或者保存第一个节点
3. 交换第一个和最后一个节点，缩小数组范围并继续执行第一步

代码如下

```java
package com.code.note.test;

import com.code.note.tree.BinaryHeap;

public class Solution2 {

    public void buildBigHeap(int[] arr, int parent, int len) {
        int child = parent * 2 + 1;
        while (child < len) {
            if (child + 1 < len && arr[child] < arr[child + 1]) {
                child++;
            }

            if (arr[child] <= arr[parent]) {
                break;
            }

            swap(arr, child, parent);

            parent = child;
            child = 2 * child + 1;
        }
    }

    public void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public void print(int[] arr) {
        BinaryHeap b = new BinaryHeap();
        b.insertLevelOrder(arr);
        b.print();
    }

    public int findKthLargest(int[] arr, int k) {
        // 构建大顶堆
        for (int i = arr.length / 2; i >= 0; i--) {
            buildBigHeap(arr, i, arr.length);
        }

        print(arr);


        for (int i = arr.length - 1; i > k; i--) {
            swap(arr, 0, i);
            buildBigHeap(arr, 0, i);
        }
        return arr[arr.length - k];
    }

    public static void main(String[] args) {

        Solution2 s = new Solution2();

        int[] arr = new int[]{3,2,3,1,2,4,5,5,6};

        s.print(arr);

        int a = s.findKthLargest(arr, 4);


        System.out.println(a);
    }
}
```

