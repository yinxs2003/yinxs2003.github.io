---
title: 多线程控制
date: 2020-06-14
tags: java
---



1. 可以使用countDownLatch
2. 可以使用CyclicBarrier
3. Semaphore



如何保证线程再其他线程任务执行后执行：可以使用CountDownLatch或者CyclicBarrier

##	CountDownLatch（线程计数器 ）

**CountDownLatch：拦截所有线程，直到count个数为0**

CountDownLatch 类位于java.util.concurrent 包下，利用它可以实现类似计数器的功能。

执行latch.countDown()时计数器减一，直到计数器值变成0，才会执行latch.await()方法后的线程



比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch 来实现这种功能了。

```java
package com.bd.thread;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author xupeng
 * @date: 14/06/2020
 */
public class CountDownLatchTest {
  public static void main(String[] args) {
    final CountDownLatch latch = new CountDownLatch(2);

    new Thread() {
      public void run() {
        try {
          System.out.println("子线程" + Thread.currentThread().getName() + "正在执行");
          Thread.sleep(3000);
          System.out.println("子线程" + Thread.currentThread().getName() + "执行完毕");
          latch.countDown();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }.start();

    new Thread() {
      public void run() {
        try {
          System.out.println("子线程" + Thread.currentThread().getName() + "正在执行");
          Thread.sleep(3000);
          System.out.println("子线程" + Thread.currentThread().getName() + "执行完毕");
          latch.countDown();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }.start();

    try {
      System.out.println("等待2个子线程执行完毕...");
      latch.await();
      System.out.println("2个子线程已经执行完毕");
      System.out.println("继续执行主线程");
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}

```

执行结果：

```
子线程Thread-0正在执行
子线程Thread-1正在执行
等待2个子线程执行完毕...
子线程Thread-0执行完毕
子线程Thread-1执行完毕
2个子线程已经执行完毕
继续执行主线程
```

## CyclicBarrier（回环栅栏）

**栅栏：拦截所有线程直到所有线程处于barrier状态才会继续执行**

CyclicBarrier中最重要的方法就是await方法，它有2个重载版本

```java
public int await() throws InterruptedException, BrokenBarrierException { };
public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException { };
```

第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；

第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。

```java
package com.bd.thread;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author xupeng
 * @date: 14/06/2020
 */
public class CirclicBarrierTest {
  public static void main(String[] args) {
    int N = 4;
    CyclicBarrier barrier = new CyclicBarrier(N);
    for (int i = 0; i < N; i++)
      new Writer(barrier).start();
  }

  static class Writer extends Thread {
    private CyclicBarrier cyclicBarrier;

    public Writer(CyclicBarrier cyclicBarrier) {
      this.cyclicBarrier = cyclicBarrier;
    }

    @Override
    public void run() {
      System.out.println("线程" + Thread.currentThread().getName() + "正在写入数据...");
      try {
        Thread.sleep(5000);      //以睡眠来模拟写入数据操作
        System.out.println("线程" + Thread.currentThread().getName() + "写入数据完毕，等待其他线程写入完毕");
        cyclicBarrier.await();
      } catch (InterruptedException e) {
        e.printStackTrace();
      } catch (BrokenBarrierException e) {
        e.printStackTrace();
      }
      System.out.println("所有线程写入完毕，继续处理其他任务...");
    }
  }
}
```

## Semaphore用法（信号量）

**信号量：用来控制同时访问的线程数**

Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。Semaphore类位于java.util.concurrent包下，它提供了2个构造器：

``` java
public Semaphore(int permits) {          //参数permits表示许可数目，即同时可以允许多少线程进行访问
    sync = new NonfairSync(permits);
}
public Semaphore(int permits, boolean fair) {    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
}
```

下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：

```java
public void acquire() throws InterruptedException {  }     //获取一个许可
public void acquire(int permits) throws InterruptedException { }    //获取permits个许可
public void release() { }          //释放一个许可
public void release(int permits) { }    //释放permits个许可
```

