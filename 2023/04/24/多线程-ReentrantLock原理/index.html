<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>多线程-ReentrantLock原理 | 工作随笔</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">多线程-ReentrantLock原理</h1><a id="logo" href="/.">工作随笔</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">多线程-ReentrantLock原理</h1><div class="post-meta">2023-04-24<span> | </span><span class="category"><a href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81AQS%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">1、AQS的初始化。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81AQS%E7%9A%84%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2、AQS的加锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%88%9D%E6%AC%A1%E5%8A%A0%E9%94%81%EF%BC%8C%E8%BF%98%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%BE%97AQS%E7%9A%84%E9%94%81%EF%BC%9B"><span class="toc-number">3.</span> <span class="toc-text">2-1、 第一种情况：初次加锁，还没有任何线程获得AQS的锁；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%B7%B2%E7%BB%8F%E6%9C%89%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%BE%97%E4%BA%86AQS%E7%9A%84%E9%94%81%EF%BC%8C%E4%BD%86%E6%98%AF%E8%8E%B7%E5%BE%97%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA"><span class="toc-number">4.</span> <span class="toc-text">2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9A%E5%B7%B2%E7%BB%8F%E6%9C%89%E7%BA%BF%E7%A8%8B%E8%8E%B7%E5%BE%97%E4%BA%86AQS%E7%9A%84%E9%94%81-%E5%B9%B6%E4%B8%94%E5%8A%A0%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%B8%8D%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%EF%BC%9B"><span class="toc-number">5.</span> <span class="toc-text">2-3、第三种情况：已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81AQS%E7%9A%84%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">3、AQS的解锁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">4、公平锁非公平锁的区别</span></a></li></ol></div></div><div class="post-content"><p>如果你在之前的文章中我们已经了解过了 java中的管程sychronized实现原理，那么再来看AbstractQueuedSynchronizer的实现就会非常简单了，虽然使用的加锁技术有不同之处，但是他们都是基于同样的理念去实现的.</p>
<p>打开ReentrantLock 的源码你会发现，ReentrantLock  的所有操作都是基于Sycn对象去操作的，而Sycn继承于AbstractQueuedSynchronizer的一个子类，而不管是NonfairSync非公平锁，还是FairSync 公平锁都继承于Sycn，这也说明了ReentrantLock  里面最终维护的其实就是一个AQS对象。</p>
<p><img src="/resources/ReentrantLock/v2-2ee1014090c1b443b24f6e69c28442e9_1440w-1682070247235-29.webp" alt="img"></p>
<h3 id="1、AQS的初始化。"><a href="#1、AQS的初始化。" class="headerlink" title="1、AQS的初始化。"></a><strong>1、AQS的初始化。</strong></h3><p>当我们调用new ReentrantLock()时其实就是初始化了一个AQS对象，该对象包括如下几个属性</p>
<p>1、<strong>state</strong> （锁的状态 0代表未加锁，&gt;0则代表已加锁，和重入次数）</p>
<p>2、<strong>exclusiveOwnerThread</strong> （拥有当前锁的线程）</p>
<p>3、由 Node节点组成的双向链表，Node节点保存了等待线程的相关信息。</p>
<p><img src="/resources/ReentrantLock/v2-9a8eb3fe3514e624707ad18d4f859ed6_1440w.webp" alt="img"></p>
<p><strong>当AQS初始化之后，会初始化一个如下对象</strong></p>
<p>1、state状态为0</p>
<p>2、exclusiveOwnerThread &#x3D;null</p>
<p> 3、由head 和tail两个空节点组成的首尾双向链表。</p>
<p><img src="/resources/ReentrantLock/v2-141518a2df8159ef365bf773eec152f7_1440w.webp" alt="img"></p>
<h3 id="2、AQS的加锁过程"><a href="#2、AQS的加锁过程" class="headerlink" title="2、AQS的加锁过程"></a><strong>2、AQS的加锁过程</strong></h3><p>一个线程通过ReentrantLock .lock()  首先会获得当前AQS锁的状态，然后根据锁的对应状态做出不同的处理，具体分为以下几种情况；</p>
<p>1、<strong>第一种情况：</strong>初次加锁，还没有任何线程获得AQS的锁；</p>
<p>2、<strong>第二种情况：</strong>已经有线程获得了AQS的锁，但是加锁的线程和当前线程是同一个;</p>
<p>3、<strong>第三种情况三：</strong>已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；</p>
<p>下面我们针对每种情况进行分析</p>
<h3 id="2-1、-第一种情况：初次加锁，还没有任何线程获得AQS的锁；"><a href="#2-1、-第一种情况：初次加锁，还没有任何线程获得AQS的锁；" class="headerlink" title="2-1、 第一种情况：初次加锁，还没有任何线程获得AQS的锁；"></a><strong>2-1、</strong> <strong>第一种情况：初次加锁，还没有任何线程获得AQS的锁；</strong></h3><p>线程A调用ReentrantLock .lock()  进行加锁，当还没有任何对象获得AQS锁时候会执FairSync.tryAcquire（）方法的如下代码：</p>
<p><img src="/resources/ReentrantLock/v2-fb7582a703962a9fc69ef7471b5dce1e_1440w.webp" alt="img"></p>
<p><strong>以上标注代码的逻辑：</strong></p>
<p>1、判断队列中是否有正在等待锁的节点，因为是初次加锁，所以这里head和tail节点都是空；</p>
<p>2、使用compareAndSetState（）方法对AQS进行加锁（此方法能保证操作的原子性）。</p>
<p>3、设置当前获得锁对象的线程；</p>
<p><img src="/resources/ReentrantLock/v2-ff8e996407749e929af483f439558b64_1440w.webp" alt="img"></p>
<h3 id="2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个"><a href="#2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个" class="headerlink" title="2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个;"></a><strong>2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个;</strong></h3><p><img src="/resources/ReentrantLock/v2-d68554183594cc5a083fef223da2f088_1440w.webp" alt="img"></p>
<p>如上面代码，当线程A调用demo1()方法，已经获得了AQS锁，当调用demo2时又会去竞争AQS锁，这样允许同一个线程多次获得同一把锁的情况称为 <strong>“可重入锁”</strong></p>
<p>当线程A再次调用ReentrantLock .lock() 时会执行FairSync.tryAcquire（）对应重入锁逻辑的代码：</p>
<p><img src="/resources/ReentrantLock/v2-9c6b1c975e6c1ffc5defd0f79ee5c71a_1440w.webp" alt="img"></p>
<p><strong>以上标注代码的逻辑：</strong></p>
<p>1、首先拿当前线程和已经获得AQS锁的线程对比是否是同一个线程；</p>
<p>2、是同一个线程的话获得 当前AQS的state ，执行state+1累计重入次数；</p>
<p>3、修改AQS的state;</p>
<p><strong>最后执行结果如下图：</strong></p>
<p><img src="/resources/ReentrantLock/v2-fdab126d61043d8e8b45c9be725c7dad_1440w.webp" alt="img"></p>
<h3 id="2-3、第三种情况：已经有线程获得了AQS的锁-并且加锁的线程和当前线程不是同一个；"><a href="#2-3、第三种情况：已经有线程获得了AQS的锁-并且加锁的线程和当前线程不是同一个；" class="headerlink" title="2-3、第三种情况：已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；"></a><strong>2-3、第三种情况：已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；</strong></h3><p>当前面的线程A已经获得了AQS锁，还没进行释放，此时线程B调用ReentrantLock .lock() 方法获取锁会执行AbstractQueuedSynchronizer.acquire()的如下代码：</p>
<p><img src="/resources/ReentrantLock/v2-1652935801412dc6fb63c19fbef4940c_1440w.webp" alt="img"></p>
<p><strong>以上代码逻辑：</strong></p>
<p><strong>1、首先执行 addWaiter（）把获得锁不成功的线程加入到阻塞队列</strong></p>
<p>A、把线程B封装为一个Node节点（这里我们定义为nodeB）;</p>
<p>B、如果当前AQS中双向链表tail节点不为空，则把nodeB设置为tail节点，把nodeB.pre指向原来的tail节点，并把原来的tail节点的nex指向nodeB；</p>
<p>C、如果当前AQS中双向链表tail节点为空，则说明当前链表里面没有其他等待的节点，那么首先创建一个Node  节点（这里定义为nodeN）作为head节点，然后把nodeN.nex指向nodeB节点，把tail指向nodeB节点,nodeB.pre指向nodeN节点； </p>
<p><strong>2、addWwaiter()成功后调用 acquireQueued（）方法</strong>；</p>
<p>F、首先会再次尝试获取一下锁；</p>
<p>G、当获取锁失败后，把双向链表中nodeB.pre指向的节点的waitStatus 设置为 -1；</p>
<p><strong>注：</strong></p>
<p><strong>waitStatus&#x3D;0</strong>  新加的节点，处于阻塞状态。</p>
<p><strong>waitStatus&#x3D; 1</strong> 表示该线程节点已释放（超时、中断），已取消的节点不会再阻塞。</p>
<p><strong>waitStatus&#x3D;-1</strong> 表示该线程的后续线程需要阻塞，即只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程 。</p>
<p><strong>waitStatus&#x3D;-2</strong>  表示该节点的线程处于等待Condition条件状态,不会被当作是同步队列上的节点,直到被唤醒(signal),设置其值为0,重新进入阻塞状。</p>
<p><strong>waitStatus&#x3D;-3</strong>  表示该线程以及后续线程进行无条件传播（CountDownLatch中有使用）共享模式下，        PROPAGATE 状态的线程处于可运行状态。</p>
<p>因为我们的案例是第一加锁，所以head 和tail节点都为null ，所以代码会走A、C、F、G逻辑 。</p>
<p>最后结果如图。</p>
<p><img src="/resources/ReentrantLock/v2-d4d66759f2761c7f2873a1d28ce7ae1c_1440w.webp" alt="img"></p>
<p><strong>最后整个AQS初始化、线程A两次加锁、线程B加锁的流程如图：</strong></p>
<p><img src="/resources/ReentrantLock/v2-0e5c82fd5518713879a7e2c13bc71259_1440w.webp" alt="img"></p>
<h3 id="3、AQS的解锁过程"><a href="#3、AQS的解锁过程" class="headerlink" title="3、AQS的解锁过程"></a><strong>3、AQS的解锁过程</strong></h3><p>通过上面的流程，我们已经了解了AQS的加锁过程，当线程加锁不成功之后，会把当前线程放到一个等待队列中去，这个队列是由head和tail构建出来的一个双向链表，下面我们继续上面的案例继续分析AQS的解锁过程。</p>
<p>因为上面AQS的锁获得线程为线程A ，所以现在只有线程A可以进行释放锁，当线程A调用ReentrantLock .unlock() 时，最终执行ReentrantLock.tryRelease()方法，代码如下：</p>
<p><img src="/resources/ReentrantLock/v2-0deb9cd7199f5fb6b5b1959154e86ec3_1440w.webp" alt="img"></p>
<p>1、获得当前AQS的state 并进行减1(state每减1代表释放一次锁)；</p>
<p>2、当state&#x3D;0的时候说明当前锁已经完全释放了，此时会设置拥有AQS 锁的线程为null;</p>
<p>3、当state不等于0说明锁还没有释放完全，此时修改state的值。</p>
<p>因为上面案例中线程A获得了2次锁，所以线程A需要调用两次ReentrantLock .unlock()才能释放锁，整个流程如下图：</p>
<p><img src="/resources/ReentrantLock/v2-3c93d8482ca4623f3362a4ca491b6a46_1440w.webp" alt="img"></p>
<p>当线程A释放完锁之后程序会调用AbstractQueuedSynchronizer.release()方法的如下代码：</p>
<p><img src="/resources/ReentrantLock/v2-c2671edb6cf3db997e1d2348f4752438_1440w.webp" alt="img"></p>
<p>我想如果明白了AQS的加锁过程，那么你已经猜到了，当线程释放锁完毕之后接下来肯定是唤醒等待队列里面的线程了，这段代码也的确是在做这些事情：</p>
<p>1、获得等待队列链表中的head节点；</p>
<p>2、当head节点不为空，并且head节点的waitStatus!&#x3D;0（这里代表线程状态正常）时，调用unparkSuccessor（）方法唤醒链表中head.next节点中的线程，。</p>
<p>3、当前链表里面head.next 为nodeB,所以线程B会被唤醒，然 后重新去获取锁，同时重构链表节点.</p>
<p><strong>最后结果如图：</strong></p>
<p><img src="/resources/ReentrantLock/v2-1a23525fdccec60ce0d88fd32f1c3701_1440w.webp" alt="img"></p>
<h3 id="4、公平锁非公平锁的区别"><a href="#4、公平锁非公平锁的区别" class="headerlink" title="4、公平锁非公平锁的区别"></a><strong>4、公平锁非公平锁的区别</strong></h3><p>公平锁进行lock()的时候，如果AQS为无锁状态，公平锁首先会判断AQS里面是否有等待的线程，如果有的话会添加到队列里面排队，队列里面没有线程的话才会去尝试获取锁。</p>
<p>非公平锁 进行lock()的时候，只要是AQS是无锁状态，不管队列里面是否有等待线程都会直接去尝试获得锁。</p>
</div><div class="tags"><a href="/tags/概念"><i class="fa fa-tag">概念</i></a></div><div class="post-nav"><a class="pre" href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E4%BD%BF%E7%94%A8/">多线程-ReentrantLock使用</a><a class="next" href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Semaphore/">多线程-信号量</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yinxs2003.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p></p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E6%8A%80%E6%9C%AFJava/" style="font-size: 15px;">技术Java</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%A6%82%E5%BF%B5/" style="font-size: 15px;">概念</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/05/09/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java-线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/07/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2/">Spring-Bean的生命周期（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1/">Spring-Bean的生命周期（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/">Ubuntu mysql5.7 安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java-虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/">多线程-Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">Java-HotSpot虚拟机创建对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-JVM_Options/">Java-jvm options</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java-内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java-多线程实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://heqiao2010.github.io/" title="heqiao2010" target="_blank">heqiao2010</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">工作随笔.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>