<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java-内存模型 | 工作随笔</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java-内存模型</h1><a id="logo" href="/.">工作随笔</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java-内存模型</h1><div class="post-meta">2023-04-24<span> | </span><span class="category"><a href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">1. 内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">2. 内存间的交互操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 定义操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 约束条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-volatile"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-long%E5%92%8Cdouble%E7%9A%84%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8D%8F%E5%AE%9A"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. long和double的非原子性协定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E5%85%88%E5%8F%91%E6%80%A7"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 先发性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F-happens-before-%E8%A7%84%E5%88%99"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 先行发生(happens-before)规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E6%AF%94%E8%BE%83"><span class="toc-number">3.</span> <span class="toc-text">3. 常见比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-volatile%E4%B8%8Esynchronized%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 volatile与synchronized比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Lock-ReentrantLock-%E4%B8%8Esynchronized%E6%AF%94%E8%BE%83"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Lock(ReentrantLock)与synchronized比较</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1. 内存模型"></a>1. 内存模型</h2><p> <img src="/resources/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="内存模型"></p>
<h2 id="2-内存间的交互操作"><a href="#2-内存间的交互操作" class="headerlink" title="2. 内存间的交互操作"></a>2. 内存间的交互操作</h2><h3 id="2-1-定义操作"><a href="#2-1-定义操作" class="headerlink" title="2.1. 定义操作"></a>2.1. 定义操作</h3><ul>
<li>lock(锁定)：作用于主内存的变量,它把一个变量标识为一条线程独占的状态.</li>
<li>unlock(解锁)：作用于主内存的变量,它把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定.</li>
<li>read(读取)：作用于主内存的变量,它把一个变量的值从主内存传输到线程的工作内存中,以便随后的load动作使用.</li>
<li>load(载入)：作用于工作内存的变量,它把read操作从主内存中得到的变量值放入工作内存的变量副本中.</li>
<li>use(使用)：作用于工作内存的变量,它把工作内存中一个变量的值传递给执行引擎,每当虚拟机遇到一个需要使用到<br>变量的值的字节码指令时将会执行这个操作.</li>
<li>assign(赋值)：作用于工作内存的变量,它把一个从执行引擎接收到的值赋给工作内存的变量,每当虚拟机遇到一个<br>给变量赋值的字节码指令时执行这个操作.</li>
<li>store(存储)：作用于工作内存的变量,它把工作内存中一个变量的值传送到主内存中,以便随后的write操作使用.</li>
<li>write(写入)：作用于主内存的变量,它把store操作从工作内存中得到的变量的值放入主内存的变量中.</li>
</ul>
<h3 id="2-2-约束条件"><a href="#2-2-约束条件" class="headerlink" title="2.2. 约束条件"></a>2.2. 约束条件</h3><ol>
<li>read和load、store和write必须保证顺序操作,不能单独出现,但不需要连续操作,中间可隔有其他操作</li>
<li>不允许一个线程丢弃它的最近的assign操作,即变量在工作内存中改变了之后必须把该变化同步回主内存.</li>
<li>不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中.</li>
<li>一个新的变量只能在主内存中“诞生”,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量,换句话说,<br>就是对一个变量实施use、 store操作之前,必须先执行过了assign和load操作.</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作,但lock操作可以被同一条线程重复执行多次,多次执行lock后,<br>只有执行相同次数的unlock操作,变量才会被解锁</li>
<li>如果对一个变量执行lock操作,那将会清空工作内存中此变量的值,在执行引擎使用这个变量前,<br>需要重新执行load或assign操作初始化变量的值.</li>
<li>如果一个变量事先没有被lock操作锁定,那就不允许对它执行unlock操作,也不允许去unlock一个被其他线程锁定住的变量.</li>
<li>对一个变量执行unlock操作之前,必须先把此变量同步回主内存中(执行store、 write操作)</li>
</ol>
<h3 id="2-3-volatile"><a href="#2-3-volatile" class="headerlink" title="2.3. volatile"></a>2.3. volatile</h3><p>   &amp;emsp;&amp;emsp;假定T表示一个线程,V和W分别表示两个volatile型变量,那么在进行read、 load、 use、 assign、store和write操作时<br>   需要满足如下规则:<br>   &amp;emsp;&amp;emsp;只有当线程T对变量V执行的前一个动作是load的时候,线程T才能对变量V执行use动作;并且,只有当线程T对变量V执行的后一个动作是use<br>   的时候,线程T才能对变量V执行load动作. 线程T对变量V的use动作可以认为是和线程T对变量V的load、 read动作相关联,必须连续一起出现<br>   (这条规则要求在工作内存中,每次使用V前都必须先从主内存刷新最新的值,用于保证能看见其他线程对变量V所做的修改后的值).<br>   &amp;emsp;&amp;emsp;只有当线程T对变量V执行的前一个动作是assign的时候,线程T才能对变量V执行store动作;并且,只有当线程T对变量V执行的后一个动作<br>   是store的时候,线程T才能对变量V执行assign动作. 线程T对变量V的assign动作可以认为是和线程T对变量V的store、 write动作相关<br>   联,必须连续一起出现(这条规则要求在工作内存中,每次修改V后都必须立刻同步回主内存中,用于保证其他线程可以看到自己对变量V所做的修改)<br>   &amp;emsp;&amp;emsp;假定动作A是线程T对变量V实施的use或assign动作,假定动作F是和动作A相关联的load或store动作,假定动作P是和动作F相应的对变量V<br>   的read或write动作;类似的,假定动作B是线程T对变量W实施的use或assign动作,假定动作G是和动作B相关联的load或store动作,假定动作<br>   Q是和动作G相应的对变量W的read或write动作. 如果A先于B,那么P先于Q(这条规则要求volatile修饰的变量不会被指令重排序优化,保证代<br>   码的执行顺序与程序的顺序相同).<br>   &amp;emsp;&amp;emsp;volatile不仅保证了共享变量的可见性，还通过内存屏障保证了代码执行顺序与程序顺序相同，通过内存屏障来使变量不被指令重排优化</p>
<h3 id="2-4-long和double的非原子性协定"><a href="#2-4-long和double的非原子性协定" class="headerlink" title="2.4. long和double的非原子性协定"></a>2.4. long和double的非原子性协定</h3><p>  &amp;emsp;&amp;emsp;读写操作可分为2次32位操作,所以一定不是原子操作<br>  <strong><em>注：现在商用虚拟机本身几乎都已经实现了原子操作,所以不用volatile修饰符</em></strong></p>
<h3 id="2-5-原子性"><a href="#2-5-原子性" class="headerlink" title="2.5 原子性"></a>2.5 原子性</h3><p>  变量操作的read、load、use、assign、store、write不保证了原子性<br>  通过synchronized对lock、unlock操作也保证了原子性</p>
<h3 id="2-6-可见性"><a href="#2-6-可见性" class="headerlink" title="2.6 可见性"></a>2.6 可见性</h3><p>  volatile保证在读取共享变量之前去主内存刷最新值，还保证了最新值能及时同步至主内存</p>
<h3 id="2-7-有序性"><a href="#2-7-有序性" class="headerlink" title="2.7 有序性"></a>2.7 有序性</h3><p>  在本线程内观察所有操作都是有序的，在另一个线程观察所有操作都是无序的</p>
<h3 id="2-8-先发性"><a href="#2-8-先发性" class="headerlink" title="2.8 先发性"></a>2.8 先发性</h3><p>  先发生的线程对修改了共享变量的值、发送了消息或调用了方法会被后发生的线程所观察到  </p>
<h3 id="2-9-先行发生-happens-before-规则"><a href="#2-9-先行发生-happens-before-规则" class="headerlink" title="2.9 先行发生(happens-before)规则"></a>2.9 先行发生(happens-before)规则</h3><p>  《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。 </p>
<ul>
<li>1、程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>2、监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>3、volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>4、传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>5、start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>6、join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<h2 id="3-常见比较"><a href="#3-常见比较" class="headerlink" title="3. 常见比较"></a>3. 常见比较</h2><h3 id="3-1-volatile与synchronized比较"><a href="#3-1-volatile与synchronized比较" class="headerlink" title="3.1 volatile与synchronized比较"></a>3.1 volatile与synchronized比较</h3><ul>
<li>1、被volatile描述的共享变量通过内存屏障是代码不被指令重排优化，从而保证了共享变量在线程间的可见性，更新变量时会及时<br>的将最新值同步至主内存，读变量时会及时的去主内存获取最新值，volatile只能修饰变量，只保证可见性，不保证原子性，不能用来<br>同步。</li>
<li>2、synchronized是通过对象头的锁标志位来实现加锁与释放锁，不仅保证可见性，还保证了原子性，只有获得了对象锁的线程才能<br>进入临界区，其他线程会阻塞等待锁释放后再争抢锁。</li>
</ul>
<h3 id="3-2-Lock-ReentrantLock-与synchronized比较"><a href="#3-2-Lock-ReentrantLock-与synchronized比较" class="headerlink" title="3.2 Lock(ReentrantLock)与synchronized比较"></a>3.2 Lock(ReentrantLock)与synchronized比较</h3><ul>
<li>1、synchronized是JAVA关键字，Lock是一个java接口，ReentrantLock实现了该接口</li>
<li>2、Lock锁需要在finally{}代码里手动释放，synchronized会自动释放锁</li>
<li>3、Lock根据实现不同有多种锁类型，如公平锁、非公平锁(默认非公平锁)</li>
<li>4、性能方面，在锁竞争很大的情况下Lock性能更优于synchronized</li>
</ul>
</div><div class="tags"><a href="/tags/概念"><i class="fa fa-tag">概念</i></a></div><div class="post-nav"><a class="pre" href="/2023/04/24/Java-JVM_Options/">Java-jvm options</a><a class="next" href="/2023/04/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java-多线程实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yinxs2003.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p></p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E6%8A%80%E6%9C%AFJava/" style="font-size: 15px;">技术Java</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%A6%82%E5%BF%B5/" style="font-size: 15px;">概念</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/06/05/Java-%E9%9B%B6%E6%8B%B7%E8%B4%9D/">Java-零拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/09/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java-线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/07/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2/">Spring-Bean的生命周期（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1/">Spring-Bean的生命周期（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/">Ubuntu mysql5.7 安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/">Java-自定义注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java-虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/">多线程-Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">Java-HotSpot虚拟机创建对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-JVM_Options/">Java-jvm options</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://heqiao2010.github.io/" title="heqiao2010" target="_blank">heqiao2010</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">工作随笔.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>