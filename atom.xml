<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>工作随笔</title>
  
  
  <link href="https://yinxs2003.github.io/atom.xml" rel="self"/>
  
  <link href="https://yinxs2003.github.io/"/>
  <updated>2023-04-14T20:34:39.611Z</updated>
  <id>https://yinxs2003.github.io/</id>
  
  <author>
    <name>yinxs2003</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概念-Java内存模型</title>
    <link href="https://yinxs2003.github.io/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://yinxs2003.github.io/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-04-14T16:00:00.000Z</published>
    <updated>2023-04-14T20:34:39.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h3><p>基于分代收集理论，可以分为年轻代、年老代两类收集算法。</p><p>年轻代：标记复制</p><p>年老代：标记整理</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>其中标记清除算法是最基础的算法，后续算法都是基于标记清楚算法改进得到的</p><p>标记清除算法缺点：</p><ul><li>执行效率不稳定，当年轻代有大量回收对象时候，需要执行大量标记清除动作，而标记动作通常是需要stop the world的，所以可能存在性能问题</li><li>内存碎片问题</li></ul><h4 id="标记复制"><a href="#标记复制" class="headerlink" title="标记复制"></a>标记复制</h4><p>标记复制是将存活对象复制到两个Eden区的其中一个，然后回收剩下内存里的所有对象</p><p>年轻代特点是”朝生夕死”，需要复制对象数量少，所以使用标记复制进行垃圾回收效率高</p><p>一个Survivor区，两个Eden区，比例为8：1：1</p><ul><li>执行第一次垃圾回收时候，将存活对象放到某个Enden区，剩下的Survivor和Eden执行回收操作</li><li>执行第二次垃圾回收时候，将存活对象copy到另一个Enden区，剩下的Survivor和Eden执行回收操作</li></ul><h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>年老代特点是垃圾回收比较少，标记整理算法是年老代算法。老年代如果使用标记复制算法需要复制很多对象，效率比较低</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>年轻代回收器：</p><ul><li>Serial收集器        使用标记-复制的单线程垃圾回收器</li><li>ParNew收集器    使用标记-复制的多线程垃圾回收器</li><li>Parallel Scavenge收集器     <em>和parnew区别：控制吞吐量</em></li></ul><p>年老代回收器：</p><ul><li>Serial Old收集器    <em>使用标记-整理算法单线程垃圾回收器</em></li><li>Parallel Old收集器 <em>使用标记-整理算法多线程垃圾回收器</em></li><li>CMS收集器</li></ul><p>全年龄收集器：G1</p><h4 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h4><p>CMS是年老代回收器</p><ul><li>初始标记（CM S initial mark） <em>单线程，会stop the world</em></li><li>并发标记（CM S concurrent mark）</li><li>重新标记（CM S remark） <em>多线程，会stop the world</em></li><li>并发清除（CM S concurrent sweep）</li></ul><p><img src="/resources/%E9%9D%A2%E8%AF%95-%E4%B8%AD%E4%BF%A1/cms.jpg" alt="cms"></p><h4 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h4><p>G1是基于分代理论设计的，可以同时在年轻代年老代使用。</p><p>G1将Java堆内存分成数个相等大小的区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>Region还有一种是专门存储大对象的Region，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p><p>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的<br>运作过程大致可划分为以下四个步骤：</p><ul><li>初始标记（Initial M arking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAM S<br>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要<br>停顿线程，但耗时很短，而且是借用进行M inor GC的时候同步完成的，所以G1收集器在这个阶段实际<br>并没有额外的停顿。</li><li>并发标记（Concurrent M arking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆<br>里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以<br>后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li>最终标记（Final M arking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留<br>下来的最后那少量的SATB记录。</li><li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回<br>收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region<br>构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧<br>Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行<br>完成的。</li></ul><p><img src="resources/%E9%9D%A2%E8%AF%95-%E4%B8%AD%E4%BF%A1/g1.jpg" alt="g1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2-垃圾收集算法&quot;&gt;&lt;a href=&quot;#2-垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;2.垃圾收集算法&quot;&gt;&lt;/a&gt;2.垃圾收集算法&lt;/h3&gt;&lt;p&gt;基于分代收集理论，可以分为年轻代、年老代两类收集算法。&lt;/p&gt;
&lt;p&gt;年轻代：标记复制&lt;/p</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术Java" scheme="https://yinxs2003.github.io/tags/%E6%8A%80%E6%9C%AFJava/"/>
    
  </entry>
  
  <entry>
    <title>概念-在Spring中如何解决循环依赖的问题</title>
    <link href="https://yinxs2003.github.io/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://yinxs2003.github.io/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>一般场景是一个Bean A依赖Bean B,而Bean B也依赖Bean A.<br>Bean A → Bean B → Bean A</p><p>当然我们也可以添加更多的依赖层次，比如：<br>Bean A → Bean B → Bean C → Bean D → Bean E → Bean A</p><h2 id="Spring发生了什么"><a href="#Spring发生了什么" class="headerlink" title="Spring发生了什么"></a>Spring发生了什么</h2><p>当 Spring 上下文加载所有 bean 时，它会尝试按照它们完全工作所需的顺序创建 bean。例如，如果我们没有循环依赖，就像下面的例子：</p><p>bean A → bean B → bean C</p><p>Spring将创建bean C，然后创建bean B（并将bean C注入其中），然后创建bean A（并将bean B注入其中）。</p><p>但是，当有循环依赖时，Spring 无法决定首先创建哪个 bean，因为它们相互依赖。在这些情况下，Spring 将在加载上下文时引发<em>BeanCurrentlyInCreationException</em>。</p><p>在 Spring 中使用<strong>构造函数注入</strong>时可能会发生这种情况；如果您使用其他类型的注入，您应该不会发现此问题，因为依赖项将在需要时注入，而不是在上下文加载时注入。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>让我们定义两个相互依赖的 bean（通过构造函数注入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularDependencyA</span><span class="params">(CircularDependencyB circB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circB = circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularDependencyB</span><span class="params">(CircularDependencyA circA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以为测试编写一个 Configuration 类，我们称之为<em>TestConfig*，它指定要扫描组件的基本包。假设我们的 bean 定义在包“ *com.baeldung.circulardependency</em> ”中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123; <span class="string">"com.baeldung.circulardependency"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们可以编写一个 JUnit 测试来检查循环依赖。测试可以为空，因为在上下文加载期间将检测到循环依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= &#123; TestConfig<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CircularDependencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCircularDependency_whenConstructorInjection_thenItFails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Empty test; we just want the context to load</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您尝试运行此测试，您将收到以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'circularDependencyA'</span>:</span><br><span class="line">Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure><h2 id="应对办法"><a href="#应对办法" class="headerlink" title="应对办法"></a>应对办法</h2><h3 id="重新设计"><a href="#重新设计" class="headerlink" title="重新设计"></a>重新设计</h3><p>当您具有循环依赖关系时，可能是您遇到了设计问题，并且职责没有很好地分开。您应该尝试正确地重新设计组件，以使它们的层次结构设计得很好，并且不需要循环依赖项。</p><p>如果您无法重新设计组件（可能有很多可能的原因：遗留代码、已经过测试且无法修改的代码、没有足够的时间或资源进行完整的重新设计……），可以尝试一些变通方法。</p><h3 id="使用-Lazy"><a href="#使用-Lazy" class="headerlink" title="使用@Lazy"></a>使用@Lazy</h3><p>打破循环的一种简单方法是说 Spring 懒惰地初始化其中一个 bean。也就是说：它不会完全初始化 bean，而是创建一个代理以将其注入另一个 bean。注入的Bean仅在首次需要时才完全创建。</p><p>要使用我们的代码尝试此操作，您可以将 CircularDependencyA 更改为以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularDependencyA</span><span class="params">(@Lazy CircularDependencyB circB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circB = circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您现在运行测试，您将看到这次错误不会发生。</p><h3 id="使用-Setter-Field-注入"><a href="#使用-Setter-Field-注入" class="headerlink" title="使用 Setter/Field 注入"></a>使用 Setter/Field 注入</h3><p>最流行的解决方法之一，也是<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html" target="_blank" rel="noopener">Spring 文档提出的</a>，是使用 setter 注入。</p><p>简单地说，如果您更改 bean 的连接方式以使用 setter 注入（或字段注入）而不是构造函数注入 - 这确实解决了问题。通过这种方式，Spring 创建了 bean，但在需要它们之前不会注入依赖项。</p><p>让我们这样做——让我们改变我们的类以使用 setter 注入，并将另一个字段 ( <em>message</em> )添加到<em>CircularDependencyB</em>以便我们可以进行适当的单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCircB</span><span class="params">(CircularDependencyB circB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circB = circB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircularDependencyB <span class="title">getCircB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message = <span class="string">"Hi!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCircA</span><span class="params">(CircularDependencyA circA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们必须对单元测试进行一些更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= &#123; TestConfig<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CircularDependencyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircularDependencyA <span class="title">getCircularDependencyA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CircularDependencyA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircularDependencyB <span class="title">getCircularDependencyB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CircularDependencyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenCircularDependency_whenSetterInjection_thenItWorks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CircularDependencyA circA = context.getBean(CircularDependencyA<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">"Hi!"</span>, circA.getCircB().getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释上面看到的注释：</p><p><em>@Bean</em>：告诉 Spring 框架必须使用这些方法来检索要注入的 bean 的实现。</p><p><em>@Test</em>：测试将从上下文中获取 CircularDependencyA bean 并断言其 CircularDependencyB 已正确注入，检查其<em>message</em>属性的值。</p><h3 id="使用-PostConstruct"><a href="#使用-PostConstruct" class="headerlink" title="使用@PostConstruct"></a>使用@PostConstruct</h3><p>打破循环的另一种方法是在其中一个 bean 上使用<em>@Autowired*注入一个依赖项，然后使用一个用</em>@PostConstruct*注释的方法来设置另一个依赖项。</p><p>我们的 bean 可以有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        circB.setCircA(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircularDependencyB <span class="title">getCircB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message = <span class="string">"Hi!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCircA</span><span class="params">(CircularDependencyA circA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以运行与之前相同的测试，因此我们检查循环依赖异常仍然没有被抛出并且依赖被正确注入。</p><h3 id="实现ApplicationContextAware和InitializingBean"><a href="#实现ApplicationContextAware和InitializingBean" class="headerlink" title="实现ApplicationContextAware和InitializingBean"></a>实现ApplicationContextAware和InitializingBean</h3><p>如果其中一个 bean 实现了<em>ApplicationContextAware</em>，则该 bean 可以访问 Spring 上下文并可以从那里提取另一个 bean。实现<em>InitializingBean</em>我们表明这个 bean 在它的所有属性都被设置后必须做一些动作；在这种情况下，我们想手动设置我们的依赖项。</p><p>我们的 bean 的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyA</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircularDependencyB <span class="title">getCircB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> circB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        circB = context.getBean(CircularDependencyB<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(<span class="keyword">final</span> ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        context = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularDependencyB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message = <span class="string">"Hi!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCircA</span><span class="params">(CircularDependencyA circA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，我们可以运行之前的测试，并看到没有抛出异常并且测试按预期工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h2&gt;&lt;p&gt;一般场景是一个Bean A依赖Bean B,而Bean B也依赖Bean A.&lt;br&gt;Bean A </summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java-jstack查看线程状态</title>
    <link href="https://yinxs2003.github.io/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>https://yinxs2003.github.io/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2021-05-25T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增</p><p>高了、出现了死锁、死循环等，我们该如何分析呢？</p><p>由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要</p><p>看下jvm的内部线程的执行情况，然后再进行分析查找出原因。</p><p>用法：jstack <pid></p><p><img src="/images/jstack-1.png" alt="img"></p><p>java线程的6种状态</p><p><strong>初始态（NEW）</strong></p><p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p><p><strong>运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。</strong></p><p>就绪态</p><p>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。</p><p>所有就绪态的线程存放在就绪队列中。</p><p>运行态</p><p>获得CPU执行权，正在执行的线程。</p><p>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</p><p><strong>阻塞态（BLOCKED）</strong></p><p>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。</p><p>而在Java中，阻塞态专指请求锁失败时进入的状态。</p><p>由一个阻塞队列存放所有阻塞态的线程。</p><p>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。</p><p><strong>等待态（WAITING）</strong></p><p>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。</p><p>也有一个等待队列存放所有等待态的线程。</p><p>线程处于等待态表示它需要等待其他线程的指示才能继续运行。</p><p>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</p><p><strong>超时等待态（TIMED_WAITING）</strong></p><p>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；</p><p>进入该状态后释放CPU执行权 和 占有的资源。</p><p>与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p><p><strong>终止态（TERMINATED）</strong></p><p>线程执行结束后的状态。</p><p><strong>使用jstack查找死锁</strong></p><p>构造死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread1 拿到了 obj1 的锁！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 停顿2秒的意义在于，让Thread2线程拿到obj2的锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread1 拿到了 obj2 的锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread2 拿到了 obj2 的锁！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 停顿2秒的意义在于，让Thread1线程拿到obj1的锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread2 拿到了 obj1 的锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jstack 11464</p><p><img src="/images/jstack-2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000017bfeca3e80 (object 0x000000008a0e36e8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000017bfeca5e80 (object 0x000000008a0e36f8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">        at TestDeadLock$Thread2.run(TestDeadLock.java:40)</span><br><span class="line">        - waiting to lock &lt;0x000000008a0e36e8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000008a0e36f8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(java.base@9.0.4&#x2F;Thread.java:844)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">        at TestDeadLock$Thread1.run(TestDeadLock.java:22)</span><br><span class="line">        - waiting to lock &lt;0x000000008a0e36f8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000008a0e36e8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(java.base@9.0.4&#x2F;Thread.java:844)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增&lt;/p&gt;
&lt;p&gt;高了、出现了死锁、死循环等，我们该如何分析呢？&lt;/p&gt;
&lt;p&gt;由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要&lt;/p&gt;
&lt;p&gt;看下jvm的内部线程的</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="技术Java" scheme="https://yinxs2003.github.io/tags/%E6%8A%80%E6%9C%AFJava/"/>
    
  </entry>
  
  <entry>
    <title>Java-使用guava缓存的例子</title>
    <link href="https://yinxs2003.github.io/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>https://yinxs2003.github.io/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/</id>
    <published>2021-04-28T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p>使用guava缓存数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, String&gt; localCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuavaTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        initDataSource();</span><br><span class="line">        initLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localCache = CacheBuilder.newBuilder().maximumSize(<span class="number">5</span>).expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String value = getFromDataSource(key);</span><br><span class="line">                        localCache.put(key, value);</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFromDataSource</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSourceMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFromLocalCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> localCache.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataSourceMap.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">"key4"</span>, <span class="string">"value4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">        GuavaTest g = <span class="keyword">new</span> GuavaTest();</span><br><span class="line">        System.out.println(g.getFromLocalCache(<span class="string">"key1"</span>));</span><br><span class="line">        System.out.println(g.getFromLocalCache(<span class="string">"key2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的的例子，需要使用数据源，读不到数据从数据源里读取。如果单纯使用guava当作缓存，读取不到返回null怎么实现呢？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.cpp.cache.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Optional;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.RemovalListener;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.RemovalNotification;</span><br><span class="line"><span class="keyword">import</span> com.yidian.cpp.cache.LocalCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalCacheImpl</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">LocalCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_SIZE = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_TIME = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;K, Optional&lt;V&gt;&gt; caches = CacheBuilder.newBuilder().maximumSize(MAX_SIZE)</span><br><span class="line">            .expireAfterAccess(EXPIRE_TIME, TimeUnit.HOURS).removalListener(<span class="keyword">new</span> RemovalListener&lt;K, Optional&lt;V&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;K, Optional&lt;V&gt;&gt; notification)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Optional&lt;V&gt; opt = caches.get(key, <span class="keyword">new</span> Callable&lt;Optional&lt;V&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Optional&lt;V&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// TODO获取数据，加入缓存</span></span><br><span class="line">                <span class="keyword">return</span> Optional.fromNullable(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> opt.isPresent() ? opt.get() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        caches.put(key, Optional.of(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        caches.invalidate(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.cpp.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocalCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value associated with &#123;<span class="doctag">@code</span> key&#125; in this cache, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; if there is no cached value for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates &#123;<span class="doctag">@code</span> value&#125; with &#123;<span class="doctag">@code</span> key&#125; in this cache. If the cache</span></span><br><span class="line"><span class="comment">     * previously contained a value associated with &#123;<span class="doctag">@code</span> key&#125;, the old value</span></span><br><span class="line"><span class="comment">     * is replaced by &#123;<span class="doctag">@code</span> value&#125;.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Discards any cached value for key &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.cpp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yidian.cpp.cache.LocalCache;</span><br><span class="line"><span class="keyword">import</span> com.yidian.cpp.cache.impl.LocalCacheImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LocalCache&lt;String, String&gt; localCache = <span class="keyword">new</span> LocalCacheImpl();</span><br><span class="line">        localCache.put(<span class="string">"key"</span>,<span class="string">"v1"</span>);</span><br><span class="line">        localCache.remove(<span class="string">"key"</span>);</span><br><span class="line">        String a = localCache.get(<span class="string">"key"</span>);</span><br><span class="line">        System.out.println(a == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用guava缓存数据源&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://yinxs2003.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>概念-Mysql之redolog_binglog_mvcc.md</title>
    <link href="https://yinxs2003.github.io/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/"/>
    <id>https://yinxs2003.github.io/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/</id>
    <published>2021-04-13T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h2><p>数据在内存中的这个过程叫做data buffer，数据已经存储在磁盘上叫data file。</p><p>事务的日志也一样，在内存中叫log  buffer，在磁盘上叫log file。</p><p>data buffer的数据定时写入到data file，这个定时执行的过程是checkpoint。</p><p>如果checkpoint失败，在恢复时候，只需要做最后一次redo log或者undo log的操作就可以完成故障恢复</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>确保事务的持久性。<br>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p><h3 id="什么时候产生"><a href="#什么时候产生" class="headerlink" title="什么时候产生"></a>什么时候产生</h3><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p><h3 id="什么时候释放"><a href="#什么时候释放" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><h3 id="对应的物理文件"><a href="#对应的物理文件" class="headerlink" title="对应的物理文件"></a>对应的物理文件</h3><p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2<br>innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。<br>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2<br>关于文件的大小和数量，由一下两个参数配置<br>innodb_log_file_size 重做日志文件的大小。<br>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。<br>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p><p>　　<img src="https://images2017.cnblogs.com/blog/380271/201801/380271-20180128095300756-752816619.png" alt="img"></p><p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<br>1 Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。<br>2 每个事务提交时会将重做日志刷新到重做日志文件。<br>3 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件<br>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。<br>因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。<br>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：<br>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。<br>这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</p><h3 id="什么时候产生-1"><a href="#什么时候产生-1" class="headerlink" title="什么时候产生"></a>什么时候产生</h3><p>事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p><h3 id="什么时候释放-1"><a href="#什么时候释放-1" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>当事务提交之后，undo log并不能立马被删除，<br>而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><h2 id="binglog"><a href="#binglog" class="headerlink" title="binglog"></a>binglog</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</p><p>用于数据库的基于时间点的还原</p><h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h2><p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p><p>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息</p><p>也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p><h3 id="什么时候产生-2"><a href="#什么时候产生-2" class="headerlink" title="什么时候产生"></a>什么时候产生</h3><p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p><p>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p><p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。<br>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p><h3 id="什么时候释放-2"><a href="#什么时候释放-2" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CheckPoint&quot;&gt;&lt;a href=&quot;#CheckPoint&quot; class=&quot;headerlink&quot; title=&quot;CheckPoint&quot;&gt;&lt;/a&gt;CheckPoint&lt;/h2&gt;&lt;p&gt;数据在内存中的这个过程叫做data buffer，数据已经存储在磁盘上叫da</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Es排除节点</title>
    <link href="https://yinxs2003.github.io/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/"/>
    <id>https://yinxs2003.github.io/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Es集群中有一个节点性能很差，会导致Es整体查询变慢，当该物理节点被关闭但存在部分分片没有分配到其他节点上。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因为配置文件中被关闭的机器ip是存在的，Es存在一个探活过程，所以这些分片没有被自动迁移到其他节点。</p><p>可以通过Exclude该机器的IP来动态删除该机器，删除10.1.1.1节点命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT http://10.1.1.10:9210/_cluster/settings -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">"transient" :&#123;</span></span><br><span class="line"><span class="string">"cluster.routing.allocation.exclude._ip" : "10.1.1.1"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;Es集群中有一个节点性能很差，会导致Es整体查询变慢，当该物理节点被关闭但存在部分分片没有分配到其他节点上。&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://yinxs2003.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>算法-数组中的第K个最大元素</title>
    <link href="https://yinxs2003.github.io/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>https://yinxs2003.github.io/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你可以假设 k 总是有效的，且 <span class="number">1</span> ≤ k ≤ 数组的长度。</span><br></pre></td></tr></table></figure><p>该题可以使用堆排序进行实现，时间复杂度为nlogk</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.tree.BinaryHeap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[child] &lt;= arr[parent]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(arr, child, parent);</span><br><span class="line"></span><br><span class="line">            parent = child;</span><br><span class="line">            child = <span class="number">2</span> * child + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        BinaryHeap b = <span class="keyword">new</span> BinaryHeap();</span><br><span class="line">        b.insertLevelOrder(arr);</span><br><span class="line">        b.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            buildBigHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            buildBigHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[arr.length - k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Solution2 s = <span class="keyword">new</span> Solution2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>,<span class="number">4</span>,<span class="number">123</span>&#125;;</span><br><span class="line"></span><br><span class="line">        s.print(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = s.findKthLargest(arr, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://yinxs2003.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法-八大排序算法之堆排序</title>
    <link href="https://yinxs2003.github.io/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://yinxs2003.github.io/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-06T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，请你将该数组升序排列。 </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="堆排序的性质"><a href="#堆排序的性质" class="headerlink" title="堆排序的性质"></a>堆排序的性质</h3><ol><li>堆是一颗满二叉树</li><li>子节点和父节点下标关系：leftChild = parent * 2 + 1</li><li>构建大顶堆是上浮操作，上浮操作是选择子节点中较大的节点，并和parent节点比较，子节点较大则交换子节点和parent节点</li><li>不稳定排序，时间复杂度O(nlogn)</li></ol><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>使用堆排序进行排序操作，堆排序可以分成两个步骤</p><ol><li>构建大顶堆，应该是从第向上执行遍历（上浮），所以循环从数组末尾向前循环</li><li>打印或者保存第一个节点</li><li>交换第一个和最后一个节点，缩小数组范围并继续执行第一步</li></ol><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.tree.UnOrderBTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建大顶堆</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * child = parent * 2 + 1;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(Integer[] nums, <span class="keyword">int</span> parent, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[child] &lt; nums[parent]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(nums, child, parent);</span><br><span class="line"></span><br><span class="line">            parent = child;</span><br><span class="line">            child = child * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(Integer[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            buildBigHeap(nums, i, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line"></span><br><span class="line">            buildBigHeap(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Integer[] arr1)</span> </span>&#123;</span><br><span class="line">        UnOrderBTree unOrderBTree2 = <span class="keyword">new</span> UnOrderBTree();</span><br><span class="line">        unOrderBTree2.insertLevelOrder(arr1);</span><br><span class="line">        unOrderBTree2.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        Integer[] arr1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        s.print(arr1);</span><br><span class="line">        s.heapSort(arr1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://yinxs2003.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法-快速排序</title>
    <link href="https://yinxs2003.github.io/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://yinxs2003.github.io/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-01T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序1"><a href="#快速排序1" class="headerlink" title="快速排序1"></a>快速排序1</h2><p>以第一个数字6作为基数，使用双指针i,j进行双向遍历：</p><ul><li>1、i从左往右寻找第一位大于基数（6）的数字，j从右往左寻找第一位小于基数（6）的数字；</li><li>2、找到后将两个数字进行交换。继续循环交换直到i&gt;=j结束循环；</li><li>3、最终指针i=j,此时交换基数和i(j)指向的数字即可将数组划分为小于基数（6）/基数（6）/大于基数（6）的三部分，即完成一趟快排；<img src="/images/quickSort1.jpeg" alt="quickSort1"  /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, p - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, l, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main m = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        m.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序2"><a href="#快速排序2" class="headerlink" title="快速排序2"></a>快速排序2</h2><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（交换后index++，结束后返回index-1）。在这个分区退出之后，该基准就处于数列的中间位置（index-1）。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree.quicksort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> partitionIndex = partition(arr, left, right);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = left;</span><br><span class="line">        <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        s.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        log.info(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快速排序1&quot;&gt;&lt;a href=&quot;#快速排序1&quot; class=&quot;headerlink&quot; title=&quot;快速排序1&quot;&gt;&lt;/a&gt;快速排序1&lt;/h2&gt;&lt;p&gt;以第一个数字6作为基数，使用双指针i,j进行双向遍历：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、i从左往右寻找第一位大于基数（</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://yinxs2003.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>概念-Java内存模型</title>
    <link href="https://yinxs2003.github.io/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/"/>
    <id>https://yinxs2003.github.io/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</id>
    <published>2021-03-23T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型被提出的背景"><a href="#Java内存模型被提出的背景" class="headerlink" title="Java内存模型被提出的背景"></a>Java内存模型被提出的背景</h3><p>Java内存模型被提出主要是为解决如下问题</p><ul><li>硬件效率问题</li><li>计算机内存比CPU慢很多，所以需要在CPU和主存之间加寄存器和高速缓存。</li><li>缓存一致性问题</li><li>代码指令重排导致多线程执行的“乱序问题”</li></ul><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，简称 JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p><h3 id="Java内存模型的组成"><a href="#Java内存模型的组成" class="headerlink" title="Java内存模型的组成"></a>Java内存模型的组成</h3><ul><li><p>主内存</p><p>Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与介绍物理硬件的主内存名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p></li><li><p>本地内存</p><p>每个线程都有自己的本地内存。线程本地内存存有主存中变量的副本。</p></li></ul><img src="/images/JMM2.png" alt="JMM2"/><h3 id="Java内存模型和计算机内存架构"><a href="#Java内存模型和计算机内存架构" class="headerlink" title="Java内存模型和计算机内存架构"></a>Java内存模型和计算机内存架构</h3><h4 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h4><img src="/images/JMM3.png" alt="JMM3"  /><h4 id="Java线程与硬件处理器"><a href="#Java线程与硬件处理器" class="headerlink" title="Java线程与硬件处理器"></a>Java线程与硬件处理器</h4><img src="/images/JMM4.png" alt="JMM4"  /><h4 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h4><p>通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有本地内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p><img src="/images/JMM5.png" alt="JMM5"  /><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>Java中的synchronize是使用监视器（monitor）实现的。Java中的每个对象都与一个可以锁定或者解锁的监视器相关联。只有一个线程能够持有某个监视器上的锁，任何其他试图锁定该监视器的线程都将阻塞，直至他们可以获得该监视器上的锁。线程t可以多次锁定某个特定的监视器，而每个解锁操作都会抵消一次锁定操作的效果。</p><p>synchronized计算的是对象的引用，然后它试图执行在该对象的监视器上的锁定动作，并且锁定动作成功完成之前不会执行下一步动作。在锁定动作执之后，synchronized语句体被执行。如果该语句体执行结束，无论是正常结束还是猝然结束都会在相同的监视器上执行解锁动作。</p><p>synchronized方法在被调用时会自动执行锁定动作。它的方法体在该锁定动作成功完成之前是不会被执行的。如果该方法是实例方法，那么它会锁定与在其上调用该方法的<strong>实例相关联的监视器</strong>。如果该方法是static的，那么它会锁定与与表示定义该方法的类的Class对象相关联的监视器。</p><h4 id="wait、notify和notifyAll"><a href="#wait、notify和notifyAll" class="headerlink" title="wait、notify和notifyAll"></a>wait、notify和notifyAll</h4><p>每个对象，除了具有相关联的监视器，还有相关联的等待集，即一个线程集。</p><p>当一个对象被创建时，它的等待集为空。向等待集中添加线程或者移除线程的基础动作都是原子性的。等待集只能通过wait、notify、notifyAll方法进行操作</p><h4 id="内存模型定义"><a href="#内存模型定义" class="headerlink" title="内存模型定义"></a>内存模型定义</h4><p>给定一个程序和该程序的执行轨迹，内存模型可以描述该执行轨迹是否是该程序的一次合法执行。Java编程语言的内存模型是通过如下方式实现的：检查在执行轨迹中的每个读操作。并依据特定的规则，检查该读操作观察到的写操作是否有效。</p><p>内存模型描述了程序的可能的行为。Java语言实现可以按照其喜好产生任何代码，只要程序所有的执行过程都会产生内存模型可以预测的结果。</p><p>这对Java语言的实现着提供了很大的自由度区执行大量的代码转换，包括冲排序动作和移除不必要的同步。</p><h4 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h4><p>两个动作可以通过happen-before来进行关系排序。如果一个动作在另一个动作之前发生，那么第一个动作对于第二个动作就是可视的，并且第一个动作排在第二个动作之前。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Java内存模型被提出的背景&quot;&gt;&lt;a href=&quot;#Java内存模型被提出的背景&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型被提出的背景&quot;&gt;&lt;/a&gt;Java内存模型被提出的背景&lt;/h3&gt;&lt;p&gt;Java内存模型被提出主要是为解决如下问题&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>算法-二叉树剪枝</title>
    <link href="https://yinxs2003.github.io/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/"/>
    <id>https://yinxs2003.github.io/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/buildTree.png" alt="buildTree.png"></p><ol start="2"><li>这个题得用后序遍历，用前序遍历删不干净</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/buildTree.png&quot; alt=&quot;buildTree.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;这个题得用后序遍历，用前序遍历删不干净&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://yinxs2003.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法-重建二叉树</title>
    <link href="https://yinxs2003.github.io/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://yinxs2003.github.io/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/buildTree.png" alt="buildTree.png"></p><p>题目分析</p><ol><li>前序遍历的特点是preorder[0]是根节点</li><li>中序遍历的特点是跟节点左边是左子树，跟节点右边是右子树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, rootIndex + <span class="number">1</span>),</span><br><span class="line">                Arrays.copyOfRange(inorder, <span class="number">0</span>, rootIndex));</span><br><span class="line"></span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder, rootIndex+<span class="number">1</span>, len),</span><br><span class="line">                Arrays.copyOfRange(inorder, rootIndex+<span class="number">1</span>, len));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preorder = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inorder = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        TreeNode root = test.buildTree(preorder, inorder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python版本更好理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder , inorder)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        loc = inorder.index(preorder[<span class="number">0</span>]) <span class="comment"># 在中序遍历中查询当前层的根节点</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span> : loc + <span class="number">1</span>], inorder[ : loc])  <span class="comment"># 每次都是去掉头节点所以从1开始</span></span><br><span class="line">        root.right = self.buildTree(preorder[loc + <span class="number">1</span> : ], inorder[loc + <span class="number">1</span>: ])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/buildTree.png&quot; alt=&quot;buildTree.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;题目分析&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前序遍历的特点是preorder[0]是根节点&lt;/li&gt;
&lt;li&gt;中序遍历的特点是跟节点左边是左子树，跟节点右边是右</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="算法" scheme="https://yinxs2003.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux-vim正则查找</title>
    <link href="https://yinxs2003.github.io/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/"/>
    <id>https://yinxs2003.github.io/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p>使用vim查询<strong>spend=14435</strong>的命令是,</p><p>/spend=[1-9]\{5,5\}</p><p>其中[1-9]表示任意一个1～9的数字</p><p>\{5,5\}上面的数字表示出现了5次，即匹配14435</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用vim查询&lt;strong&gt;spend=14435&lt;/strong&gt;的命令是,&lt;/p&gt;
&lt;p&gt;/spend=[1-9]&#92;{5,5&#92;}&lt;/p&gt;
&lt;p&gt;其中[1-9]表示任意一个1～9的数字&lt;/p&gt;
&lt;p&gt;&#92;{5,5&#92;}上面的数字表示出现了5次，即匹配14435&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://yinxs2003.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>概念-Spring源码</title>
    <link href="https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/"/>
    <id>https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聊聊Spring"><a href="#聊聊Spring" class="headerlink" title="聊聊Spring"></a>聊聊Spring</h2><ol><li>控制反转思想IOC</li><li>依赖注入AOP</li><li>bean的生命周期</li><li>循环依赖</li><li>三级缓存</li><li>FactoryBean和BeanFactory区别</li><li>ApplicationContxt和BeanFactory区别</li><li>Spring中的设计模式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;聊聊Spring&quot;&gt;&lt;a href=&quot;#聊聊Spring&quot; class=&quot;headerlink&quot; title=&quot;聊聊Spring&quot;&gt;&lt;/a&gt;聊聊Spring&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制反转思想IOC&lt;/li&gt;
&lt;li&gt;依赖注入AOP&lt;/li&gt;
&lt;li&gt;bean</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>概念-CMS垃圾回收器</title>
    <link href="https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CMS垃圾回收"><a href="#CMS垃圾回收" class="headerlink" title="CMS垃圾回收"></a>CMS垃圾回收</h3><p>CMS垃圾回收收集所有代。它会使用最小的资源来进行大多数垃圾回收工作，通常低停顿并发收集器不会复制或者压缩活动的对象。在不移动活动对象的情况下完成垃圾回收。如果内存碎片导致无法正常分配内存，请分配更大的堆内存。</p><p>CMS在年老带执行垃圾收集会氛围以下几个阶段</p><table><thead><tr><th align="left">Phase</th><th>Description</th></tr></thead><tbody><tr><td align="left">(1) Initial Mark <em>(Stop the World Event)</em></td><td>Objects in old generation are “marked” as reachable including those objects which may be reachable from young generation. Pause times are typically short in duration relative to minor collection pause times.</td></tr><tr><td align="left">(2) Concurrent Marking</td><td>Traverse the tenured generation object graph for reachable objects concurrently while Java application threads are executing. Starts scanning from marked objects and transitively marks all objects reachable from the roots. The mutators are executing during the concurrent phases 2, 3, and 5 and any objects allocated in the CMS generation during these phases (including promoted objects) are immediately marked as live.</td></tr><tr><td align="left">(3) Remark <em>(Stop the World Event)</em></td><td>Finds objects that were missed by the concurrent mark phase due to updates by Java application threads to objects after the concurrent collector had finished tracing that object.</td></tr><tr><td align="left">(4) Concurrent Sweep</td><td>Collects the objects identified as unreachable during marking phases. The collection of a dead object adds the space for the object to a free list for later allocation. Coalescing of dead objects may occur at this point. Note that live objects are not moved.</td></tr><tr><td align="left">(5) Resetting</td><td>Prepare for next concurrent collection by clearing data structures.</td></tr></tbody></table><h3 id="查看垃圾收集步骤"><a href="#查看垃圾收集步骤" class="headerlink" title="查看垃圾收集步骤"></a>查看垃圾收集步骤</h3><p>我们来一步一步查看CMS垃圾收集器的动作：</p><ol><li><p>CMS的堆结构</p><p>堆被分成如下三个部分</p><p><img src="/images/jvm-Slide1.png" alt="img"></p><p>年轻代被划分成多个区域，分别是一个Eden区和两个survivor区。</p><p>年老代被划分成一整个连续的区域，年老代垃圾回收通常在原位置进行回收，除非有full GC，否则年老代不进行压缩。</p></li><li><p>CMS在年轻代GC如何工作</p><p><img src="/images/jvm-Slide2.png" alt="img"></p><p>在下图，年轻代是绿色表示，年老代是蓝色表示。如果你的程序已经运行了一段时间，CMS有可能是这样，对象在年老代是散落分布的。</p><p>对于CMS的年老代的内存释放，如果不是FullGC，不会进行内存空间压缩。</p></li><li><p>收集年轻代</p><p>活着的对象从Eden区和survivior区拷贝到另一个survivor区。任何旧对象达到年龄阈值都会被允许进入老年代</p><p><img src="/images/jvm-Slide3.png" alt="jvm-Slide3.png"></p></li><li><p>年轻代收集之后</p><p>年轻代收集之后，Eden区被清理，且两个survivor中的一个被清空</p><p><img src="/images/jvm-Slide4.png" alt="jvm-Slide4.png"></p><p>新提升对象在图中以深蓝色表示。绿色代表是年轻代存活且没有被允许进入老年代的对象</p></li><li><p>CMS收集器的年老代</p><p>两次Stop the world发生在：初始化标记和重新标记。当年老代达到一定占用率，CMS开始收集垃圾。</p><p><img src="/images/jvm-Slide5.png" alt="jvm-Slide5.png"></p><p>（1）可达的对象被标记时候，初始化标记会发生短暂stop-the-world现象、</p><p>（2）并发标记寻找存活的对象并继续执行寻找</p><p>（3）在重新标记阶段，会重新标记在并发标记阶段中没有标记且满足被标记条件的对象</p></li><li><p>年老代收集 - 并发清除</p><p>对象没有再上一个阶段被标记将会被释放，且没有内存区域压缩</p><p><img src="/images/jvm-Slide6.png" alt="jvm-Slide6.png"></p><p>注意：Unmarked objects == Dead Objects</p></li><li><p>年老代收集 - 清除之后</p><p>在（4）清除阶段，你可以看到大量的内存被释放，并且可以看出没有执行压缩内存操作</p><p><img src="/images/jvm-Slide7.png" alt="jvm-Slide7.png"></p></li></ol><p>​        最后CMS收集器将进入（5）重置阶段，并且等待达到下次GC阈值</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="">G1垃圾回收器</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CMS垃圾回收&quot;&gt;&lt;a href=&quot;#CMS垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收&quot;&gt;&lt;/a&gt;CMS垃圾回收&lt;/h3&gt;&lt;p&gt;CMS垃圾回收收集所有代。它会使用最小的资源来进行大多数垃圾回收工作，通常低停顿并发收集器不会复制或</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>概念-G1垃圾回收器2</title>
    <link href="https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/"/>
    <id>https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p>G1收集器采用了另一种分配堆的方法。 后面的图片逐步检查了G1系统。</p><h3 id="G1堆结构"><a href="#G1堆结构" class="headerlink" title="G1堆结构"></a>G1堆结构</h3><p>G1堆事一个内存区域被切分为多个相同大小的区域（regions）</p><p><img src="/images/Slide8.png" alt="Slide8.png"></p><p>区域大小是在jvm一启动就被选择的。JVM通常会生成两千个区域，每个区域大小相同，在1到32MB之间</p><h3 id="G1堆分配"><a href="#G1堆分配" class="headerlink" title="G1堆分配"></a>G1堆分配</h3><p>事实上，这些区域被映射成Eden、Survivor和年老代</p><p><img src="/images/G1-Slide9.png" alt="G1-Slide9.png"></p><p>图片中的颜色显示了哪个区域与哪个角色相关联。 将活动对象从一个区域撤离（即复制或移动）到另一个区域。 区域被设计为并行或不停止其他应用程序线程的情况下并行垃圾收集。</p><p>如图所示，区域被分成Eden、Suivivor和年老代。此外还有第四种巨大区域。这些区域被设计成存放大于标准区域50%的对象。他们被一个连续集合区域进行存储。最后一种区域是堆未使用区域。</p><p>注意：在撰写本文时，尚未优化庞大对象的过程。因此应避免创建这种大小的对象。</p><h3 id="G1年轻代"><a href="#G1年轻代" class="headerlink" title="G1年轻代"></a>G1年轻代</h3><p>年轻代堆被分成了大概两千个区域，区域大小在1MB到32MB之间。蓝色区域存储年老代对象，绿色区域存储年轻代对象。</p><p><img src="/images/G1-Slide10.png" alt="G1-Slide10.png"></p><p>注意：这些区域不需要像旧的垃圾收集器一样是内存连续的</p><h3 id="G1的一次Young-GC"><a href="#G1的一次Young-GC" class="headerlink" title="G1的一次Young GC"></a>G1的一次Young GC</h3><p>存活的对象撤离（移动或者拷贝）一个或者多个存活区域，如果年龄阈值满足，一些对象会被提升到年老代区域。</p><p><img src="/images/G1-Slide11.png" alt="G1-Slide11.png"></p><p>这是一次stop-the-world的暂停。Eden大小和survivor大小在下一次yongGC被计算。“计票”（accounting）信息被保存用来帮助计算这些区域的大小。诸如暂停时间目标之类的事情也要考虑在内。</p><p>这种方法使调整区域大小变得非常容易，可以根据需要增大或缩小区域。</p><h3 id="G1的YoungGC结束"><a href="#G1的YoungGC结束" class="headerlink" title="G1的YoungGC结束"></a>G1的YoungGC结束</h3><p>存活的对象已经“撤离”到survivor区域或者年老代区域。</p><p><img src="/images/G1-Slide12.png" alt="G1-Slide12.png"></p><p>最近提升对象用dark blue表示，survivor区域时绿色。</p><p>关于G1，总结如下：</p><ol><li>堆是一整个内存被切分成区域</li><li>年轻代由一组不连续的区域组成，这使得改变区域大小非常容易</li><li>年轻代垃圾回收或者yong GC会stop-the-world，所有的应用线程都会被停止。(Young generation garbage collections, or young GCs, are stop the world events. All application threads are stopped for the operation.)</li><li>年轻的GC使用多个线程并行完成。</li><li>将活动对象复制到新的幸存者或较旧的地区。</li></ol><h3 id="G1年老代的垃圾收集"><a href="#G1年老代的垃圾收集" class="headerlink" title="G1年老代的垃圾收集"></a>G1年老代的垃圾收集</h3><p>像CMS收集器一样，G1收集器被设计为用于旧对象的低暂停收集器。 下表描述了旧版本的G1收集阶段。</p><h4 id="G1收集阶段-并发标记周期阶段"><a href="#G1收集阶段-并发标记周期阶段" class="headerlink" title="G1收集阶段-并发标记周期阶段"></a>G1收集阶段-并发标记周期阶段</h4><p>G1收集器在老年代上执行以下阶段。 请注意，某些阶段是年轻一代收集的一部分。</p><table><thead><tr><th>Phase</th><th>Description</th></tr></thead><tbody><tr><td>(1) 初始标记 <em>(Stop the World Event)</em></td><td>这会stop-the-world。 对于G1来说, 它可以像普通young GC一样执行。标记survivor区域(root regions) ，因为这些区域可能引用了老年代对象。</td></tr><tr><td>(2) 根区域扫描</td><td>扫描survivor区域来获得年老代的参考（Scan survivor regions for references into the old generation），当程序在运行时会发生这种情况。这个阶段必须完成之后fullGC才能发生。</td></tr><tr><td>(3) 并发标记</td><td>在堆中查找活动对象，在应用运行时候发生，。这个阶段可以被Young GC打断。</td></tr><tr><td>(4) 重新标记(Stop the World Event)</td><td>完成堆中存活对象的标记。使用一个叫snapshot-at-the-beginning (SATB)的算法要比CMS用的算法要快的多。</td></tr><tr><td>(5) 清除 <em>(Stop the World Event and Concurrent)</em></td><td>对活动对象进行计数（accounting）和并完全清空区域。 （停止世界）<br/>清除RememberSet（RSet）。 （停止世界）<br/>重置空区域并将他们返回到空闲列表。 （并发）</td></tr><tr><td>(<em>) Copying *(Stop the World Event)</em></td><td>这些操作会stop-the-world 以保证活着的对象撤离到新的未使用的区域。该操作可以被记录为[GC pause(young)]。或者年轻、年老代区域被标记为[GC pause (mixed)].</td></tr></tbody></table><h3 id="G1老年代垃圾收集详解"><a href="#G1老年代垃圾收集详解" class="headerlink" title="G1老年代垃圾收集详解"></a>G1老年代垃圾收集详解</h3><p>在定义了阶段之后，让我们看一下，他们如何与G1收集器中的旧版本就行交互。</p><h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h4><p>初始标记对象，在年轻代被执行。在日志中被记录为GC pause (young)(inital-mark).</p><p><img src="/images/G1-Slide13.png" alt="G1-Slide13.png"></p><h4 id="并发标记阶段"><a href="#并发标记阶段" class="headerlink" title="并发标记阶段"></a>并发标记阶段</h4><p>如果空的区域被找到，他们在重新标记阶段会被立即移除。并且，计数（acounting）信息会决定存活度计算结果。</p><p><img src="/images/G1-Slide14.png" alt="G1-Slide14.png"></p><h4 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h4><p>空区域被删除并回收，并且在这阶段会计算所有区域的区域存活度（Region liveness ）。</p><p><img src="/images/G1-Slide15.png" alt="G1-Slide15.png"></p><h4 id="拷贝-清除阶段"><a href="#拷贝-清除阶段" class="headerlink" title="拷贝/清除阶段"></a>拷贝/清除阶段</h4><p>G1选择“存活度”(liveness)最低的区域，这些区域可以以最快速度被收集。这些区域在执行young GC时候被收集。在日志中被记录为[GC pause (mixed)]。所以年轻代和年老代可以被同时收集。</p><h4 id="拷贝-清除阶段之后"><a href="#拷贝-清除阶段之后" class="headerlink" title="拷贝/清除阶段之后"></a>拷贝/清除阶段之后</h4><p>选定的区域被收集且被压缩，在图中分别用深蓝色和深绿色所表示</p><p><img src="/images/G1-Slide17.png" alt="G1-Slide17.png"></p><h3 id="G1年老代总结"><a href="#G1年老代总结" class="headerlink" title="G1年老代总结"></a>G1年老代总结</h3><p>总而言之，关于旧一代的G1垃圾回收，我们可以提出一些关键点:</p><ul><li>并发标记阶段<ul><li>活跃度信息是在应用线程运行的被并行计算的</li><li>在活着的对象“撤离”时间段内，并且这些区域即将被回收，在这个时候定义活跃度信息。</li></ul></li><li>并发标记阶段<ul><li>使用SATB算法，该算法比CMS使用的算法快得多。</li><li>完全为空的区域将被回收</li></ul></li><li>拷贝清理阶段<ul><li>年轻代年老代可以同时执行回收操作</li><li>年老代区域基于它们的活跃度被选择是否回收</li></ul></li></ul><p><strong>剩下的日志查看还没有翻译</strong></p><h4 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h4><p><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;G1收集器采用了另一种分配堆的方法。 后面的图片逐步检查了G1系统。&lt;/p&gt;
&lt;h3 id=&quot;G1堆结构&quot;&gt;&lt;a href=&quot;#G1堆结构&quot; class=&quot;headerlink&quot; title=&quot;G1堆结构&quot;&gt;&lt;/a&gt;G1堆结构&lt;/h3&gt;&lt;p&gt;G1堆事一个内存区域被切分为多个</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>概念-G1垃圾回收器1</title>
    <link href="https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/"/>
    <id>https://yinxs2003.github.io/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="G1垃圾回收"><a href="#G1垃圾回收" class="headerlink" title="G1垃圾回收"></a>G1垃圾回收</h3><p>G1（Garbage-First） 收集器是为服务器准备的垃圾回收器，是为很多核大内存服务器准备的垃圾回收器。它在达到高吞吐量时满足了GC停顿时间可预测这样的一个目标。在Oracle JDK 7 update4 及以后的版本被支持。G1收集器是为如下程序设计：</p><ul><li>垃圾收集于应用线程之间是并发的</li><li>紧凑的自由空间且没有较长的GC停顿时间</li><li>需要更可以预测的GC停顿时间</li><li>不想牺牲很多吞吐性能</li><li>不需要更大的Java堆</li></ul><p>G1计划被当作CMS的长期的替代品。相比CMS，很多不同把G1变成一个更好的解决方案。</p><ul><li>G1是一个压缩收集器，G1垃圾回收器依赖于区域（regions），避免使用空闲列表进行分配（avoid the use of fine-grained free lists for allocation）。这大大简化了垃圾回收器的各个部分，并消除了潜在的碎片问题</li><li>对比CMS，G1垃圾收集器提供更加可预测的GC停顿时间，并允许用户指定暂停的目标（and allows users to specify desired pause targets）</li></ul><h3 id="G1垃圾回收器概述"><a href="#G1垃圾回收器概述" class="headerlink" title="G1垃圾回收器概述"></a>G1垃圾回收器概述</h3><p>旧的老年代收集器（serial,parallel,CMS）把堆分成了三个部分，年轻代，年老代，永久代，并且永久代是固定的内存大小</p><p><img src="/images/HeapStructure.png" alt="HeapStructure.png"></p><p>所有内存对象都最终属于这三部分之一</p><p>G1垃圾收集器使用了不同的步骤</p><p><img src="/images/Slide9.png" alt="Slide9.png"></p><p>堆被分成了相等大小的内存区域，每一个都是连续虚拟内存。某些区域被集合被分配成于旧回收器同样的角色（eden,surivivor,old）但他们的大小并没有固定。这在内存使用方面提供了更大的灵活性。</p><p>当执行垃圾回收的时候，G1操作在某方面和CMS类似。G1执行并发的全局标记，以决定堆内存里对象的存活性。在标记阶段完成之后，G1知道了那一个内存区域（regions）几乎为空，它会首先收集这些区域，这样通常回收出较大空白内存。这也是为什么这种垃圾回收器被叫做Garbage-First。顾名思义，G1优先在充满垃圾对象内存区域执行收集和压缩行动。G1使用暂停预测模型来满足用户自定义的暂停时间目标，并且根据制定暂停时间目标选择收集的收集的区域。</p><p>由G1标识哪些区域充满垃圾对象，G1从一个或多个区域区域拷贝对象到一个堆内存区域，在这个过程中压缩并清理内存。这个过程是在多个处理器上执行的，用以减少暂停时间并增加吞吐量。因此每个垃圾收集，G1都在用户定义的暂停时间内连续的工作以减少内存碎片。这个超出了前面两种方法的能力。<strong>CMS垃圾回收器不会压缩ParallelOld垃圾回收器仅执行整个堆压缩，这导致相当长的停顿时间</strong></p><p>值得注意的是，G1不是一个实时的回收器。它有可能满足设定的目标时间，但不是绝对的。G1根据先前收集的数据，估算用户指定的目标时间可以收集多少区域。收集器有一个合理准确的垃圾收集模型，并使用此模型来确定要收集那些区域，同时stop-the-world暂停时间在用户指定的时间范围内。</p><p>注意：G1由并发（concurrent）（与应用程序一起运行，例如优化、标记、清理）和并行（parallel）（多线程）阶段。完整的垃圾回收仍然是单线程的，如果想调整jvm参数，您的应用程序应该避免fullGC。</p><h3 id="G1足迹"><a href="#G1足迹" class="headerlink" title="G1足迹"></a>G1足迹</h3><p>如果你从ParallelOldGC或者CMS改成G1，你可以观察到G1 jvm进程占用资源更大。这在很大程度上与“记账”数据结构有关，例如Remembered Sets 和 Collection Sets。</p><p><strong>Remembered Sets</strong> </p><p>Remembered Sets 或 Rset：将对象引用跟踪到给定区域中。堆中每个区域（region）有一个Rset。Rset可以并行和独立的收集一个区域的垃圾对象，Rset的对jvm占用内存大小不超过5%。</p><p><strong>Collection Sets</strong> </p><p>Collection Sets或 CSets：在一个GC过程中CSets是一种将被回收的区域集。在GC过程中，所有在CSet中活着的对象将要被移动、复制。区域集合可以是Eden、survivor或者是年老代。CSet堆jvm内存占用大小不超过1%</p><h3 id="G1的推荐用例"><a href="#G1的推荐用例" class="headerlink" title="G1的推荐用例"></a>G1的推荐用例</h3><p>G1的首要重点是为运行需要大堆且GC延迟有限的应用程序的用户提供解决方案。 这意味着堆大小约为6GB或更大，并且稳定且可预测的暂停时间低于0.5秒。</p><p>如果当前具有CMS或ParallelOldGC垃圾收集器的应用程序具有以下一个或多个特征，则将其切换到G1很有用。</p><ul><li>完整的GC持续时间太长或太频繁。</li><li>对象分配率或提升率差异很大。</li><li>不必要的长时间垃圾收集或压缩暂停（长于0.5到1秒）</li></ul><p>注意：如果您使用的是CMS或ParallelOldGC，并且您的应用程序未经历长时间的垃圾收集暂停，则可以继续使用当前的收集器。 使用最新的JDK不需要更改为G1收集器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;G1垃圾回收&quot;&gt;&lt;a href=&quot;#G1垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;G1垃圾回收&quot;&gt;&lt;/a&gt;G1垃圾回收&lt;/h3&gt;&lt;p&gt;G1（Garbage-First） 收集器是为服务器准备的垃圾回收器，是为很多核大内存服务器准备的垃圾回收器</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>概念-B树和B+树</title>
    <link href="https://yinxs2003.github.io/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/"/>
    <id>https://yinxs2003.github.io/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点</p><ol><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li><li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li><li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li></ol><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="/images/BTree.png" alt="img"></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p><h2 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="B树和B+树区别"></a>B树和B+树区别</h2><ol><li>B+树的非叶子节点不保存键值对应的数据，这样使得B+树每个节点所能保存的键值大大增加；</li><li>B+树叶子节点保存了父节点的所有键值和键值对应的数据，每个叶子节点的键值从小到大链接；</li><li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</li><li>B+的非叶子节点只进行数据索引，不会存实际的键值对应的数据，所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</li></ol><p><img src="/images/B+Tree.png" alt="img"></p><blockquote><h4 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h4><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;/a&gt;B树&lt;/h2&gt;&lt;p&gt;B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>概念-Mysql索引面试题</title>
    <link href="https://yinxs2003.github.io/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://yinxs2003.github.io/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hash索引和B-Tree索引区别"><a href="#hash索引和B-Tree索引区别" class="headerlink" title="hash索引和B+Tree索引区别"></a>hash索引和B+Tree索引区别</h2><ol><li>hash索引只适合等值查询，无法进行范围查询</li><li>存在大量键值重复时候，hash索引效率很低</li><li>hash索引无法利用索引进行排序</li><li>hash索引无法利用联合索引做前缀匹配原则</li></ol><h2 id="B-Tree叶子节点能存储哪些东西"><a href="#B-Tree叶子节点能存储哪些东西" class="headerlink" title="B+Tree叶子节点能存储哪些东西"></a>B+Tree叶子节点能存储哪些东西</h2><p>可以存储整行数据或者是主键索引值，当存储整行数据时候为主键索引，存储主键索引时候是非主键索引。非主键索引在进行查询时候需要先寻找主键索引，根据主键索引获取需要的数据，这个查询两次的过程叫做回表。非主键索引中的联合索引可以通过做前缀原则实现覆盖索引的效果</p><h2 id="创建联合索引的时候，如何选择联合索引的字段顺序"><a href="#创建联合索引的时候，如何选择联合索引的字段顺序" class="headerlink" title="创建联合索引的时候，如何选择联合索引的字段顺序"></a>创建联合索引的时候，如何选择联合索引的字段顺序</h2><p>创建联合索引需要考虑联合索引字段的顺序，where子句中使用最频繁的一列放在最左边。比如我们创建了联合索引idx_k1_k2_k3(key1,key2,key3)三个索引相当于创建了idx(key1,key2,key3) idx(key1,key2) idx(key1)三个索引。</p><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>平衡二叉树查找效率确实很高，但是频繁的IO才是阻碍提高性能的瓶颈，怎样减少IO次数呢？前辈们很聪明的提出了局部性原理，分为时间局部性原理和空间局部性原理</p><p>时间局部性原理：即假如你查询id为1的用户数据，过一段时间你还会查询id为1的数据，所以会将这部分数据缓存下来。</p><p>空间局部性原理：当你查询id为1的用户数据的时候，你有很大的概率会去查询id为2，3，4的用户的数据，所以会一次性的把id为1，2，3，4的数据都读到内存中去，这个最小的单位就是页。页大小是由linux系统决定的，4k或者8k</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="/2021/03/02/概念-B树和B+树/">B树和B+树</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hash索引和B-Tree索引区别&quot;&gt;&lt;a href=&quot;#hash索引和B-Tree索引区别&quot; class=&quot;headerlink&quot; title=&quot;hash索引和B+Tree索引区别&quot;&gt;&lt;/a&gt;hash索引和B+Tree索引区别&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;hash</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>概念-书写高质量SQL的若干建议</title>
    <link href="https://yinxs2003.github.io/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/"/>
    <id>https://yinxs2003.github.io/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2023-04-14T17:37:25.731Z</updated>
    
    <content type="html"><![CDATA[<p>表结构：（有一个联合索引idx_userid_age，userId在前，age在后）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;userId&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(255) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_userid_age&#96; (&#96;userId&#96;,&#96;age&#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><h2 id="建议1"><a href="#建议1" class="headerlink" title="建议1"></a>建议1</h2><p>查询SQL尽量不要使用select *，而是select具体字段</p><p>理由：</p><ol><li><p>只取需要的字段，节省资源、减少网络开销。</p></li><li><p>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</p></li></ol><h2 id="建议2"><a href="#建议2" class="headerlink" title="建议2"></a>建议2</h2><p>优化limit分页</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id，name，age from employee limit 10000，10</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方案一 ：返回上次查询的最大记录(偏移量)</span><br><span class="line">select id，name from employee where id&gt;10000 limit 10.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方案二：order by + 索引， id是主键索引</span><br><span class="line">select id，name from employee order by id  limit 10000，10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方案三：在业务允许的情况下限制页数：</span><br></pre></td></tr></table></figure><h2 id="建议3"><a href="#建议3" class="headerlink" title="建议3"></a>建议3</h2><p>优化like语句</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId，name from user where userId like &#39;%123&#39;;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId，name from user where userId like &#39;123%&#39;;</span><br></pre></td></tr></table></figure><h2 id="建议4"><a href="#建议4" class="headerlink" title="建议4"></a>建议4</h2><p>尽量避免在索引列上使用mysql的内置函数</p><p>业务需求：查询最近七天内登陆过的用户(假设loginTime加了索引)</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select userId,loginTime from loginuser where Date_ADD(loginTime,Interval 7 DAY) &gt;&#x3D;now();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain  select userId,loginTime from loginuser where  loginTime &gt;&#x3D; Date_ADD(NOW(),INTERVAL - 7 DAY);</span><br></pre></td></tr></table></figure><h2 id="建议5"><a href="#建议5" class="headerlink" title="建议5"></a>建议5</h2><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age-1 &#x3D;10；</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age &#x3D;11；</span><br></pre></td></tr></table></figure><h2 id="建议6"><a href="#建议6" class="headerlink" title="建议6"></a>建议6</h2><p>Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</p><blockquote><p>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</p><p>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</p><p>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</p></blockquote><h2 id="建议7"><a href="#建议7" class="headerlink" title="建议7"></a>建议7</h2><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select age,name  from user where age &lt;&gt;18;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可以考虑分开两条sql写</span><br><span class="line">select age,name  from user where age &lt;18;</span><br><span class="line">select age,name  from user where age &gt;18;</span><br></pre></td></tr></table></figure><h2 id="建议8"><a href="#建议8" class="headerlink" title="建议8"></a>建议8</h2><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age &#x3D; 10;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;符合最左匹配原则</span><br><span class="line">select * from user where userid&#x3D;10 and age &#x3D;10；</span><br><span class="line">&#x2F;&#x2F;符合最左匹配原则</span><br><span class="line">select * from user where userid &#x3D;10;</span><br></pre></td></tr></table></figure><h2 id="建议9"><a href="#建议9" class="headerlink" title="建议9"></a>建议9</h2><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where address &#x3D;&#39;深圳&#39; order by age ;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_no_idx.png" alt="img"></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table user add index idx_address_age (address,age)</span><br><span class="line">select * from user where address &#x3D;&#39;深圳&#39; order by age ;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_add_idx.png" alt="img"></p><h2 id="建议10"><a href="#建议10" class="headerlink" title="建议10"></a>建议10</h2><p>在适当的时候，使用覆盖索引</p><p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; like模糊查询，不走索引了</span><br><span class="line">select * from user where userid like &#39;%123%&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/combine_idx1.png" alt="img"></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;id为主键，那么为普通索引，即覆盖索引登场了。</span><br><span class="line">select id,name from user where userid like &#39;%123%&#39;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/combine_idx2.png" alt="img"></p><h2 id="建议11"><a href="#建议11" class="headerlink" title="建议11"></a>建议11</h2><p>删除冗余和重复索引</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEY &#96;idx_userId&#96; (&#96;userId&#96;)  </span><br><span class="line">KEY &#96;idx_userId_age&#96; (&#96;userId&#96;,&#96;age&#96;)</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引</span><br><span class="line">KEY &#96;idx_userId_age&#96; (&#96;userId&#96;,&#96;age&#96;)</span><br></pre></td></tr></table></figure><h2 id="建议12"><a href="#建议12" class="headerlink" title="建议12"></a>建议12</h2><p>where子句中考虑使用默认值代替null</p><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age is not null;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_idex_default_num1.png" alt="img"></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置0为默认值</span><br><span class="line">select * from user where age&gt;0;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_idex_default_num2.png" alt="img"></p><p>理由：</p><p>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</p><blockquote><p>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件<code>！=，&gt;is null，is not null</code>经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。</p></blockquote><p>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;表结构：（有一个联合索引idx_userid_age，userId在前，age在后）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="技术" scheme="https://yinxs2003.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="概念" scheme="https://yinxs2003.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
</feed>
