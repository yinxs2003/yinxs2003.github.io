<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>工作随笔</title><meta name="author" content="yinxs2003"><meta name="copyright" content="yinxs2003"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="工作随笔">
<meta property="og:url" content="https://yinxs2003.github.io/index.html">
<meta property="og:site_name" content="工作随笔">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:author" content="yinxs2003">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yinxs2003.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '工作随笔',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-04-22 08:50:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0-rc1"><link rel="alternate" href="/atom.xml" title="工作随笔" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="工作随笔"><span class="site-name">工作随笔</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">工作随笔</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="概念-Java内存模型">概念-Java内存模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2023-04-14T16:00:00.000Z" title="Created 2023-04-15 00:00:00">2023-04-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">2.垃圾收集算法基于分代收集理论，可以分为年轻代、年老代两类收集算法。
年轻代：标记复制
年老代：标记整理
标记清除其中标记清除算法是最基础的算法，后续算法都是基于标记清楚算法改进得到的
标记清除算法缺点：

执行效率不稳定，当年轻代有大量回收对象时候，需要执行大量标记清除动作，而标记动作通常是需要stop the world的，所以可能存在性能问题
内存碎片问题

标记复制标记复制是将存活对象复制到两个Eden区的其中一个，然后回收剩下内存里的所有对象
年轻代特点是”朝生夕死”，需要复制对象数量少，所以使用标记复制进行垃圾回收效率高
一个Survivor区，两个Eden区，比例为8：1：1

执行第一次垃圾回收时候，将存活对象放到某个Enden区，剩下的Survivor和Eden执行回收操作
执行第二次垃圾回收时候，将存活对象copy到另一个Enden区，剩下的Survivor和Eden执行回收操作

标记整理年老代特点是垃圾回收比较少，标记整理算法是年老代算法。老年代如果使用标记复制算法需要复制很多对象，效率比较低
垃圾回收器年轻代回收器：

Serial收集器        使用 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/" title="概念-在Spring中如何解决循环依赖的问题">概念-在Spring中如何解决循环依赖的问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-05-30T16:00:00.000Z" title="Created 2021-05-31 00:00:00">2021-05-31</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">什么是循环依赖一般场景是一个Bean A依赖Bean B,而Bean B也依赖Bean A.Bean A → Bean B → Bean A
当然我们也可以添加更多的依赖层次，比如：Bean A → Bean B → Bean C → Bean D → Bean E → Bean A
Spring发生了什么当 Spring 上下文加载所有 bean 时，它会尝试按照它们完全工作所需的顺序创建 bean。例如，如果我们没有循环依赖，就像下面的例子：
bean A → bean B → bean C
Spring将创建bean C，然后创建bean B（并将bean C注入其中），然后创建bean A（并将bean B注入其中）。
但是，当有循环依赖时，Spring 无法决定首先创建哪个 bean，因为它们相互依赖。在这些情况下，Spring 将在加载上下文时引发BeanCurrentlyInCreationException。
在 Spring 中使用构造函数注入时可能会发生这种情况；如果您使用其他类型的注入，您应该不会发现此问题，因为依赖项将在需要时注入，而不是在上下文加载时注入。
一 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/" title="Java-jstack查看线程状态">Java-jstack查看线程状态</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-05-25T16:00:00.000Z" title="Created 2021-05-26 00:00:00">2021-05-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增
高了、出现了死锁、死循环等，我们该如何分析呢？
由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要
看下jvm的内部线程的执行情况，然后再进行分析查找出原因。
用法：jstack 

java线程的6种状态
初始态（NEW）
创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。
运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。
就绪态
该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。
所有就绪态的线程存放在就绪队列中。
运行态
获得CPU执行权，正在执行的线程。
由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。
阻塞态（BLOCKED）
当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。
而在Java中，阻塞态专指请求锁失败时进入的状态。
由一个阻塞队列存放所有阻塞态的线程。
处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。
等待态（W ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/" title="Java-使用guava缓存的例子">Java-使用guava缓存的例子</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-04-28T16:00:00.000Z" title="Created 2021-04-29 00:00:00">2021-04-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">使用guava缓存数据源
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.code.note.test;import java.util.HashMap;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;public class GuavaTest &#123;    private HashMap&lt;String, String&gt; dataSourceMap = new HashMap& ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/" title="概念-Mysql之redolog_binglog_mvcc.md">概念-Mysql之redolog_binglog_mvcc.md</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-04-13T16:00:00.000Z" title="Created 2021-04-14 00:00:00">2021-04-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">CheckPoint数据在内存中的这个过程叫做data buffer，数据已经存储在磁盘上叫data file。
事务的日志也一样，在内存中叫log  buffer，在磁盘上叫log file。
data buffer的数据定时写入到data file，这个定时执行的过程是checkpoint。
如果checkpoint失败，在恢复时候，只需要做最后一次redo log或者undo log的操作就可以完成故障恢复
redo log作用确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
内容物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。
什么时候产生事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
什么时候释放当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。
对 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/" title="Linux-Es排除节点">Linux-Es排除节点</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-04-07T16:00:00.000Z" title="Created 2021-04-08 00:00:00">2021-04-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目描述Es集群中有一个节点性能很差，会导致Es整体查询变慢，当该物理节点被关闭但存在部分分片没有分配到其他节点上。
解决方案因为配置文件中被关闭的机器ip是存在的，Es存在一个探活过程，所以这些分片没有被自动迁移到其他节点。
可以通过Exclude该机器的IP来动态删除该机器，删除10.1.1.1节点命令：
12345curl -XPUT http://10.1.1.10:9210/_cluster/settings -d '&#123;"transient" :&#123;"cluster.routing.allocation.exclude._ip" : "10.1.1.1"&#125;&#125;'

</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" title="算法-数组中的第K个最大元素">算法-数组中的第K个最大元素</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-04-07T16:00:00.000Z" title="Created 2021-04-08 00:00:00">2021-04-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目描述12345678910111213在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2:输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

该题可以使用堆排序进行实现，时间复杂度为nlogk
如何实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.code.note.test;import com.code.note.tree.BinaryHeap;public class Solution2 &#123;    public void buildBigHeap(int[] arr, int parent, int len) ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/" title="算法-八大排序算法之堆排序">算法-八大排序算法之堆排序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-04-06T16:00:00.000Z" title="Created 2021-04-07 00:00:00">2021-04-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目描述123456789101112131415给你一个整数数组 nums，请你将该数组升序排列。 示例 1：输入：nums = [5,2,3,1]输出：[1,2,3,5]示例 2：输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5]

堆排序的性质
堆是一颗满二叉树
子节点和父节点下标关系：leftChild = parent * 2 + 1
构建大顶堆是上浮操作，上浮操作是选择子节点中较大的节点，并和parent节点比较，子节点较大则交换子节点和parent节点
不稳定排序，时间复杂度O(nlogn)

如何实现使用堆排序进行排序操作，堆排序可以分成两个步骤

构建大顶堆，应该是从第向上执行遍历（上浮），所以循环从数组末尾向前循环
打印或者保存第一个节点
交换第一个和最后一个节点，缩小数组范围并继续执行第一步

代码如下
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" title="算法-快速排序">算法-快速排序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-04-01T16:00:00.000Z" title="Created 2021-04-02 00:00:00">2021-04-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">快速排序1以第一个数字6作为基数，使用双指针i,j进行双向遍历：

1、i从左往右寻找第一位大于基数（6）的数字，j从右往左寻找第一位小于基数（6）的数字；
2、找到后将两个数字进行交换。继续循环交换直到i&gt;=j结束循环；
3、最终指针i=j,此时交换基数和i(j)指向的数字即可将数组划分为小于基数（6）/基数（6）/大于基数（6）的三部分，即完成一趟快排；

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.code.note.test;import java.util.Arrays;import java.util.HashSet;import java.util.Set;import java.util.concurrent.locks.ReentrantLock;public class Main &#123;    public void quickSort(int[] arr, int left, int ri ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/" title="概念-Java内存模型">概念-Java内存模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-23T16:00:00.000Z" title="Created 2021-03-24 00:00:00">2021-03-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Java内存模型被提出的背景Java内存模型被提出主要是为解决如下问题

硬件效率问题
计算机内存比CPU慢很多，所以需要在CPU和主存之间加寄存器和高速缓存。
缓存一致性问题
代码指令重排导致多线程执行的“乱序问题”

什么是Java内存模型Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，简称 JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。
Java内存模型的组成
主内存
Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与介绍物理硬件的主内存名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。

本地内存
每个线程都有自己的本地内存。线程本地内存存有主存中变量的副本。




Java内存模型和计算机内存架构硬件内存架构

Java线程与硬件处理器

Java内存模型与硬件内存架构的关系通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/" title="算法-二叉树剪枝">算法-二叉树剪枝</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-07T16:00:00.000Z" title="Created 2021-03-08 00:00:00">2021-03-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">

这个题得用后序遍历，用前序遍历删不干净

12345678910111213141516public TreeNode pruneTree(TreeNode root) &#123;        if (root == null) &#123;            return null;        &#125;        root.left = pruneTree(root.left);        root.right = pruneTree(root.right);        if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0) &#123;            return null;        &#125;        return root;    &#125;









</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" title="算法-重建二叉树">算法-重建二叉树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-07T16:00:00.000Z" title="Created 2021-03-08 00:00:00">2021-03-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">
题目分析

前序遍历的特点是preorder[0]是根节点
中序遍历的特点是跟节点左边是左子树，跟节点右边是右子树

123456789101112131415161718192021222324252627282930313233343536373839public class Test &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int len = preorder.length;        if (len == 0) &#123;            return null;        &#125;        int rootVal = preorder[0];        int rootIndex = 0;        for (int i = 0; i &lt; len; i++) &#123;            if (inorder[i] == rootVal) &#123;                rootIndex =  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/" title="Linux-vim正则查找">Linux-vim正则查找</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-04T16:00:00.000Z" title="Created 2021-03-05 00:00:00">2021-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">使用vim查询spend=14435的命令是,
/spend=[1-9]\{5,5\}
其中[1-9]表示任意一个1～9的数字
\{5,5\}上面的数字表示出现了5次，即匹配14435
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/" title="概念-Spring源码">概念-Spring源码</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-04T16:00:00.000Z" title="Created 2021-03-05 00:00:00">2021-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">聊聊Spring
控制反转思想IOC
依赖注入AOP
bean的生命周期
循环依赖
三级缓存
FactoryBean和BeanFactory区别
ApplicationContxt和BeanFactory区别
Spring中的设计模式

</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="概念-CMS垃圾回收器">概念-CMS垃圾回收器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-04T16:00:00.000Z" title="Created 2021-03-05 00:00:00">2021-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">CMS垃圾回收CMS垃圾回收收集所有代。它会使用最小的资源来进行大多数垃圾回收工作，通常低停顿并发收集器不会复制或者压缩活动的对象。在不移动活动对象的情况下完成垃圾回收。如果内存碎片导致无法正常分配内存，请分配更大的堆内存。
CMS在年老带执行垃圾收集会氛围以下几个阶段



Phase
Description



(1) Initial Mark (Stop the World Event)
Objects in old generation are “marked” as reachable including those objects which may be reachable from young generation. Pause times are typically short in duration relative to minor collection pause times.


(2) Concurrent Marking
Traverse the tenured generation object graph for reachable objects  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/" title="概念-G1垃圾回收器2">概念-G1垃圾回收器2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-04T16:00:00.000Z" title="Created 2021-03-05 00:00:00">2021-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">G1收集器采用了另一种分配堆的方法。 后面的图片逐步检查了G1系统。
G1堆结构G1堆事一个内存区域被切分为多个相同大小的区域（regions）

区域大小是在jvm一启动就被选择的。JVM通常会生成两千个区域，每个区域大小相同，在1到32MB之间
G1堆分配事实上，这些区域被映射成Eden、Survivor和年老代

图片中的颜色显示了哪个区域与哪个角色相关联。 将活动对象从一个区域撤离（即复制或移动）到另一个区域。 区域被设计为并行或不停止其他应用程序线程的情况下并行垃圾收集。
如图所示，区域被分成Eden、Suivivor和年老代。此外还有第四种巨大区域。这些区域被设计成存放大于标准区域50%的对象。他们被一个连续集合区域进行存储。最后一种区域是堆未使用区域。
注意：在撰写本文时，尚未优化庞大对象的过程。因此应避免创建这种大小的对象。
G1年轻代年轻代堆被分成了大概两千个区域，区域大小在1MB到32MB之间。蓝色区域存储年老代对象，绿色区域存储年轻代对象。

注意：这些区域不需要像旧的垃圾收集器一样是内存连续的
G1的一次Young GC存活的对象撤离（移动或者拷贝）一个或者多个 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/" title="概念-G1垃圾回收器1">概念-G1垃圾回收器1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-04T16:00:00.000Z" title="Created 2021-03-05 00:00:00">2021-03-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">G1垃圾回收G1（Garbage-First） 收集器是为服务器准备的垃圾回收器，是为很多核大内存服务器准备的垃圾回收器。它在达到高吞吐量时满足了GC停顿时间可预测这样的一个目标。在Oracle JDK 7 update4 及以后的版本被支持。G1收集器是为如下程序设计：

垃圾收集于应用线程之间是并发的
紧凑的自由空间且没有较长的GC停顿时间
需要更可以预测的GC停顿时间
不想牺牲很多吞吐性能
不需要更大的Java堆

G1计划被当作CMS的长期的替代品。相比CMS，很多不同把G1变成一个更好的解决方案。

G1是一个压缩收集器，G1垃圾回收器依赖于区域（regions），避免使用空闲列表进行分配（avoid the use of fine-grained free lists for allocation）。这大大简化了垃圾回收器的各个部分，并消除了潜在的碎片问题
对比CMS，G1垃圾收集器提供更加可预测的GC停顿时间，并允许用户指定暂停的目标（and allows users to specify desired pause targets）

G1垃圾回收器概述旧的老年代收集器 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/" title="概念-B树和B+树">概念-B树和B+树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-02T16:00:00.000Z" title="Created 2021-03-03 00:00:00">2021-03-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">B树B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点

排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）

B+树B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/" title="概念-Mysql索引面试题">概念-Mysql索引面试题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-02T16:00:00.000Z" title="Created 2021-03-03 00:00:00">2021-03-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">hash索引和B+Tree索引区别
hash索引只适合等值查询，无法进行范围查询
存在大量键值重复时候，hash索引效率很低
hash索引无法利用索引进行排序
hash索引无法利用联合索引做前缀匹配原则

B+Tree叶子节点能存储哪些东西可以存储整行数据或者是主键索引值，当存储整行数据时候为主键索引，存储主键索引时候是非主键索引。非主键索引在进行查询时候需要先寻找主键索引，根据主键索引获取需要的数据，这个查询两次的过程叫做回表。非主键索引中的联合索引可以通过做前缀原则实现覆盖索引的效果
创建联合索引的时候，如何选择联合索引的字段顺序创建联合索引需要考虑联合索引字段的顺序，where子句中使用最频繁的一列放在最左边。比如我们创建了联合索引idx_k1_k2_k3(key1,key2,key3)三个索引相当于创建了idx(key1,key2,key3) idx(key1,key2) idx(key1)三个索引。
局部性原理平衡二叉树查找效率确实很高，但是频繁的IO才是阻碍提高性能的瓶颈，怎样减少IO次数呢？前辈们很聪明的提出了局部性原理，分为时间局部性原理和空间局部性原理
时间局部性原理 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/" title="概念-书写高质量SQL的若干建议">概念-书写高质量SQL的若干建议</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-02T16:00:00.000Z" title="Created 2021-03-03 00:00:00">2021-03-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">表结构：（有一个联合索引idx_userid_age，userId在前，age在后）
12345678CREATE TABLE &#96;user&#96; (  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;userId&#96; int(11) NOT NULL,  &#96;age&#96; int(11) DEFAULT NULL,  &#96;name&#96; varchar(255) NOT NULL,  PRIMARY KEY (&#96;id&#96;),  KEY &#96;idx_userid_age&#96; (&#96;userId&#96;,&#96;age&#96;) USING BTREE) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8;

建议1查询SQL尽量不要使用select *，而是select具体字段
理由：

只取需要的字段，节省资源、减少网络开销。

select * 进行查询时，很可能就不会使用 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="概念-基本数据类型">概念-基本数据类型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-02T16:00:00.000Z" title="Created 2021-03-03 00:00:00">2021-03-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">基本数据类型枚举
数字类型：byte，short，int，long
浮点型：float，double
布尔类型：boolean
字符型：char

计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0～255，换算成十六进制是00 ~ ff。其中最高位是符号位，所以数据范围是-128～127，即-2^7～2^8 - 1
一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。
每个字节占大小不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：
以下一个方块代表一个字节（byte），一个字节有8位（bits），所以byte大小是
123456789101112131415161718192021       ┌───┐  byte │   │       └───┘       ┌───┬───┐ short │   │   │       └───┴───┘       ┌───┬───┬───┬───┐   in ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="概念-面试题整理">概念-面试题整理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-02T16:00:00.000Z" title="Created 2021-03-03 00:00:00">2021-03-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">hash索引和b+tree索引区别hash索引只能等值查询，无法进行范围查询hash索引无法索引自动排序hash索引键值重复严重效率变得很低hash索引无法使用做匹配前缀原则
B+Tree数据叶子结点数据存储B+Tree叶子节点可以存储整行的数据，也可以存储主键索引。存储整行数据表示是主键索引。存储主键索引值表示是非主键索引。非主键索引查找数据需要先找到主键索引再根据主键索引查询数据。这个过程叫做回表。覆盖索引查询数据不需要回表。联合索引就是覆盖索引的一种。比如建了一个联合索引index(key1,key2,key3)，那么可以同时有三种索引，分别是index(key1), index(key1,key2)和index(key1,key2,key3)。创建联合索引需要注意字段顺序，排顺序的规则是where子句中最常用字段放在前面。
G1与CMS区别
CMS只适合年老代，因为CMS只有在fullGC时候会压缩内存。新生代产生无法接受该算法产生的碎片垃圾。
G1适合年老代同时适合年轻代，它会把存活的数据从一个区域复制到另一个区域并且进行压缩，没有内存碎片。因为G1是基于区域的，会记录那个区 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/02/%E6%A6%82%E5%BF%B5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/" title="概念-String为什么被设计为不可变的">概念-String为什么被设计为不可变的</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-01T16:00:00.000Z" title="Created 2021-03-02 00:00:00">2021-03-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">不可变的好处1. 可以缓存 hash 值
因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
2. String Pool 的需要
如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。

3. 安全性
String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。
4. 线程安全
String 不可变性天生具备线程安全，可以在多个线程中安全地使用。
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/02/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/" title="算法-回文链表">算法-回文链表</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-03-01T16:00:00.000Z" title="Created 2021-03-02 00:00:00">2021-03-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目
这个题用链表方式可以实现，但效率很低
因为是回文链表，使用快慢指针，每次循环让fast走两步，slow走一步
反转后半段链表，反转起始节点为当前slow节点
题目解答12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        ListNode slow = head;        ListNode fast = head;        // fast结束时候slow在中间        while (slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;        &#125;        ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/03/01/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" title="算法-反转链表">算法-反转链表</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-28T16:00:00.000Z" title="Created 2021-03-01 00:00:00">2021-03-01</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目概述
题目解答迭代解法

3和4 ：反转节点
1、2:   后移旧头节点

12345678910111213public ListNode reverseList(ListNode head) &#123;    ListNode newHead = null;    while(head != null)&#123;        ListNode tmp = head.next; // 1        head.next = newHead; // 3        newHead = head;      // 4        head = tmp; // 2 后移head节点    &#125;    return newHead;&#125;

在迭代解法的基础上可以衍生出其递归解法

结束条件是：当头节点遍历到末尾，且为空时，返回newHead
1、2步是遍历所有节点操作
3、4步是将head.next指向前一个节点（newHead），并将newHead后移一位（newHead = head; ）

12345678910111213141516171819pub ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/28/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%92%8C%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" title="算法-两数、三数之和">算法-两数、三数之和</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-27T16:00:00.000Z" title="Created 2021-02-28 00:00:00">2021-02-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">两数之和
两数之和的话需要遍历两次
条件是nums[i] + nums[j] == target

题目解答123456789101112131415161718192021222324252627package com.code.note.arrays;import java.util.Arrays;public class TwoSum &#123;    public int[] twoSum(int[] nums, int target) &#123;        int[] arr = new int[2];        for (int i = 0; i &lt; nums.length - 1; i++) &#123;            for (int j = i + 1; j &lt; nums.length; j++) &#123;                if (nums[i] + nums[j] == target) &#123;                    arr[0] = i;                    arr[1] =  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/24/%E7%AE%97%E6%B3%95-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/" title="算法-二叉树的镜像">算法-二叉树的镜像</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-23T16:00:00.000Z" title="Created 2021-02-24 00:00:00">2021-02-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目地址剑指 Offer 27. 二叉树的镜像题目概述
题目分析
递归结束条件：root为空返回true

递归每层做什么：前序遍历所有节点，并交换left和right节点

递归返回：当前root节点


题目解答12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode mirrorTree(TreeNode root) &#123;        if (root == null) &#123;            return null;        &#125;        sw ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/19/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" title="算法-二叉树的最近公共祖先">算法-二叉树的最近公共祖先</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-18T16:00:00.000Z" title="Created 2021-02-19 00:00:00">2021-02-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目地址剑指 Offer 68 - II. 二叉树的最近公共祖先题目概述
题目分析
递归结束条件：返回节点为空时结束递归
根据题目可以得知p、q节点分布存在三种情况：
p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先（即根节点root）
p q 都在左子树 （先被找到的即为最近父节点）
p q 都在右子树


递归返回：无返回

题目解答12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;    /**     * 二叉树的最近公共祖先     * 思路：     * 三种情况：     * 1、p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先     * 2、p q 都在左子树      * 3、p q 都在右子树     * @param root     * @param p     * @param q     * @return     */    public TreeNode lowestCommonAncestor(Tr ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/19/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACdouble/" title="算法-二叉树的最近公共祖先">算法-二叉树的最近公共祖先</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-18T16:00:00.000Z" title="Created 2021-02-19 00:00:00">2021-02-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目概述输入字符串转成double数字
题目分析
字符串是否为空
字符串是否包含非数字
字符串是否包含正负号
是否超过double最大值

题目解答1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.code.note.test;public class Solution &#123;    public Double parseDouble(String n) &#123;        int isNegative = 1;        String numStr = n.trim();        if (numStr == null) return 0D;        if (numStr.length() &gt; 0 &amp;&amp; numStr.charAt(0) == '-') &#123;            isNegative  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/19/%E7%AE%97%E6%B3%95-%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/" title="算法-二叉树的最近公共祖先">算法-二叉树的最近公共祖先</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-18T16:00:00.000Z" title="Created 2021-02-19 00:00:00">2021-02-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目概述https://leetcode-cn.com/problems/maximum-binary-tree/
题目分析
二叉树的根是数组 nums 中的最大元素（写一个函数获取当前数组中的最大index）

左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
写一个函数用来返回


题目解答12345678910111213141516171819202122232425262728293031323334353637383940package com.code.note.test;import com.code.note.tree.TreeNode;import com.code.note.util.BTreePrinter;public class Solution &#123;    public TreeNode constructMaximumBinaryTree(Integer[] nums) &#123;        return helper(nums, 0, nums.length-1); ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%E5%80%BC/" title="算法-二叉搜索树第K大节点值">算法-二叉搜索树第K大节点值</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-16T16:00:00.000Z" title="Created 2021-02-17 00:00:00">2021-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目地址剑指 Offer 54. 二叉搜索树的第k大节点题目概述
题目分析为什么在中序遍历时候更改cnt值？大概是因二叉搜索树的中序遍历是有序的

递归结束条件：当x节点为空时结束递归
递归每层做什么：right -&gt; mid -&gt; left 依次访问，在中序遍历修改cnt值，当++cnt == k时记录val并结束遍历
递归返回：无返回

题目解答123456789101112131415161718192021222324252627int ans, cnt;public int kthLargest(TreeNode root, int k) &#123;    if (root == null) &#123;        return 0;    &#125;    kthLargestNode(root, k);    System.out.println(ans);    return ans;&#125;public void kthLargestNode(TreeNode x, int k) &#123;    if (x == null) &#123;  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/14/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" title="算法-平衡二叉树">算法-平衡二叉树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-13T16:00:00.000Z" title="Created 2021-02-14 00:00:00">2021-02-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目地址110. 平衡二叉树题目概述
题目分析左右子树高度差大于1返回false，这个需要递归到每一层

递归结束条件：root为空返回true，左右子树高度差值大于1返回false

递归每层做什么：计算左树、右树高度

递归返回：高度值


题目解答123456789101112131415161718public boolean isBalanced(TreeNode root) &#123;    if (root == null) &#123;        return true;    &#125;    int l = getDepth(root.left);    int r = getDepth(root.right);    if (Math.abs(l - r) &gt; 1) &#123;        return false;    &#125;    return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;public int getDepth(TreeNode x) &# ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/14/%E7%AE%97%E6%B3%95-%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" title="算法-是否是对称二叉树">算法-是否是对称二叉树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-13T16:00:00.000Z" title="Created 2021-02-14 00:00:00">2021-02-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目地址101. 对称二叉树题目概述
题目分析递归的难点在于：找到可以递归的点 为什么很多人觉得递归一看就会，一写就废。 或者说是自己写无法写出来，关键就是你对递归理解的深不深。
对于此题： 递归的点怎么找？从拿到题的第一时间开始，思路如下：
1.怎么判断一棵树是不是对称二叉树？ 答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对称时，他对称
2.那么怎么知道左子树与右子树对不对称呢？在这我直接叫为左树和右树 答案：如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称。
仔细读这句话，是不是有点绕？怎么感觉有一个功能A我想实现，但我去实现A的时候又要用到A实现后的功能呢？
当你思考到这里的时候，递归点已经出现了： 递归点：我在尝试判断左树与右树对称的条件时，发现其跟两树的孩子的对称情况有关系。
想到这里，你不必有太多疑问，上手去按思路写代码，函数A（左树，右树）功能是返回是否对称
def 函数A（左树，右树）： 左树节点值等于右树节点值 且 函数A（左树的左子树，右树的右子树），函数A（左树的右子树，右树的左子树）均为 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/02/12/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/" title="算法-合并二叉树">算法-合并二叉树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-02-11T16:00:00.000Z" title="Created 2021-02-12 00:00:00">2021-02-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">题目地址617. 合并二叉树题目概述
这道题其实就是把二叉树每个节点的值相加，并放到新的二叉树节点，如果某棵树当前节点为空，他的value值是0
其实这个题主要考察的是二叉树遍历，只不过需要同时遍历两棵树，二叉树遍历代码如下:
123456789101112private Node walk(Node x) &#123;    if (x == null) &#123;        return null;    &#125;    System.out.println(x.value);    x.left = walk(x.left);    x.right = walk(x.right);    return x;&#125;

如何实现
结束条件：当两个数节点都为空，结束当前递归

每层递归做了什么：计算两个val相加（需要判空），根据该值生成新的节点

每层递归返回什么：返回上次计算接Node引用


整体代码如下:
1234567891011121314151617class Solution &#123;    public TreeNode mergeTrees(Tr ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/01/27/Mybatis-%E6%8B%BC%E8%A3%85%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6sql/" title="Mybatis拼装复杂条件sql">Mybatis拼装复杂条件sql</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-01-26T16:00:00.000Z" title="Created 2021-01-27 00:00:00">2021-01-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">需求背景因为mybatis不好拼装如下sql
123select doc_id,encourage_card_id from encourage_card_quantitative_fake_progress where (doc_id = 'a' and encourage_card_id = 'b') or  (doc_id = 'c' and encourage_card_id = 'd')



所以我们在编写sql是可以使用concat函数拼装column来完成上面的sql的效果，sql如下：
123SELECT *FROM encourage_card_quantitative_fake_progressWHERE (concat(doc_id,'_',encourage_card_id) in ('1jshdfjka_12345','2jshdfjka_2'))

在mybatis中实现上面sql代码如下：
123456789101112131415161718192021222324@Componentpublic interface EncourageCardQuan ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2021/01/27/%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82ifelse%E9%97%AE%E9%A2%98/" title="模式-策略模式+工厂解决复杂ifelse过多问题">模式-策略模式+工厂解决复杂ifelse过多问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2021-01-26T16:00:00.000Z" title="Created 2021-01-27 00:00:00">2021-01-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">需求背景1.按小时、天查询不同表
2.按照特定领域、全领域按照不同字段排序
3.按照文章类型进行排序
因此条件很多，需要多个if条件判断
1234567891011121314151617181920private List&lt;MysqlBillboardCateTopviewDoc&gt; getHourOrDayDocs(String cate, BillboardScheduleReq.PostType postType, BillboardScheduleReq.SortType sortType) &#123;        List&lt;MysqlBillboardCateTopviewDoc&gt; hourOrDayDocs;        if (sortType == BillboardScheduleReq.SortType.hour) &#123;            if (Strings.isBlank(cate)) &#123;// 全领域                hourOrDayDocs = mysqlBillboardCateTopvi ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/30/Flink-SingleOutputStreamOperator%E7%94%A8%E6%B3%95/" title="Flink-SingleOutputStreamOperator用法">Flink-SingleOutputStreamOperator用法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-30T02:40:30.000Z" title="Created 2020-11-30 10:40:30">2020-11-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Flink DataStream中union和connect都有一个共同的作用，就是将2个流或多个流合成一个流。但是两者的区别是：union连接的2个流的类型必须一致，connect连接的流可以不一致，但是可以统一处理。
具体看下面示例：
123public class ConnectOperator &#123;&#125;

connect可以将2个不同类型的流同时用不同的逻辑处理好，形成一个流。
union是将2个同类型的流，合成一个，进行处理。
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/30/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20/" title="算法-构造最大二叉树">算法-构造最大二叉树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-29T16:00:00.000Z" title="Created 2020-11-30 00:00:00">2020-11-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">原题链接：654. 最大二叉树
给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。


示例 ：
输入：[3,2,1,6,0,5]输出：返回下面这棵树的根节点：
6
 /   \
3     5
 \    / 
  2  0   
    \
     1BinaryTree代码如下
123456789package com.code.note.tree;import com.code.note.listnode.ListNode;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class BinaryTree&lt;T extends Comparable&gt; &#123;    private Node&lt;T&gt; root;&#125;


</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/15/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" title="算法-二叉树深度优先和广度优先遍历">算法-二叉树深度优先和广度优先遍历</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-14T16:00:00.000Z" title="Created 2020-11-15 00:00:00">2020-11-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">深度优先遍历算法（DFS）深度优先遍历算法（Depth-First-Search），是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v所在的边都一杯探寻过，搜索将回溯到发现节点v的那条边的节点。选择其中一个座位源节点并重复以上过程，整个进程反复进行，直到所有节点都被访问位置。
前序、中序、后序遍历都属于深度优先遍历算法


前序遍历F, B, A, D, C, E, G, I, H.

中序遍历A, B, C, D, E, F, G, H, I.

后续遍历A, C, E, D, B, H, I, G, F.

广度优先遍历（BFS）广度优先遍历（Breadth-First Search），又名宽度优先搜索，或者横向优先搜索，是一种图形搜索演算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点，如果所有节点均被访问，则算法终止。
F, B, G, A, D, I, C, E, H.

代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/07/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/" title="算法-单链表">算法-单链表</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-06T16:00:00.000Z" title="Created 2020-11-07 00:00:00">2020-11-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">单链表代码如下


123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.code.note.listnode;import lombok.extern.slf4j.Slf4j;/** * 单链表 * * @param &lt;T&gt; */@Slf4jpublic class ListNode&lt;T&gt; &#123;    private int size;    private Node head;    public class Node &#123;        T value;        Node next;        Node(T value) &#123;            this.value = value;    ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/" title="Java-自定义注解">Java-自定义注解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-04T16:00:00.000Z" title="Created 2020-11-05 00:00:00">2020-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">元注解@Target最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：

类或接口：ElementType.TYPE；
字段：ElementType.FIELD；
方法：ElementType.METHOD；
构造方法：ElementType.CONSTRUCTOR；
方法参数：ElementType.PARAMETER。

例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：
如何自定义注解第一步，用@interface定义注解：
12public @interface Report &#123;&#125;



第二步，添加参数、默认值：
12345public @interface Report &#123;    int type() default 0;    String level() default "info";    String value() default "";&#125;

第三步，用元注解配置注解：
1234567@Target(Ele ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%BA%8C)/" title="Java-自定义注解（二）">Java-自定义注解（二）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-04T16:00:00.000Z" title="Created 2020-11-05 00:00:00">2020-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">再读完Java自定义注解（一）我们可以通过代码来实现我们自己的自定义注解
如何自定义注解EventBean类
12345678910111213141516package com.code.note.annotation;import lombok.Data;@Datapublic class EventBean &#123;    @EventName("coding now...")    private String name;    @EventType(eventType = EventType.Type.MEETING)    private String type;    @User(id = 1, name = "testName", email = "15090552277@163.com")    private String user;&#125;



第二步，添加参数、默认值：
12345public @interface Report &#123;    int type() default 0;    String level() default "inf ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" title="Java-自定义注解(一)">Java-自定义注解(一)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-04T16:00:00.000Z" title="Created 2020-11-05 00:00:00">2020-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">元注解@Target最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：

类或接口：ElementType.TYPE；
字段：ElementType.FIELD；
方法：ElementType.METHOD；
构造方法：ElementType.CONSTRUCTOR；
方法参数：ElementType.PARAMETER。

例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：
如何自定义注解第一步，用@interface定义注解：
12public @interface Report &#123;&#125;



第二步，添加参数、默认值：
12345public @interface Report &#123;    int type() default 0;    String level() default "info";    String value() default "";&#125;

第三步，用元注解配置注解：
1234567@Target(Ele ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/05/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/" title="算法-二叉树">算法-二叉树</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-04T16:00:00.000Z" title="Created 2020-11-05 00:00:00">2020-11-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">二叉树需要声明一个Node节点，包含节点得值，以及左右两个子节点
Node节点代码如下
1234567891011package com.code.note.tree;public class Node&lt;T extends Comparable&gt;&#123;    T value;    Node left;    Node right;    Node(T value) &#123;        this.value = value;    &#125;&#125;



BinaryTree代码如下
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.code.note.tre ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/11/03/Flink%20Connect%E5%92%8CUnion%E5%8C%BA%E5%88%AB/" title="Flink Connect和Union区别">Flink Connect和Union区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-11-03T02:40:30.000Z" title="Created 2020-11-03 10:40:30">2020-11-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Flink DataStream中union和connect都有一个共同的作用，就是将2个流或多个流合成一个流。但是两者的区别是：union连接的2个流的类型必须一致，connect连接的流可以不一致，但是可以统一处理。
具体看下面示例：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ConnectOperator &#123;    public static void main(String[] args) throws Exception &#123;        StreamExecutionEnvironment sEnv = StreamExecutionEnvironment.getExecutionEnvironment();        sEnv.setParallelism(1);         ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/10/20/Java8%E7%9A%84Function%E5%92%8CBI_Function/" title="Java8的Function和BI_Function">Java8的Function和BI_Function</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-10-20T02:40:30.000Z" title="Created 2020-10-20 10:40:30">2020-10-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Function函数概念 Function作为一个函数式接口，主要方法apply接受一个参数，返回一个值
举个例子123456789101112131415161718192021222324252627package com.bd.thread;import lombok.extern.slf4j.Slf4j;import java.util.function.Function;@Slf4jpublic class Test &#123;    public static void main(String[] args) &#123;        Function&lt;Integer, Integer&gt; f1 = x -&gt; &#123;            return x * x;        &#125;;        Function&lt;Integer, Integer&gt; f2 = x -&gt; &#123;            return x + x;        &#125;;                      // 表示f1 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/10/20/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/" title="Java中如何自动调用父类中的资源初始化方法">Java中如何自动调用父类中的资源初始化方法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-10-20T02:40:30.000Z" title="Created 2020-10-20 10:40:30">2020-10-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">一个简单的例子背景在写程序时候常常有一些资源初始化方法，我们希望这些方法能够被自动调用 ，可以使用如下方式实现自动调用
代码父类代码如下：
1234567891011121314package com.bd.autocall;import lombok.extern.slf4j.Slf4j;@Slf4jpublic abstract class Super &#123;    public abstract void call0();    public void call()&#123;        // 在这里调用子类中的call0方法        this.call0();    &#125;&#125;

子类代码如下：
1234567891011121314151617package com.bd.autocall;import lombok.extern.slf4j.Slf4j;@Slf4jpublic class Sub extends Super &#123;    @Override    public void call0() &#123;        //  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/20/Centos7%E5%AE%89%E8%A3%85python3/" title="Centos7安装python3">Centos7安装python3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-20T04:00:30.000Z" title="Created 2020-07-20 12:00:30">2020-07-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">下载python3安装包wget -c https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz
安装linux依赖yum install libffi-devel openssl openssl-devel sqlite-devel bzip2-devel -y
在源码安装文件中编辑文件Modules/Setup.dist
安装openssl在源码安装文件中编辑文件Modules/Setup.dist
去掉如下注释
1234#SSL=/usr/local/ssl_ssl _ssl.c \ -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \ -L$(SSL)/lib -lssl -lcrypto

编译安装mkdir /usr/python3
cd Python-3.7.3
./configure –prefix=/usr/python3 –enable-loadable-sqlite-extensions &amp;&amp; make &amp;&amp; make in ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BB%93%E5%BA%93/" title="如何搭建个人仓库">如何搭建个人仓库</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-11T06:40:30.000Z" title="Created 2020-07-11 14:40:30">2020-07-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">ssh端口为22情况在服务器端172.27.9.121搭建仓库
1.在仓库目录/tmp/myproject.git输入git init
2.允许上传代码
1git config receive.denyCurrentBranch ignore







3.在本地clone远程仓库代码
1git clone root@172.27.9.121:/tmp/myproject.git

4.向121服务器~/.ssh/authxxx 添加私钥，免密码认证
如何上传非ssh端口代码编辑本地文件~/.ssh/config，增加如下内容,remotevps代表的是远端服务器
12345678910111213141516# For all hostsServerAliveInterval 10Host remotevpsHostName 107.123.123.123Port 12345User rootHost *  UseKeychain yes  AddKeysToAgent yes  IdentityFile ~&#x2F;.ssh&#x2F;id_rsaHost *    Iden ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/11/%E9%9D%A2%E8%AF%95-kafka%E4%B8%93%E9%A2%98/" title="面试-Kafka专题">面试-Kafka专题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-11T04:44:51.000Z" title="Created 2020-07-11 12:44:51">2020-07-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">使用Kafka时会遇到的问题
Kafka速度很快的原因
如何保证消息不丢失
Consumer重复消费怎么处理
如何保证消息的有序性



TODO: 待增加问题

Offset怎么保存
数据倾斜怎么处理
一个Topic分配多少个Partition合适以及修改Partition的限制有哪些

Kafka速度很快的原因
磁盘的顺序读写
使用操作系统的Page Cache，而不是jvm内存，这样能极大加快读写速度。避免Object对象比在Linux对象更大的消耗，避免jvm数据增多GC变慢的问题
零拷贝，Page Cache 结合 sendfile 方法，避免拷贝到用户态内存操作，Kafka消费端的性能也大幅提升。这也是为什么有时候消费端在不断消费数据时，我们并没有看到磁盘io比较高，此刻正是操作系统缓存在提供数据。
批量读写，批量压缩：把所有消息都变成一个批量文件，并且执行合理的批量压缩，减少网络IO消耗

如何保证消息不丢失消息发布的可靠性Producer向Topic发送消息，此时网络存在异常，producer无法得知broker是否接收到该消息，网络异常可能有两种情况：

在消息传递过 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/10/ambari%E6%98%BE%E7%A4%BAheartbeat_lost%E9%97%AE%E9%A2%98/" title="python3下配置spark环境">python3下配置spark环境</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-10T04:00:30.000Z" title="Created 2020-07-10 12:00:30">2020-07-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">在/etc/profile中增加如下内容
1234567891011export JAVA_HOME=/usr/local/java/jdk1.8.0_191export PYSPARK_PYTHON=/usr/python3/bin/python3export PYSPARK_DRIVER_PYTHON=/usr/python3/bin/python3export PYSPARK_SUBMIT_ARGS="--master local pyspark-shell"export HADOOP_USER_CLASSPATH_FIRST=trueexport PATH=$JAVA_HOME/bin:$PATHexport MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4export SPARK_HOME=/usr/hdp/2.6.5.0-292/spark2export HADOOP_HOME=/usr/hdp/current/hadoop-clientexport HIVE_HOME=/usr/hdp/current/hive-server2- ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/10/centos7%E8%BF%9E%E6%8E%A5wpa%20enterprise%E4%BC%81%E4%B8%9A%E7%BA%A7wifi/" title="python3下配置spark环境">python3下配置spark环境</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-10T04:00:30.000Z" title="Created 2020-07-10 12:00:30">2020-07-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">12345678910111213141516171819$ network-manager.nmcli connection edit type 802-11-wirelessnmcli&gt; goto 802-11-wirelessnmcli 802-11-wireless&gt; set ssid &lt;your_ssid&gt;nmcli 802-11-wireless&gt; backnmcli&gt; goto 802-11-wireless-securitynmcli 802-11-wireless-security&gt; set key-mgmt wpa-eapnmcli 802-11-wireless-security&gt; set auth-alg opennmcli 802-11-wireless-security&gt; backnmcli&gt; goto 802-1xnmcli 802-1x&gt; set eap peapnmcli 802-1x&gt; set identity &lt;your_identity&gt;nmcli 802-1x& ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/10/python3_spark%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/" title="Ambari显示heartbeat_lost问题">Ambari显示heartbeat_lost问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-10T04:00:30.000Z" title="Created 2020-07-10 12:00:30">2020-07-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">解决方案重启heartbeat lost机器的ambari-agent
重启命令1service ambari-agent start



</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/07/%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" title="无重复最长子串">无重复最长子串</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-07T04:50:30.000Z" title="Created 2020-07-07 12:50:30">2020-07-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。


示例 1:
123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。



示例 2:
123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。

示例 3:
1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。

首次代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.bd.leetcod ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/06/LinkedMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84/" title="常见OOM及原因分析">常见OOM及原因分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-06T02:40:30.000Z" title="Created 2020-07-06 10:40:30">2020-07-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">LinkedMap为什么是有序MapLinkedMap底层存储是数组，初始大小为16
LinkedMap返回的set是有序的，是因为KeySet中的iterator是有序的
LinkedMap在put时候，使用for循环，且起始位置用hashIndex算出来的
1234567891011121314151617181920protected int hashIndex(int hashCode, int dataSize) &#123;        return hashCode &amp; dataSize - 1;&#125;public Object put(Object key, Object value) &#123;        key = this.convertKey(key);        int hashCode = this.hash(key);        int index = this.hashIndex(hashCode, this.data.length);        for(AbstractHashedMap.HashEntry entry ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/06/OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" title="常见OOM及原因分析">常见OOM及原因分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-06T02:40:30.000Z" title="Created 2020-07-06 10:40:30">2020-07-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">常见OOM类型堆溢出错误信息：java.lang.OutOfMemoryError: Java heap space 
Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 


Java 堆溢出排查解决思路
查找关键报错信息，如

1java.lang.OutOfMemoryError: Java heap space


使用内存映像分析工具（如Eclipsc Memory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。
如果是内存泄漏，可进一步通过工具查看泄漏对象到GC    Roots的引用链，修复应用程序中的内存泄漏。
如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 -Xmx 增加堆大小。

栈溢出1java.lang.OutOfMemoryError: unable to create new native thread



关于虚拟机栈和本地方法栈，在Java虚拟机规范中 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/06/Spark%E6%A6%82%E5%BF%B5/" title="Spark专项训练">Spark专项训练</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-06T02:40:30.000Z" title="Created 2020-07-06 10:40:30">2020-07-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Spark部署模式
standalone模式，开启7077端口提供服务
spark on yarn模式 ：
client 模式， driver运行在客户端，调试用 
cluster模式， 分布式运行，driver运行在集群子节点 





RDD什么是RDD弹性分布式数据集（RDD），Spark中的基本抽象。 
代表着一种不可变的，可以被并行操作的集合， 这个类包含RDD所有的基本操作，例如map,filter,perssist
RDD有什么属性 一组分片
 一个计算每个分区的函数 
 RDD之间的依赖关系 
 一个Partitioner，即RDD的分片函数。 
 一个列表，存储存取每个Partition的优先位置（preferred location） 
RDD弹性表现在那哪些方面 自动进行磁盘和内存存储的切换 
 基于lineage的高效容错 
 task执行失败会进行重试 
 stage执行失败会进行重试，并且只重试失败的分片 
 checkpoint和persist数据的持久化缓存 
RDD的宽依赖窄依赖，stage划分窄依赖： 窄依赖就是指父RDD的每个分区只被一个子RDD ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/07/03/Flink%E7%AA%97%E5%8F%A3/" title="Flink窗口">Flink窗口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-07-03T04:50:30.000Z" title="Created 2020-07-03 12:50:30">2020-07-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">什么是窗口Windows是处理流试计算的核心。 Windows将流分成有限个大小的“存储桶”，我们可以在“存储桶”上应用计算。
窗口类型Tumbling Window翻滚窗口，无数据重叠
滚动窗口分配器将每个元素分配给指定窗口大小的窗口。 滚动窗口具有固定的大小，并且不重叠。 例如，如果您指定大小为5分钟的翻滚窗口，则将评估当前窗口，并且每五分钟将启动一个新窗口，如下图所示。



Sliding Window滑动窗口，可数据重叠
滑动窗口分配器将元素分配给固定长度的窗口。和滚动窗口相比，窗口大小可以被windows param参数控制，一个额外的滑动参数控制滑动窗口的滑动频率。因此滑动窗口是可以重复的当滑动大小小于窗口大小。在这种情况下，元素可以被分配给多个窗口（可以重复）
例如：你可以存在一组长度为10分钟的窗口集合，这样你可以每隔5分钟就得到下一个窗口，且包含最近10分钟的所有事件，示意图如下所示

Session WindowSession Window，活动时间间隙相等的窗口
会话窗口分配器按活动会话对元素进行分组。与滚动窗口和滑动窗口相比，会话窗口不重叠且没有固定的开始和结 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/30/ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/" title="ConcurrentHashMap如何实现的">ConcurrentHashMap如何实现的</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-30T06:40:30.000Z" title="Created 2020-06-30 14:40:30">2020-06-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Jdk1.7的ConcurrentHashMapjdk1.7中采用Segment + HashEntry的方式进行实现，结构如下：

Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样
123456int sshift = 0;int ssize = 1;while (ssize &lt; concurrencyLevel) &#123;    ++sshift;    ssize &lt;&lt;= 1;&#125;

如上所示，因为ssize用位于运算来计算（ssize &lt;&lt;=1），所以Segment的大小取值都是以2的N次方，无关concurrencyLevel的取值，当然concurrencyLevel最大只能用16位的二进制来表示，即65536，换句话说，Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16
每一个Segme ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/26/Flink%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/" title="Flink提交任务">Flink提交任务</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-26T03:20:30.000Z" title="Created 2020-06-26 11:20:30">2020-06-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Flink以YarnCluster模式提交任务，且指定任务名和队列
flink run -m yarn-cluster -ynm PROD-fink-data-gather  –yarnqueue CClient /home/cclient/danke-flink-data-gather-prod.jar


</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/25/Flink%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6/" title="Flink中的并行度">Flink中的并行度</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-25T04:50:30.000Z" title="Created 2020-06-25 12:50:30">2020-06-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">Parallel Execution（并行执行）一个任务被切分成几个并行实例执行，且每个并行实例处理输入任务的一部分数据，并行度会导致乱序问题，任务的并行实力数称为并行性
可以从三个层面限制并行度
Execution Environment Level1env.setParallelism(3);

Client Level1234Client client = new Client(jobManagerAddress, config, program.getUserCodeClassLoader());// set the parallelism to 10 hereclient.run(program, 10, true);

System Level在./conf/flink-conf.yaml中配置parallelism.default来设置并行度
提示如果使用checkpoint的话需要设置一个最大并行度，避免从savepoint恢复时候导致性能问题
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/25/Flink%E6%97%B6%E9%97%B4/" title="Flink中的水印与时间">Flink中的水印与时间</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-25T04:50:30.000Z" title="Created 2020-06-25 12:50:30">2020-06-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">watermark(水印）Flink中用于衡量event time进度的机制叫做水印


官方定义watermark流(水印流)作为数据流的一部分，并带有一个时间戳t，当watermark t声明event time达到了t时刻，表名该数据流中不存在时间戳t`&lt;= t的元素
对于watermark的理解在下文中的例子中，我们有一个带有时间戳的事件流，但是由于某种原因它们并不是按顺序到达的。图中的数字代表事件发生的时间戳。第一个到达的事件发生在时间 4，然后它后面跟着的是发生在更早时间（时间 2）的事件，以此类推：

注意这是一个按照事件时间处理的例子，这意味着时间戳反映的是事件发生的时间，而不是处理事件的时间。事件时间（Event-Time）处理的强大之处在于，无论是在处理实时的数据还是重新处理历史的数据，基于事件时间创建的流计算应用都能保证结果是一样的。
现在假设我们正在尝试创建一个流计算排序算子。也就是处理一个乱序到达的事件流，并按照事件时间的顺序输出事件。
理解1数据流中的第一个元素的时间是 4，但是我们不能直接将它作为排序后数据流的第一个元素并输出它。因为数据是乱序到达的 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/20/arthas/" title="使用arthas分析presto宕机原因">使用arthas分析presto宕机原因</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-20T02:40:30.000Z" title="Created 2020-06-20 10:40:30">2020-06-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">问题描述Presto半夜总是宕机
解决思路使用arthas分析jvm使用情况


下载arthas curl -O https://alibaba.github.io/arthas/arthas-boot.jar 
启动1java -jar arthas-boot.jar

命令thread命令查看最占CPU的线程12#展示当前最忙的前N个线程并打印堆栈thread -n 3
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/18/mysql%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/" title="mysql迁移数据目录解决磁盘不足问题">mysql迁移数据目录解决磁盘不足问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-18T02:40:30.000Z" title="Created 2020-06-18 10:40:30">2020-06-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">先关闭mysql数据库
mv /var/lib/mysql /data/mysql_data


创建目录
mkdir /data/mysql_data
chown mysql:mysql /data/mysql_data
做软连接
ln -s /data/mysql_data/mysql /var/lib/mysql
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/17/%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E8%B5%B7%E5%A7%8B%E8%8A%82%E7%82%B9/" title="LeetCode 160. 相交链表">LeetCode 160. 相交链表</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-17T02:40:30.000Z" title="Created 2020-06-17 10:40:30">2020-06-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content"> 编写一个程序，找到两个单链表相交的起始节点。 
解题思路快慢指针
因为两个链表长度可能不一样，但是相交后的元素都是一样的，可以使用快慢指针
***** 分别遍历链表，获取其长度，长链表命名为quickNode，短链表命名为slowNode，二者长度差为quickStep
***** quickNode先运行quickStep步之后，此时两个链表长度相等，用一个循环就能找到相同起始节点


代码1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123;   public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        if(headA == null || headB == null)&#123;            return null;        &#125;        int aLength = getLength(headA ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/15/inode%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/" title="inode磁盘清理">inode磁盘清理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-15T06:44:51.000Z" title="Created 2020-06-15 14:44:51">2020-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


问题描述硬盘有剩余空间但一直提示no device space left，使用df -hl查看磁盘还有空间
解决方案使用df -i查看inode，发现占用率100%，说明碎片文件过多超过linux的文件数量的限制，使用如下命令查找碎片文件文件，并清理
1find / -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n

</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/15/%E5%BB%BA%E8%90%BD%E5%9C%B0%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%86%99%E5%85%A5%E5%BE%88%E6%85%A2%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="建落地临时表写入很慢导致异常的解决方法">建落地临时表写入很慢导致异常的解决方法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-15T06:44:51.000Z" title="Created 2020-06-15 14:44:51">2020-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


建表时候指定为ORC格式
1CREATE TABLE orc_table_with_null STORED AS ORC AS SELECT x,nullFROM empty;



Hive命令行调试模式
1hive --hiveconf hive.root.logger&#x3D;DEBUG,console

</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/15/%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8F%90%E4%BA%A4%E5%88%B0%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84hiveserver2/" title="beeline请求被提交到已经删除的hiveserver2节点">beeline请求被提交到已经删除的hiveserver2节点</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-15T06:44:51.000Z" title="Created 2020-06-15 14:44:51">2020-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


问题描述在ambari集群上bigdata-client节点做hiveserver2自动拉起测试，增加了一个hiveserver2，然后再ambari删除该hiveserver2
然后出现请求被提交到已经删除的hiveserver2节点

在zookeeper节点上执行zookeeper-cli.sh进入zookeeper命令行
执行删除无效的节点命令
1delete /hiveserver2/serverUri=bigdata-client:10000;version=1.2.1000.2.6.5.1175-1;sequence=0000000010

过一段时间还是会出现上述错误，之后发现自动拉起服务没删除……
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/14/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/" title="leetcode 2.两数相加">leetcode 2.两数相加</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-13T16:00:00.000Z" title="Created 2020-06-14 00:00:00">2020-06-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例：
123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 &#x3D; 807



链表ListNode结构
123456789101112131415package com.bd.leetcode.leetcode_2;public class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;    ListNode(int val, ListNode next) &#123;        this.val = val;        this.next  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/Ambari%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/" title="Ambari集群安装">Ambari集群安装</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容




目前的机器172.22.222.109
安装ambari-server在/etc/yum.repos.d/ambari.repo中新增ambari源
123456789cat &#x2F;etc&#x2F;yum.repos.d&#x2F;ambari.repo#VERSION_NUMBER&#x3D;2.6.2.2-1[ambari-2.6.2.2]name&#x3D;ambari Version - ambari-2.6.2.2baseurl&#x3D;http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;ambari&#x2F;centos7&#x2F;2.x&#x2F;updates&#x2F;2.6.2.2gpgcheck&#x3D;1gpgkey&#x3D;http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;ambari&#x2F;centos7&#x2F;2.x&#x2F;updates&#x2F;2.6.2.2&#x2F;RPM-GPG-KEY&#x2 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/Docker%E5%AE%89%E8%A3%85superset/" title="Docker安装superset">Docker安装superset</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


挂载目录到本地mkdir /Users/yangaipeng/Desktop/incubator-superset/docker_superset/superset
启动docker supersetdocker run -d -p 8088:8088 -v /Users/yangaipeng/Desktop/incubator-superset/docker_superset/superset:/home/superset –name superset2 superset-release-tag
增加配置文件将配置文件superset_config.py放到/Users/yangaipeng/Desktop/incubator-superset/docker_superset/superset目录下
在superset_config.py将mysql地址配置为host.docker.internal，表示让docker中的superset访问本机数据库
设置用户名和密码docker exec -it 2326fa0a7d8b fabmanager create-admi ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/JVM%E7%AE%97%E6%B3%95/" title="JVM垃圾回收算法与收集器">JVM垃圾回收算法与收集器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


垃圾回收方法标记清除算法适用：年轻带，年老带
缺点：不连续内存碎片，导致大对象直接进入年老带或者直接触发下一次GC
复制算法适用：年轻带（更适合“朝生夕死”），不适用于年老带，因为可能存在100%存活的极端情况
缺点：复制算法会导致浪费一定的survivor内存空间，现在内存算法都是经过改良更适合年轻带，且堆中的Eden和2个survivor比例是 8：1：1
标记整理适用：年老带（更适合“朝生夕死”）
分带收集算法适用：根据各个年代的特点使用最适当的收集算法
部分垃圾回收器CMS收集器初始标记（此处会stop-the-world）
并发标记
重新标记（此处会stop-the-world）
并发清除
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/Hue%E9%85%8D%E7%BD%AEPresto/" title="Hue配置Presto">Hue配置Presto</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


python3安装pyhive进入hue安装目录/usr/local/hue/hue-4.3.0/
./build/env/bin/pip install pyhive
在/usr/local/hue/hue-4.3.0/desktop目录编辑
12345vim desktop&#x2F;conf&#x2F;hue.ini[[[presto]]]      name &#x3D; Presto      interface&#x3D;sqlalchemy      options&#x3D;&#39;&#123;&quot;url&quot;: &quot;presto:&#x2F;&#x2F;172.22.222.89:9090&#x2F;hive_danke&#x2F;default&quot;&#125;&#39;

重启huekill pid 
/usr/local/hue/hue-4.3.0/build/env/bin/python2.7 /usr/local/hue/hue-4.3.0/build/env/bin/hue runcherrypyserver
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java线程池">Java线程池</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


TheadPoolExecutor队列满时候的丢弃策略DiscardPolicy：不处理，直接丢弃掉；AbortPolicy：直接抛出 RejectedExecutionException 异常，这是默认的拒绝策略；DiscardOldestPolicy：丢弃最老的任务，并执行当前任务；CallerRunsPolicy：由调用线程本身运行任务，以减缓提交速度，会阻塞主线程；
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/Linux%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BAparted%E5%91%BD%E4%BB%A4/" title="Linux挂载分区parted命令">Linux挂载分区parted命令</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


分区命令如下
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/Presto%E5%AF%BC%E5%87%BA%E5%88%B0csv/" title="Presto导出到csv">Presto导出到csv</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


nohup presto –server localhost:9090 –catalog hive_danke –schema default -f /tmp/tmp.sql –output-format CSV &amp;&gt; /data/xiongyan_yanzheng.csv &amp;
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/spark-submit%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0jars/" title="spark-submit时候添加jars">spark-submit时候添加jars</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


spark-submit时单独添加jarsspark-submit –jars app-util-1.0.0.jar –class com.dankegongyu.dailyremain.DailyRemain –master yarn –deploy-mode client /data/bigdata/app-daily-remain-1.0.0.jar $yesterday
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/%E4%BD%BF%E7%94%A8Macpro%E5%88%9B%E5%BB%BAcentos7%E5%90%AF%E5%8A%A8%E7%9B%98/" title="使用Macpro创建centos7启动盘">使用Macpro创建centos7启动盘</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容




Macpro 查看新增优盘diskutil list
umount u盘
diskutil unmountDisk /dev/disk2
Macpro dd命令写入sudo dd if=/Users/yxs1112003/Downloads/CentOS-7-x86_64-DVD-1503-01.iso of=/dev/disk2 bs=4m
centos7 显示进度条的dd命令
dd if=./centos7.1.iso of=/dev/sdb1 status=progress
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2020/06/03/%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85flink%EF%BC%8C%E9%80%82%E9%85%8Dhdp%E7%89%88%E6%9C%AChadoop/" title="手动编译安装flink，适配ambari hdp版本hadoop">手动编译安装flink，适配ambari hdp版本hadoop</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2020-06-03T02:40:30.000Z" title="Created 2020-06-03 10:40:30">2020-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


找到ambari hadoop版本在hdp下载目录找到当前hadoop版本
http://repo.hortonworks.com/content/repositories/releases/org/apache/hadoop/hadoop-common/
前面是hadoop版本，后面是hdp版本
clone flinkclone flink源码
git clone https://github.com/apache/flink.git
切换分支
手动编译在工程目录执行 git checkout release-1.6.4-rc1
Flink编译安装
mvn clean install -DskipTests -Drat.skip=true -Pvendor-repos -Dhadoop.version=2.7.3.2.6.5.0-292
参考：
https://www.bbsmax.com/A/B0zqV4OnJv/
</div></div></div><div class="recent-post-item"><div class="recent-post-info"><a class="article-title" href="/2012/06/15/ambari%E9%9B%86%E7%BE%A4datanode%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98/" title="ambari集群datanode出现OOM问题">ambari集群datanode出现OOM问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2012-06-15T06:44:51.000Z" title="Created 2012-06-15 14:44:51">2012-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="content">文章内容


问题描述hadoop-worker004、hadoop-worker005有时候会断连接，ambari显示datanode dead，看日志里提示datanode OOM
解决方案查看是由于hadoop-worker004、hadoop-worker005 CPU和IO负载压力太大导致的
经调查由于sql查询的数据在hadoop-worker004、hadoop-worker005上属于热点数据，且这两个节点数据比较多，需要做rebalance
其他查看IO负载命令12utity占比，越接近100%，磁盘IO压力越大iostat -dmx 1



</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yinxs2003</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" title="概念-Java内存模型">概念-Java内存模型</a><time datetime="2023-04-14T16:00:00.000Z" title="Created 2023-04-15 00:00:00">2023-04-15</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/" title="概念-在Spring中如何解决循环依赖的问题">概念-在Spring中如何解决循环依赖的问题</a><time datetime="2021-05-30T16:00:00.000Z" title="Created 2021-05-31 00:00:00">2021-05-31</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/" title="Java-jstack查看线程状态">Java-jstack查看线程状态</a><time datetime="2021-05-25T16:00:00.000Z" title="Created 2021-05-26 00:00:00">2021-05-26</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/" title="Java-使用guava缓存的例子">Java-使用guava缓存的例子</a><time datetime="2021-04-28T16:00:00.000Z" title="Created 2021-04-29 00:00:00">2021-04-29</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/" title="概念-Mysql之redolog_binglog_mvcc.md">概念-Mysql之redolog_binglog_mvcc.md</a><time datetime="2021-04-13T16:00:00.000Z" title="Created 2021-04-14 00:00:00">2021-04-14</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>Categories</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">技术</span><span class="card-category-list-count">80</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>Tags</span></div><div class="card-tag-cloud"><a href="/tags/Linux/" style="font-size: 1.26em; color: #999fa8">Linux</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.42em; color: #99a6b7">大数据</a> <a href="/tags/%E6%8A%80%E6%9C%AFJava/" style="font-size: 1.34em; color: #99a3b0">技术Java</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.1em; color: #999">面试</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.5em; color: #99a9bf">算法</a> <a href="/tags/Java/" style="font-size: 1.18em; color: #999ca1">Java</a> <a href="/tags/%E6%A6%82%E5%BF%B5/" style="font-size: 1.34em; color: #99a3b0">概念</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>Archives</span><a class="card-more-btn" href="/archives/" title="More">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">April 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">May 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">April 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">March 2021</span><span class="card-archive-list-count">16</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/02/"><span class="card-archive-list-date">February 2021</span><span class="card-archive-list-count">9</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/01/"><span class="card-archive-list-date">January 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/11/"><span class="card-archive-list-date">November 2020</span><span class="card-archive-list-count">9</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/10/"><span class="card-archive-list-date">October 2020</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>Info</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">Article :</div><div class="item-count">80</div></div><div class="webinfo-item"><div class="item-name">UV :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">PV :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Last Push :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-04-22T00:50:43.240Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By yinxs2003</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>