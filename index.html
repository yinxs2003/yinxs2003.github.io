<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>工作随笔</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0-rc1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">工作随笔</h1><a id="logo" href="/.">工作随笔</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2023/06/05/Java-%E9%9B%B6%E6%8B%B7%E8%B4%9D/">Java-零拷贝</a></h1><div class="post-meta">2023-06-05</div><div class="post-content">零拷贝传统的IO存在什么问题？为什么引入零拷贝的？如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。
传统 I&#x2F;O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I&#x2F;O 接口从磁盘读取或写入。
代码通常如下，一般会需要两个系...</div><p class="readmore"><a href="/2023/06/05/Java-%E9%9B%B6%E6%8B%B7%E8%B4%9D/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/05/17/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D-CPU%E9%A3%99%E5%8D%87/">no-title</a></h1><div class="post-meta">2023-05-17</div><div class="post-content">1.先用top查看那个程序占用cpu多，可以知道3913这个java进程CPU使用飙高

2.使用命令ps -mp 3913 -o THREAD,tid,time查看jvm里的线程

3.可以看到tid为3936 cpu使用率异常，但3936是十进制的，使用print “%x\n” 3936命令转为16进制得到f60

4.使用jstack抓取堆栈最近20行...</div><p class="readmore"><a href="/2023/05/17/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D-CPU%E9%A3%99%E5%8D%87/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/05/09/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java-线程池</a></h1><div class="post-meta">2023-05-09</div><div class="post-content">
补充队列满时候的丢弃策略
DiscardPolicy：不处理，直接丢弃掉；
AbortPolicy：直接抛出 RejectedExecutionException 异常，这是默认的拒绝策略；
DiscardOldestPolicy：丢弃最老的任务，并执行当前任务；
CallerRunsPolicy：由调用线程本身运行任务，以减缓提交速度，会阻塞主线程；

...</div><p class="readmore"><a href="/2023/05/09/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/05/07/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2/">Spring-Bean的生命周期（二）</a></h1><div class="post-meta">2023-05-07</div><div class="post-content">Bean的生命周期：

获取Bean的定义
xml和annotion获取初始Bean定义
经BeanFactoryPostProcessors处理获取完整定义


反射得到Bean对象
初始化Bean（赋值Bean属性）
初始化普通Bean对象
初始化aware接口对象


使用Bean
销毁Bean


</div><p class="readmore"><a href="/2023/05/07/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1/">Spring-Bean的生命周期（一）</a></h1><div class="post-meta">2023-05-06</div><div class="post-content">
</div><p class="readmore"><a href="/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/">Ubuntu mysql5.7 安装</a></h1><div class="post-meta">2023-05-01</div><div class="post-content">123456789wget http://repo.mysql.com/mysql-apt-config_0.8.10-1_all.debsudo dpkg -i mysql-apt-config_0.8.10-1_all.debsudo dpkg-reconfigure mysql-apt-configsudo apt updatesudo apt-cac...</div><p class="readmore"><a href="/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/27/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/">Java-自定义注解</a></h1><div class="post-meta">2023-04-27</div><div class="post-content"><h4 id="元注解-Target"><a href="#元注解-Target" class="headerlink" title="元注解@Target"></a>元注解@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>第一步，用<code>@interface</code>定义注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2023/04/27/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java-虚拟机</a></h1><div class="post-meta">2023-04-27</div><div class="post-content">一. Java虚拟机内存区域1. 运行时数据区   
2. 程序计数器(Program Counter Register)
1、程序计数器是线程内(每个线程都有唯一的、封闭的)一小块内存区域
2、计数器指定的是当前虚拟机执行指令的地址
3、当虚拟机执行的是Native方法时,计数器值为空(Undefined),此内存区域是唯一一个在Java虚拟机规范中没有规...</div><p class="readmore"><a href="/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/">多线程-Condition</a></h1><div class="post-meta">2023-04-27</div><div class="post-content">使用ReentrantLock比直接使用synchronized更安全，可以替代synchronized进行线程同步。
但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？
答案是使用Condition对象来实现wait和notify的...</div><p class="readmore"><a href="/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">Java-HotSpot虚拟机创建对象</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">Java对象的创建创建java对象大概归纳为以下步骤

类加载检查
为新生对象分配内存
对类进行初始化操作

1.类加载检查当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
2.为新生对象分配内存指针碰...</div><p class="readmore"><a href="/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/Java-JVM_Options/">Java-jvm options</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">-Xmx10m设置虚拟机最大堆内存
-Xms10设置虚拟机初始堆内存，可与-Xmx相等避免每次GC重新内存分配
-Xmn10m设置堆年轻代大小
-Xss1m设置栈内存
#出现 OOME 时生成堆 dump:-XX:+HeapDumpOnOutOfMemoryError#生成堆文件地址：-XX:HeapDumpPath&#x3D;&#x2F;temp&#x2F...</div><p class="readmore"><a href="/2023/04/24/Java-JVM_Options/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java-内存模型</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">1. 内存模型 
2. 内存间的交互操作2.1. 定义操作
lock(锁定)：作用于主内存的变量,它把一个变量标识为一条线程独占的状态.
unlock(解锁)：作用于主内存的变量,它把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定.
read(读取)：作用于主内存的变量,它把一个变量的值从主内存传输到线程的工作内存中,以便随后的load动作...</div><p class="readmore"><a href="/2023/04/24/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java-多线程实现</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">1. JAVA与线程1.1 线程的实现
实现方式:使用内核线程实现、 使用用户线程实现和使用用户线程加轻量级进程混合实现.
JDK1.2之前是基于用户线程实现的，JDK1.2及以后是基于操作系统原生线程模型实现的.

1.2 Java线程调度
线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协同式线程调度(Cooperative Th...</div><p class="readmore"><a href="/2023/04/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/Spring-Ioc%E5%92%8CAop/">Spring-Ioc和Aop</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">IoC、Bean、依赖注入IoC是控制反转，含义是把创建对象的操作交给Spring执行
把创建好的对象放到IoC容器，放到IoC容器的对象叫做Bean。放入IoC容器之前的赋值这个动作叫做依赖注入
AOP指的是在执行某个方法这个时刻，会先执行一些预定义好的操作。这个执行过程叫做切面。比较常见的例子是打印日志、Spring的事务
Bean创建的过程有一个步骤可...</div><p class="readmore"><a href="/2023/04/24/Spring-Ioc%E5%92%8CAop/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier/">多线程-CyclicBarrier</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">CyclicBarrier是java提供的同步辅助类。一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)，才得以继续执行。阻塞子线程，当阻塞数量到达定义的参与线程数后，才可继续向下执行。
1234567891011121314151617181920212223public class Barrier...</div><p class="readmore"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CountDownLatch/">多线程-CountDownLatch</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">CountDownLatch 是多线程控制的一种工具，它被称为 门阀、 计数器或者 闭锁。这个工具经常用来用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。下面我们就来一起认识一下 CountDownLatch
认识 CountDownLatchCountDownLatch  能够使一个线程在等待另外一些线程完成各自工作之后，再继...</div><p class="readmore"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CountDownLatch/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E4%BD%BF%E7%94%A8/">多线程-ReentrantLock使用</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">从Java 5开始，引入了一个高级的处理并发的java.util.concurrent包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。
我们知道Java语言直接提供了synchronized关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。
java.util.concurrent.locks包提供的Reentran...</div><p class="readmore"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E4%BD%BF%E7%94%A8/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E5%8E%9F%E7%90%86/">多线程-ReentrantLock原理</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">如果你在之前的文章中我们已经了解过了 java中的管程sychronized实现原理，那么再来看AbstractQueuedSynchronizer的实现就会非常简单了，虽然使用的加锁技术有不同之处，但是他们都是基于同样的理念去实现的.
打开ReentrantLock 的源码你会发现，ReentrantLock  的所有操作都是基于Sycn对象去操作的，而S...</div><p class="readmore"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E5%8E%9F%E7%90%86/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Semaphore/">多线程-信号量</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">
前面我们讲了各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。
还有一种受限资源，它需要保证同一时刻最多有N个线程能访问，比如同一时刻最多创建100个数据库连接，最多允许10个用户下载等。
这种限制数量的锁，如果用Lock数组来实现，就太麻烦了...</div><p class="readmore"><a href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Semaphore/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-CheckPoint/">大数据-CheckPoint</a></h1><div class="post-meta">2023-04-24</div><p class="readmore"><a href="/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-CheckPoint/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-Flink%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/">大数据-状态后端</a></h1><div class="post-meta">2023-04-24</div><div class="post-content">可用的State BackendFlink提供三种开箱即用的State Backend：

HashMapStateBackend 
EmbeddedRocksDBStateBackend

HashMapStateBackendHashMapStateBackend在java堆上保存数据，健值对的状态和windows函数使用hashtable存储值或者触发...</div><p class="readmore"><a href="/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-Flink%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">概念-Java内存模型</a></h1><div class="post-meta">2023-04-15</div><div class="post-content">2.垃圾收集算法基于分代收集理论，可以分为年轻代、年老代两类收集算法。
年轻代：标记复制
年老代：标记整理
标记清除其中标记清除算法是最基础的算法，后续算法都是基于标记清楚算法改进得到的
标记清除算法缺点：

执行效率不稳定，当年轻代有大量回收对象时候，需要执行大量标记清除动作，而标记动作通常是需要stop the world的，所以可能存在性能问题
内存碎...</div><p class="readmore"><a href="/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/">概念-在Spring中如何解决循环依赖的问题</a></h1><div class="post-meta">2021-05-31</div><div class="post-content">什么是循环依赖一般场景是一个Bean A依赖Bean B,而Bean B也依赖Bean A.Bean A → Bean B → Bean A
当然我们也可以添加更多的依赖层次，比如：Bean A → Bean B → Bean C → Bean D → Bean E → Bean A
Spring发生了什么当 Spring 上下文加载所有 bean 时，它会...</div><p class="readmore"><a href="/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/">Java-jstack查看线程状态</a></h1><div class="post-meta">2021-05-26</div><div class="post-content">有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增
高了、出现了死锁、死循环等，我们该如何分析呢？
由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要
看下jvm的内部线程的执行情况，然后再进行分析查找出原因。
用法：jstack 

java线程的6种状态
初始态（NEW）
创建一个Thread对象...</div><p class="readmore"><a href="/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/">Java-使用guava缓存的例子</a></h1><div class="post-meta">2021-04-29</div><div class="post-content">使用guava缓存数据源
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.code.note.test;import java.util.Ha...</div><p class="readmore"><a href="/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/">概念-Mysql之redolog_binglog_mvcc.md</a></h1><div class="post-meta">2021-04-14</div><div class="post-content">CheckPoint数据在内存中的这个过程叫做data buffer，数据已经存储在磁盘上叫data file。
事务的日志也一样，在内存中叫log  buffer，在磁盘上叫log file。
data buffer的数据定时写入到data file，这个定时执行的过程是checkpoint。
如果checkpoint失败，在恢复时候，只需要做最后一次re...</div><p class="readmore"><a href="/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/">Linux-Es排除节点</a></h1><div class="post-meta">2021-04-08</div><div class="post-content">题目描述Es集群中有一个节点性能很差，会导致Es整体查询变慢，当该物理节点被关闭但存在部分分片没有分配到其他节点上。
解决方案因为配置文件中被关闭的机器ip是存在的，Es存在一个探活过程，所以这些分片没有被自动迁移到其他节点。
可以通过Exclude该机器的IP来动态删除该机器，删除10.1.1.1节点命令：
12345curl -XPUT http://1...</div><p class="readmore"><a href="/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">算法-数组中的第K个最大元素</a></h1><div class="post-meta">2021-04-08</div><div class="post-content">题目描述12345678910111213在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例 1:输入: [3,2,1,5,6,4] 和 k = 2输出: 5示例 2:输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4说明:你可以假设 k 总是有效的，且 1 ...</div><p class="readmore"><a href="/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/">算法-八大排序算法之堆排序</a></h1><div class="post-meta">2021-04-07</div><div class="post-content">题目描述123456789101112131415给你一个整数数组 nums，请你将该数组升序排列。 示例 1：输入：nums = [5,2,3,1]输出：[1,2,3,5]示例 2：输入：nums = [5,1,1,2,0,0]输出：[0,0,1,1,2,5]

堆排序的性质
堆是一颗满二叉树
子节点和父节点下标关系：leftChild &#x3D; pa...</div><p class="readmore"><a href="/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">算法-快速排序</a></h1><div class="post-meta">2021-04-02</div><div class="post-content">快速排序1以第一个数字6作为基数，使用双指针i,j进行双向遍历：

1、i从左往右寻找第一位大于基数（6）的数字，j从右往左寻找第一位小于基数（6）的数字；
2、找到后将两个数字进行交换。继续循环交换直到i&gt;&#x3D;j结束循环；
3、最终指针i&#x3D;j,此时交换基数和i(j)指向的数字即可将数组划分为小于基数（6）&#x2F;基数（6）&#x...</div><p class="readmore"><a href="/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/">概念-Java内存模型</a></h1><div class="post-meta">2021-03-24</div><div class="post-content">Java内存模型被提出的背景Java内存模型被提出主要是为解决如下问题

硬件效率问题
计算机内存比CPU慢很多，所以需要在CPU和主存之间加寄存器和高速缓存。
缓存一致性问题
代码指令重排导致多线程执行的“乱序问题”

什么是Java内存模型Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，简称 JMM）来屏蔽掉各...</div><p class="readmore"><a href="/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/">算法-二叉树剪枝</a></h1><div class="post-meta">2021-03-08</div><div class="post-content">

这个题得用后序遍历，用前序遍历删不干净

12345678910111213141516public TreeNode pruneTree(TreeNode root) &#123;        if (root == null) &#123;            return null;        &#125;        root.left...</div><p class="readmore"><a href="/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">算法-重建二叉树</a></h1><div class="post-meta">2021-03-08</div><div class="post-content">
题目分析

前序遍历的特点是preorder[0]是根节点
中序遍历的特点是跟节点左边是左子树，跟节点右边是右子树

123456789101112131415161718192021222324252627282930313233343536373839public class Test &#123;    public TreeNode buildTr...</div><p class="readmore"><a href="/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/">Linux-vim正则查找</a></h1><div class="post-meta">2021-03-05</div><div class="post-content">使用vim查询spend&#x3D;14435的命令是,
&#x2F;spend&#x3D;[1-9]\{5,5\}
其中[1-9]表示任意一个1～9的数字
\{5,5\}上面的数字表示出现了5次，即匹配14435
</div><p class="readmore"><a href="/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">概念-CMS垃圾回收器</a></h1><div class="post-meta">2021-03-05</div><div class="post-content">CMS垃圾回收CMS垃圾回收收集所有代。它会使用最小的资源来进行大多数垃圾回收工作，通常低停顿并发收集器不会复制或者压缩活动的对象。在不移动活动对象的情况下完成垃圾回收。如果内存碎片导致无法正常分配内存，请分配更大的堆内存。
CMS在年老带执行垃圾收集会氛围以下几个阶段



Phase
Description



(1) Initial Mark (St...</div><p class="readmore"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/">概念-G1垃圾回收器1</a></h1><div class="post-meta">2021-03-05</div><div class="post-content">G1垃圾回收G1（Garbage-First） 收集器是为服务器准备的垃圾回收器，是为很多核大内存服务器准备的垃圾回收器。它在达到高吞吐量时满足了GC停顿时间可预测这样的一个目标。在Oracle JDK 7 update4 及以后的版本被支持。G1收集器是为如下程序设计：

垃圾收集于应用线程之间是并发的
紧凑的自由空间且没有较长的GC停顿时间
需要更可以预...</div><p class="readmore"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/">概念-G1垃圾回收器2</a></h1><div class="post-meta">2021-03-05</div><div class="post-content">G1收集器采用了另一种分配堆的方法。 后面的图片逐步检查了G1系统。
G1堆结构G1堆事一个内存区域被切分为多个相同大小的区域（regions）

区域大小是在jvm一启动就被选择的。JVM通常会生成两千个区域，每个区域大小相同，在1到32MB之间
G1堆分配事实上，这些区域被映射成Eden、Survivor和年老代

图片中的颜色显示了哪个区域与哪个角色相...</div><p class="readmore"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/">概念-Spring源码</a></h1><div class="post-meta">2021-03-05</div><div class="post-content">聊聊Spring
控制反转思想IOC
依赖注入AOP
bean的生命周期
循环依赖
三级缓存
FactoryBean和BeanFactory区别
ApplicationContxt和BeanFactory区别
Spring中的设计模式

</div><p class="readmore"><a href="/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/">概念-B树和B+树</a></h1><div class="post-meta">2021-03-03</div><div class="post-content">B树B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点

排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
子节点数：非叶节点的子节点数&gt;1，且&lt;&#x3D;M ，且M&gt;&#x3D;2，空树除外（注：M阶代表一个树节点最多...</div><p class="readmore"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/">概念-Mysql索引面试题</a></h1><div class="post-meta">2021-03-03</div><div class="post-content">hash索引和B+Tree索引区别
hash索引只适合等值查询，无法进行范围查询
存在大量键值重复时候，hash索引效率很低
hash索引无法利用索引进行排序
hash索引无法利用联合索引做前缀匹配原则

B+Tree叶子节点能存储哪些东西可以存储整行数据或者是主键索引值，当存储整行数据时候为主键索引，存储主键索引时候是非主键索引。非主键索引在进行查询时候需...</div><p class="readmore"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/">概念-书写高质量SQL的若干建议</a></h1><div class="post-meta">2021-03-03</div><div class="post-content">表结构：（有一个联合索引idx_userid_age，userId在前，age在后）
12345678CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `userId` int(11) NOT NULL,  `age` int(11) DEFAULT NULL,  `name` var...</div><p class="readmore"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">概念-基本数据类型</a></h1><div class="post-meta">2021-03-03</div><div class="post-content">基本数据类型枚举
数字类型：byte，short，int，long
浮点型：float，double
布尔类型：boolean
字符型：char

计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0～255，换算成十六进制是00 ~ ff。其中最高位...</div><p class="readmore"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">概念-面试题整理</a></h1><div class="post-meta">2021-03-03</div><div class="post-content">hash索引和b+tree索引区别hash索引只能等值查询，无法进行范围查询hash索引无法索引自动排序hash索引键值重复严重效率变得很低hash索引无法使用做匹配前缀原则
B+Tree数据叶子结点数据存储B+Tree叶子节点可以存储整行的数据，也可以存储主键索引。存储整行数据表示是主键索引。存储主键索引值表示是非主键索引。非主键索引查找数据需要先找到主键...</div><p class="readmore"><a href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/02/%E6%A6%82%E5%BF%B5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/">概念-String为什么被设计为不可变的</a></h1><div class="post-meta">2021-03-02</div><div class="post-content">不可变的好处1. 可以缓存 hash 值
因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
2. String Pool 的需要
如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 Strin...</div><p class="readmore"><a href="/2021/03/02/%E6%A6%82%E5%BF%B5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/02/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">算法-回文链表</a></h1><div class="post-meta">2021-03-02</div><div class="post-content">题目
这个题用链表方式可以实现，但效率很低
因为是回文链表，使用快慢指针，每次循环让fast走两步，slow走一步
反转后半段链表，反转起始节点为当前slow节点
题目解答12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solu...</div><p class="readmore"><a href="/2021/03/02/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/03/01/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">算法-反转链表</a></h1><div class="post-meta">2021-03-01</div><div class="post-content">题目概述
题目解答迭代解法

3和4 ：反转节点
1、2:   后移旧头节点

12345678910111213public ListNode reverseList(ListNode head) &#123;    ListNode newHead = null;    while(head != null)&#123;        ListNode ...</div><p class="readmore"><a href="/2021/03/01/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/28/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%92%8C%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">算法-两数、三数之和</a></h1><div class="post-meta">2021-02-28</div><div class="post-content">两数之和
两数之和的话需要遍历两次
条件是nums[i] + nums[j] &#x3D;&#x3D; target

题目解答123456789101112131415161718192021222324252627package com.code.note.arrays;import java.util.Arrays;public class TwoSu...</div><p class="readmore"><a href="/2021/02/28/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%92%8C%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/24/%E7%AE%97%E6%B3%95-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">算法-二叉树的镜像</a></h1><div class="post-meta">2021-02-24</div><div class="post-content">题目地址剑指 Offer 27. 二叉树的镜像题目概述
题目分析
递归结束条件：root为空返回true

递归每层做什么：前序遍历所有节点，并交换left和right节点

递归返回：当前root节点


题目解答12345678910111213141516171819202122232425262728293031/** * Definition fo...</div><p class="readmore"><a href="/2021/02/24/%E7%AE%97%E6%B3%95-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/19/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">算法-二叉树的最近公共祖先</a></h1><div class="post-meta">2021-02-19</div><div class="post-content">题目地址剑指 Offer 68 - II. 二叉树的最近公共祖先题目概述
题目分析
递归结束条件：返回节点为空时结束递归
根据题目可以得知p、q节点分布存在三种情况：
p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先（即根节点root）
p q 都在左子树 （先被找到的即为最近父节点）
p q 都在右子树


递归返回：无返回

题目解答12...</div><p class="readmore"><a href="/2021/02/19/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/19/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACdouble/">算法-二叉树的最近公共祖先</a></h1><div class="post-meta">2021-02-19</div><div class="post-content">题目概述输入字符串转成double数字
题目分析
字符串是否为空
字符串是否包含非数字
字符串是否包含正负号
是否超过double最大值

题目解答1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575...</div><p class="readmore"><a href="/2021/02/19/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACdouble/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/19/%E7%AE%97%E6%B3%95-%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/">算法-二叉树的最近公共祖先</a></h1><div class="post-meta">2021-02-19</div><div class="post-content">题目概述https://leetcode-cn.com/problems/maximum-binary-tree/
题目分析
二叉树的根是数组 nums 中的最大元素（写一个函数获取当前数组中的最大index）

左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
写一个函数用来返回

...</div><p class="readmore"><a href="/2021/02/19/%E7%AE%97%E6%B3%95-%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%E5%80%BC/">算法-二叉搜索树第K大节点值</a></h1><div class="post-meta">2021-02-17</div><div class="post-content">题目地址剑指 Offer 54. 二叉搜索树的第k大节点题目概述
题目分析为什么在中序遍历时候更改cnt值？大概是因二叉搜索树的中序遍历是有序的

递归结束条件：当x节点为空时结束递归
递归每层做什么：right -&gt; mid -&gt; left 依次访问，在中序遍历修改cnt值，当++cnt &#x3D;&#x3D; k时记录val并结束遍历
递归...</div><p class="readmore"><a href="/2021/02/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%E5%80%BC/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/14/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">算法-平衡二叉树</a></h1><div class="post-meta">2021-02-14</div><div class="post-content">题目地址110. 平衡二叉树题目概述
题目分析左右子树高度差大于1返回false，这个需要递归到每一层

递归结束条件：root为空返回true，左右子树高度差值大于1返回false

递归每层做什么：计算左树、右树高度

递归返回：高度值


题目解答123456789101112131415161718public boolean isBalanced(...</div><p class="readmore"><a href="/2021/02/14/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/14/%E7%AE%97%E6%B3%95-%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">算法-是否是对称二叉树</a></h1><div class="post-meta">2021-02-14</div><div class="post-content">题目地址101. 对称二叉树题目概述
题目分析递归的难点在于：找到可以递归的点 为什么很多人觉得递归一看就会，一写就废。 或者说是自己写无法写出来，关键就是你对递归理解的深不深。
对于此题： 递归的点怎么找？从拿到题的第一时间开始，思路如下：
1.怎么判断一棵树是不是对称二叉树？ 答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对...</div><p class="readmore"><a href="/2021/02/14/%E7%AE%97%E6%B3%95-%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/02/12/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/">算法-合并二叉树</a></h1><div class="post-meta">2021-02-12</div><div class="post-content">题目地址617. 合并二叉树题目概述
这道题其实就是把二叉树每个节点的值相加，并放到新的二叉树节点，如果某棵树当前节点为空，他的value值是0
其实这个题主要考察的是二叉树遍历，只不过需要同时遍历两棵树，二叉树遍历代码如下:
123456789101112private Node walk(Node x) &#123;    if (x == null) ...</div><p class="readmore"><a href="/2021/02/12/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/01/27/Mybatis-%E6%8B%BC%E8%A3%85%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6sql/">Mybatis拼装复杂条件sql</a></h1><div class="post-meta">2021-01-27</div><div class="post-content"><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>因为mybatis不好拼装如下sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> doc_id,encourage_card_id </span><br><span class="line"><span class="keyword">from</span> encourage_card_quantitative_fake_progress </span><br><span class="line"><span class="keyword">where</span> (doc_id <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> encourage_card_id <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>) <span class="keyword">or</span>  (doc_id <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> encourage_card_id <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span>) </span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2021/01/27/Mybatis-%E6%8B%BC%E8%A3%85%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6sql/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2021/01/27/%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82ifelse%E9%97%AE%E9%A2%98/">模式-策略模式+工厂解决复杂ifelse过多问题</a></h1><div class="post-meta">2021-01-27</div><div class="post-content"><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>1.按小时、天查询不同表</p>
<p>2.按照特定领域、全领域按照不同字段排序</p>
<p>3.按照文章类型进行排序</p>
<p>因此条件很多，需要多个if条件判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getHourOrDayDocs</span><span class="params">(String cate, BillboardScheduleReq.PostType postType, BillboardScheduleReq.SortType sortType)</span> &#123;</span><br><span class="line">        List&lt;MysqlBillboardCateTopviewDoc&gt; hourOrDayDocs;</span><br><span class="line">        <span class="keyword">if</span> (sortType == BillboardScheduleReq.SortType.hour) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(cate)) &#123;<span class="comment">// 全领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocHourlyService.listAllCatePostTypeHourly(postType.getValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//分领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocHourlyService.listTypeCatePostTypeHourly(cate, postType.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 天排行榜</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(cate)) &#123; <span class="comment">// 全领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocDailyService.listAllCatePostTypeDaily(postType.getValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//分领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocDailyService.listTypeCatePostTypeDaily(cate, postType.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hourOrDayDocs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2021/01/27/%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82ifelse%E9%97%AE%E9%A2%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/30/Flink-SingleOutputStreamOperator%E7%94%A8%E6%B3%95/">Flink-SingleOutputStreamOperator用法</a></h1><div class="post-meta">2020-11-30</div><div class="post-content">Flink DataStream中union和connect都有一个共同的作用，就是将2个流或多个流合成一个流。但是两者的区别是：union连接的2个流的类型必须一致，connect连接的流可以不一致，但是可以统一处理。
具体看下面示例：
123public class ConnectOperator &#123;&#125;

connect可以将2个不同...</div><p class="readmore"><a href="/2020/11/30/Flink-SingleOutputStreamOperator%E7%94%A8%E6%B3%95/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/30/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20/">算法-构造最大二叉树</a></h1><div class="post-meta">2020-11-30</div><div class="post-content"><p>原题链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></p>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ol>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ol>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p></div><p class="readmore"><a href="/2020/11/30/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/15/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/">算法-二叉树深度优先和广度优先遍历</a></h1><div class="post-meta">2020-11-15</div><div class="post-content"><h2 id="深度优先遍历算法（DFS）"><a href="#深度优先遍历算法（DFS）" class="headerlink" title="深度优先遍历算法（DFS）"></a>深度优先遍历算法（DFS）</h2><p>深度优先遍历算法（Depth-First-Search），是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v所在的边都一杯探寻过，搜索将回溯到发现节点v的那条边的节点。选择其中一个座位源节点并重复以上过程，整个进程反复进行，直到所有节点都被访问位置。</p>
<p>前序、中序、后序遍历都属于深度优先遍历算法</p></div><p class="readmore"><a href="/2020/11/15/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/07/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/">算法-单链表</a></h1><div class="post-meta">2020-11-07</div><div class="post-content"><p>单链表代码如下</p></div><p class="readmore"><a href="/2020/11/07/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%BA%8C)/">Java-自定义注解（二）</a></h1><div class="post-meta">2020-11-05</div><div class="post-content"><p>再读完Java自定义注解（一）我们可以通过代码来实现我们自己的自定义注解</p>
<h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>EventBean类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventName(&quot;coding now...&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventType(eventType = EventType.Type.MEETING)</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@User(id = 1, name = &quot;testName&quot;, email = &quot;15090552277@163.com&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%BA%8C)/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/">Java-自定义注解(一)</a></h1><div class="post-meta">2020-11-05</div><div class="post-content"><h4 id="元注解-Target"><a href="#元注解-Target" class="headerlink" title="元注解@Target"></a>元注解@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>第一步，用<code>@interface</code>定义注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/05/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/">算法-二叉树</a></h1><div class="post-meta">2020-11-05</div><div class="post-content"><p>二叉树需要声明一个Node节点，包含节点得值，以及左右两个子节点</p>
<p>Node节点代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;&#123;</span><br><span class="line">    T value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node(T value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2020/11/05/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/11/03/Flink%20Connect%E5%92%8CUnion%E5%8C%BA%E5%88%AB/">Flink Connect和Union区别</a></h1><div class="post-meta">2020-11-03</div><div class="post-content">Flink DataStream中union和connect都有一个共同的作用，就是将2个流或多个流合成一个流。但是两者的区别是：union连接的2个流的类型必须一致，connect连接的流可以不一致，但是可以统一处理。
具体看下面示例：
123456789101112131415161718192021222324252627282930313233343...</div><p class="readmore"><a href="/2020/11/03/Flink%20Connect%E5%92%8CUnion%E5%8C%BA%E5%88%AB/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/10/20/Java8%E7%9A%84Function%E5%92%8CBI_Function/">Java8的Function和BI_Function</a></h1><div class="post-meta">2020-10-20</div><div class="post-content">Function函数概念 Function作为一个函数式接口，主要方法apply接受一个参数，返回一个值
举个例子123456789101112131415161718192021222324252627package com.bd.thread;import lombok.extern.slf4j.Slf4j;import java.util.functi...</div><p class="readmore"><a href="/2020/10/20/Java8%E7%9A%84Function%E5%92%8CBI_Function/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/10/20/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/">Java中如何自动调用父类中的资源初始化方法</a></h1><div class="post-meta">2020-10-20</div><div class="post-content">一个简单的例子背景在写程序时候常常有一些资源初始化方法，我们希望这些方法能够被自动调用 ，可以使用如下方式实现自动调用
代码父类代码如下：
1234567891011121314package com.bd.autocall;import lombok.extern.slf4j.Slf4j;@Slf4jpublic abstract class Super ...</div><p class="readmore"><a href="/2020/10/20/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/20/Centos7%E5%AE%89%E8%A3%85python3/">Centos7安装python3</a></h1><div class="post-meta">2020-07-20</div><div class="post-content">下载python3安装包wget -c https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz
安装linux依赖yum install libffi-devel openssl openssl-devel sqlite-devel bzip2-devel -y
在源码安装文件中编辑文件Modules...</div><p class="readmore"><a href="/2020/07/20/Centos7%E5%AE%89%E8%A3%85python3/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BB%93%E5%BA%93/">如何搭建个人仓库</a></h1><div class="post-meta">2020-07-11</div><div class="post-content"><h1 id="ssh端口为22情况"><a href="#ssh端口为22情况" class="headerlink" title="ssh端口为22情况"></a>ssh端口为22情况</h1><p>在服务器端172.27.9.121搭建仓库</p>
<p>1.在仓库目录&#x2F;tmp&#x2F;myproject.git输入git init</p>
<p>2.允许上传代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config receive.denyCurrentBranch ignore</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BB%93%E5%BA%93/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/11/%E9%9D%A2%E8%AF%95-kafka%E4%B8%93%E9%A2%98/">面试-Kafka专题</a></h1><div class="post-meta">2020-07-11</div><div class="post-content"><h1 id="使用Kafka时会遇到的问题"><a href="#使用Kafka时会遇到的问题" class="headerlink" title="使用Kafka时会遇到的问题"></a>使用Kafka时会遇到的问题</h1><ol>
<li>Kafka速度很快的原因</li>
<li>如何保证消息不丢失</li>
<li>Consumer重复消费怎么处理</li>
<li>如何保证消息的有序性</li>
</ol></div><p class="readmore"><a href="/2020/07/11/%E9%9D%A2%E8%AF%95-kafka%E4%B8%93%E9%A2%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/10/ambari%E6%98%BE%E7%A4%BAheartbeat_lost%E9%97%AE%E9%A2%98/">python3下配置spark环境</a></h1><div class="post-meta">2020-07-10</div><div class="post-content">在&#x2F;etc&#x2F;profile中增加如下内容
1234567891011export JAVA_HOME=/usr/local/java/jdk1.8.0_191export PYSPARK_PYTHON=/usr/python3/bin/python3export PYSPARK_DRIVER_PYTHON=/usr/python3/bin...</div><p class="readmore"><a href="/2020/07/10/ambari%E6%98%BE%E7%A4%BAheartbeat_lost%E9%97%AE%E9%A2%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/10/centos7%E8%BF%9E%E6%8E%A5wpa%20enterprise%E4%BC%81%E4%B8%9A%E7%BA%A7wifi/">python3下配置spark环境</a></h1><div class="post-meta">2020-07-10</div><div class="post-content">12345678910111213141516171819$ network-manager.nmcli connection edit type 802-11-wirelessnmcli&gt; goto 802-11-wirelessnmcli 802-11-wireless&gt; set ssid &lt;your_ssid&gt;nmcli 802...</div><p class="readmore"><a href="/2020/07/10/centos7%E8%BF%9E%E6%8E%A5wpa%20enterprise%E4%BC%81%E4%B8%9A%E7%BA%A7wifi/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/07/%E7%AE%97%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">算法-无重复最长子串</a></h1><div class="post-meta">2020-07-07</div><div class="post-content"><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p></div><p class="readmore"><a href="/2020/07/07/%E7%AE%97%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/06/LinkedMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84/">常见OOM及原因分析</a></h1><div class="post-meta">2020-07-06</div><div class="post-content">LinkedMap为什么是有序MapLinkedMap底层存储是数组，初始大小为16
LinkedMap返回的set是有序的，是因为KeySet中的iterator是有序的
LinkedMap在put时候，使用for循环，且起始位置用hashIndex算出来的
1234567891011121314151617181920protected int hash...</div><p class="readmore"><a href="/2020/07/06/LinkedMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/06/OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">常见OOM及原因分析</a></h1><div class="post-meta">2020-07-06</div><div class="post-content"><h1 id="常见OOM类型"><a href="#常见OOM类型" class="headerlink" title="常见OOM类型"></a>常见OOM类型</h1><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>错误信息：java.lang.OutOfMemoryError: Java heap space </p>
<p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 </p></div><p class="readmore"><a href="/2020/07/06/OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/06/Spark%E6%A6%82%E5%BF%B5/">Spark专项训练</a></h1><div class="post-meta">2020-07-06</div><div class="post-content"><h1 id="Spark部署模式"><a href="#Spark部署模式" class="headerlink" title="Spark部署模式"></a>Spark部署模式</h1><ol>
<li>standalone模式，开启7077端口提供服务</li>
<li>spark on yarn模式 ：</li>
<li>client 模式， driver运行在客户端，调试用 </li>
<li>cluster模式， 分布式运行，driver运行在集群子节点</li>
</ol></div><p class="readmore"><a href="/2020/07/06/Spark%E6%A6%82%E5%BF%B5/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/07/03/Flink%E7%AA%97%E5%8F%A3/">Flink窗口</a></h1><div class="post-meta">2020-07-03</div><div class="post-content"><h1 id="什么是窗口"><a href="#什么是窗口" class="headerlink" title="什么是窗口"></a>什么是窗口</h1><p>Windows是处理流试计算的核心。 Windows将流分成有限个大小的“存储桶”，我们可以在“存储桶”上应用计算。</p>
<h1 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h1><h2 id="Tumbling-Window"><a href="#Tumbling-Window" class="headerlink" title="Tumbling Window"></a>Tumbling Window</h2><p>翻滚窗口，无数据重叠</p>
<p>滚动窗口分配器将每个元素分配给指定窗口大小的窗口。 滚动窗口具有固定的大小，并且不重叠。 例如，如果您指定大小为5分钟的翻滚窗口，则将评估当前窗口，并且每五分钟将启动一个新窗口，如下图所示。</p></div><p class="readmore"><a href="/2020/07/03/Flink%E7%AA%97%E5%8F%A3/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/30/ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/">ConcurrentHashMap如何实现的</a></h1><div class="post-meta">2020-06-30</div><div class="post-content"><h1 id="Jdk1-7的ConcurrentHashMap"><a href="#Jdk1-7的ConcurrentHashMap" class="headerlink" title="Jdk1.7的ConcurrentHashMap"></a>Jdk1.7的ConcurrentHashMap</h1><p>jdk1.7中采用<code>Segment</code> + <code>HashEntry</code>的方式进行实现，结构如下：</p>
<p><img src="/images/jdk1.7_ConcurrentHashMap.png" alt="concurrenthashmap_java8"></p>
<p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，因为ssize用位于运算来计算（<code>ssize &lt;&lt;=1</code>），所以Segment的大小取值都是以2的N次方，无关concurrencyLevel的取值，当然concurrencyLevel最大只能用16位的二进制来表示，即65536，换句话说，Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16</p>
<p>每一个Segment元素下的HashEntry的初始化也是按照位于运算来计算，用cap来表示，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如上所示，HashEntry大小的计算也是2的N次方（cap &lt;&lt;&#x3D;1）， cap的初始值为1，所以HashEntry最小的容量为2</p>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置</p>
<p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒</p>
<h1 id="Jdk1-8-ConcurrentHashMap"><a href="#Jdk1-8-ConcurrentHashMap" class="headerlink" title="Jdk1.8 ConcurrentHashMap"></a>Jdk1.8 ConcurrentHashMap</h1><p>Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）。其数据结构如下图所示</p></div><p class="readmore"><a href="/2020/06/30/ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/26/Flink%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/">Flink提交任务</a></h1><div class="post-meta">2020-06-26</div><div class="post-content"><p>Flink以YarnCluster模式提交任务，且指定任务名和队列</p>
<p>flink run -m yarn-cluster -ynm PROD-fink-data-gather  –yarnqueue CClient &#x2F;home&#x2F;cclient&#x2F;danke-flink-data-gather-prod.jar</p></div><p class="readmore"><a href="/2020/06/26/Flink%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/25/Flink%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6/">Flink中的并行度</a></h1><div class="post-meta">2020-06-25</div><div class="post-content">Parallel Execution（并行执行）一个任务被切分成几个并行实例执行，且每个并行实例处理输入任务的一部分数据，并行度会导致乱序问题，任务的并行实力数称为并行性
可以从三个层面限制并行度
Execution Environment Level1env.setParallelism(3);

Client Level1234Client client...</div><p class="readmore"><a href="/2020/06/25/Flink%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/25/Flink%E6%97%B6%E9%97%B4/">Flink中的水印与时间</a></h1><div class="post-meta">2020-06-25</div><div class="post-content"><h1 id="watermark-水印）"><a href="#watermark-水印）" class="headerlink" title="watermark(水印）"></a>watermark(水印）</h1><p>Flink中用于衡量event time进度的机制叫做水印</p></div><p class="readmore"><a href="/2020/06/25/Flink%E6%97%B6%E9%97%B4/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/20/arthas/">使用arthas分析presto宕机原因</a></h1><div class="post-meta">2020-06-20</div><div class="post-content"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Presto半夜总是宕机</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>使用arthas分析jvm使用情况</p></div><p class="readmore"><a href="/2020/06/20/arthas/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/18/mysql%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/">mysql迁移数据目录解决磁盘不足问题</a></h1><div class="post-meta">2020-06-18</div><div class="post-content"><p>先关闭mysql数据库</p>
<p>mv &#x2F;var&#x2F;lib&#x2F;mysql &#x2F;data&#x2F;mysql_data</p></div><p class="readmore"><a href="/2020/06/18/mysql%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/17/%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">算法-相交链表</a></h1><div class="post-meta">2020-06-17</div><div class="post-content"><p> 编写一个程序，找到两个单链表相交的起始节点。 </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针</p>
<p>因为两个链表长度可能不一样，但是相交后的元素都是一样的，可以使用快慢指针</p>
<p>***** 分别遍历链表，获取其长度，长链表命名为quickNode，短链表命名为slowNode，二者长度差为quickStep</p>
<p>***** quickNode先运行quickStep步之后，此时两个链表长度相等，用一个循环就能找到相同起始节点</p></div><p class="readmore"><a href="/2020/06/17/%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/15/inode%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/">inode磁盘清理</a></h1><div class="post-meta">2020-06-15</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/15/inode%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/15/%E5%BB%BA%E8%90%BD%E5%9C%B0%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%86%99%E5%85%A5%E5%BE%88%E6%85%A2%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">建落地临时表写入很慢导致异常的解决方法</a></h1><div class="post-meta">2020-06-15</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/15/%E5%BB%BA%E8%90%BD%E5%9C%B0%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%86%99%E5%85%A5%E5%BE%88%E6%85%A2%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/15/%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8F%90%E4%BA%A4%E5%88%B0%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84hiveserver2/">beeline请求被提交到已经删除的hiveserver2节点</a></h1><div class="post-meta">2020-06-15</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/15/%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8F%90%E4%BA%A4%E5%88%B0%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84hiveserver2/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/14/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">leetcode 2.两数相加</a></h1><div class="post-meta">2020-06-14</div><div class="post-content"><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h1><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2020/06/14/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/Ambari%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/">Ambari集群安装</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/Ambari%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/Docker%E5%AE%89%E8%A3%85superset/">Docker安装superset</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/Docker%E5%AE%89%E8%A3%85superset/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/Hue%E9%85%8D%E7%BD%AEPresto/">Hue配置Presto</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/Hue%E9%85%8D%E7%BD%AEPresto/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/JVM%E7%AE%97%E6%B3%95/">JVM垃圾回收算法与收集器</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/JVM%E7%AE%97%E6%B3%95/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/Linux%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BAparted%E5%91%BD%E4%BB%A4/">Linux挂载分区parted命令</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/Linux%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BAparted%E5%91%BD%E4%BB%A4/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/Presto%E5%AF%BC%E5%87%BA%E5%88%B0csv/">Presto导出到csv</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/Presto%E5%AF%BC%E5%87%BA%E5%88%B0csv/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/spark-submit%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0jars/">spark-submit时候添加jars</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/spark-submit%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0jars/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/%E4%BD%BF%E7%94%A8Macpro%E5%88%9B%E5%BB%BAcentos7%E5%90%AF%E5%8A%A8%E7%9B%98/">使用Macpro创建centos7启动盘</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/%E4%BD%BF%E7%94%A8Macpro%E5%88%9B%E5%BB%BAcentos7%E5%90%AF%E5%8A%A8%E7%9B%98/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2020/06/03/%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85flink%EF%BC%8C%E9%80%82%E9%85%8Dhdp%E7%89%88%E6%9C%AChadoop/">手动编译安装flink，适配ambari hdp版本hadoop</a></h1><div class="post-meta">2020-06-03</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2020/06/03/%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85flink%EF%BC%8C%E9%80%82%E9%85%8Dhdp%E7%89%88%E6%9C%AChadoop/">Read More</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/06/15/ambari%E9%9B%86%E7%BE%A4datanode%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98/">ambari集群datanode出现OOM问题</a></h1><div class="post-meta">2012-06-15</div><div class="post-content"><p>文章内容</p></div><p class="readmore"><a href="/2012/06/15/ambari%E9%9B%86%E7%BE%A4datanode%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98/">Read More</a></p></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yinxs2003.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/avatar.png"/></a><p></p></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 15px;">大数据</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/%E6%8A%80%E6%9C%AFJava/" style="font-size: 15px;">技术Java</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E6%A6%82%E5%BF%B5/" style="font-size: 15px;">概念</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/06/05/Java-%E9%9B%B6%E6%8B%B7%E8%B4%9D/">Java-零拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/17/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D-CPU%E9%A3%99%E5%8D%87/">问题定位-CPU飙升</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/09/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java-线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/07/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2/">Spring-Bean的生命周期（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1/">Spring-Bean的生命周期（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/">Ubuntu mysql5.7 安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/">Java-自定义注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java-虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/">多线程-Condition</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/">Java-HotSpot虚拟机创建对象</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://heqiao2010.github.io/" title="heqiao2010" target="_blank">heqiao2010</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">工作随笔.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>