<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring_Bean的生命周期</title>
      <link href="/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/05/06/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="/../resources/Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%A6%82%E8%BF%B0%EF%BC%9ABean%E5%AE%9A%E4%B9%89%E5%92%8CBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.svg" alt="概述：Bean定义和Bean的生命周期"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu mysql5.7 安装</title>
      <link href="/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/"/>
      <url>/2023/05/01/Linux-Ubuntu%E5%AE%89%E8%A3%85mysql5.7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql-apt-config_0.8.10-1_all.deb</span><br><span class="line">sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb</span><br><span class="line">sudo dpkg-reconfigure mysql-apt-config</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt-cache policy mysql-server</span><br><span class="line"></span><br><span class="line">sudo apt install -f mysql-client=5.7.30-1ubuntu18.04</span><br><span class="line">sudo apt install -f mysql-community-server=5.7.30-1ubuntu18.04</span><br><span class="line">sudo apt install -f mysql-server=5.7.30-1ubuntu18.04</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-虚拟机</title>
      <link href="/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/04/27/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Java虚拟机内存区域"><a href="#一-Java虚拟机内存区域" class="headerlink" title="一. Java虚拟机内存区域"></a>一. Java虚拟机内存区域</h2><h3 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h3><p>   <img src="/resources/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="java运行时数据区"></p><h3 id="2-程序计数器-Program-Counter-Register"><a href="#2-程序计数器-Program-Counter-Register" class="headerlink" title="2. 程序计数器(Program Counter Register)"></a>2. 程序计数器(Program Counter Register)</h3><ul><li>1、程序计数器是线程内(每个线程都有唯一的、封闭的)一小块内存区域</li><li>2、计数器指定的是当前虚拟机执行指令的地址</li><li>3、当虚拟机执行的是Native方法时,计数器值为空(Undefined),此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError<br>   情况的区域.</li></ul><h3 id="3-Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#3-Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="3. Java虚拟机栈(Java Virtual Machine Stacks)"></a>3. Java虚拟机栈(Java Virtual Machine Stacks)</h3><ul><li>1、虚拟机栈是线程内部的、封闭的</li><li>2、虚拟机栈描述的是java方法执行的内存模型</li><li>3、每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、 操作数栈、 动态链接、 方法出口等信息</li><li>4、java方法的执行就是入栈与出栈的过程</li><li>5、如果虚拟机栈深度超出了虚拟机允许深度将会抛出StackOverflowError异常,现代虚拟机大多数支持动态扩展(也允许固定长度),当虚拟机申<br>   请扩展时申请不到足够的内存时,将会抛出OutOfMemoryError异常</li></ul><h3 id="4-本地方法栈-Native-Method-Stack"><a href="#4-本地方法栈-Native-Method-Stack" class="headerlink" title="4. 本地方法栈(Native Method Stack)"></a>4. 本地方法栈(Native Method Stack)</h3><ul><li>1、为虚拟机调用本地Native方法提供服务</li><li>2、也有虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一</li><li>3、也会抛出StackOverflowError异常和OutOfMemoryError异常</li></ul><h3 id="5-Java堆-Java-Heap-GC堆"><a href="#5-Java堆-Java-Heap-GC堆" class="headerlink" title="5. Java堆(Java Heap) GC堆"></a>5. Java堆(Java Heap) GC堆</h3><ul><li>1、线程共享的最大一块内存区域</li><li>2、此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存,虚拟机规范所有的对象实例与数据都在堆上分配</li><li>3、随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、 标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐<br>   变得不是那么“绝对”了</li></ul><h3 id="6-方法区-Method-Area"><a href="#6-方法区-Method-Area" class="headerlink" title="6. 方法区(Method Area)"></a>6. 方法区(Method Area)</h3><ul><li>1、存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据</li><li>2、这区域的内存回收目标主要是针对常量池的回收和对类型的卸载</li></ul><h3 id="7-运行时常量池-Runtime-Constant-Pool"><a href="#7-运行时常量池-Runtime-Constant-Pool" class="headerlink" title="7. 运行时常量池(Runtime Constant Pool)"></a>7. 运行时常量池(Runtime Constant Pool)</h3><ul><li>1、Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成<br>   的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放</li><li>2、String.intern()也会放入运行时常量池中</li></ul><h3 id="8-直接内存-Direct-Memory"><a href="#8-直接内存-Direct-Memory" class="headerlink" title="8. 直接内存(Direct Memory)"></a>8. 直接内存(Direct Memory)</h3><ul><li>1、NIO的DirectByteBuffer对象使用直接内存,这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据</li></ul><h2 id="二-Java对象"><a href="#二-Java对象" class="headerlink" title="二. Java对象"></a>二. Java对象</h2><h3 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h3><ul><li>1、指针碰撞(Bump the Pointer)</li><li>2、空闲列表(Free List)</li></ul><h3 id="2-对象再内存中的布局"><a href="#2-对象再内存中的布局" class="headerlink" title="2. 对象再内存中的布局"></a>2. 对象再内存中的布局</h3><ul><li>1、分为3块区域:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</li><li>2、对象头包含:轻量级锁定、 重量级锁定、 GC标记、 可偏向</li></ul><h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h3><ul><li>1、句柄访问<br> <img src="/resources/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="句柄访问对象"></li><li>2、直接指针访问<br> <img src="/resources/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" alt="直接指针访问"></li></ul><h2 id="三-垃圾回收与内存分配"><a href="#三-垃圾回收与内存分配" class="headerlink" title="三. 垃圾回收与内存分配"></a>三. 垃圾回收与内存分配</h2><h3 id="1-引用计数法-虚拟机未使用"><a href="#1-引用计数法-虚拟机未使用" class="headerlink" title="1. 引用计数法(虚拟机未使用)"></a>1. 引用计数法(虚拟机未使用)</h3><ul><li>1、互相引用将无法得到正常回收</li></ul><h3 id="2-可达性分析算法-Reachability-Analysis"><a href="#2-可达性分析算法-Reachability-Analysis" class="headerlink" title="2. 可达性分析算法(Reachability Analysis)"></a>2. 可达性分析算法(Reachability Analysis)</h3><ul><li>1、通过GC Root节点向下搜索,搜索走过的路径称为引用链(Reference Chain),当一个对象没有一个引用链经过,则表示该对象是不可用的,可以回收</li><li>2、可作为GC Root对象的有:   <ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象 </li><li>方法区中类静态属性引用的对象  </li><li>方法区中常量引用的对象  </li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul></li></ul><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h3><ul><li>1、强引用(Strong Reference): new 关键字</li><li>2、软引用(Soft Reference):当要发生内存溢出时会将软引用对象加入回收队列中</li><li>3、弱引用(Weak Reference):只能活到下次GC前</li><li>4、虚引用(Phantom Reference):幽灵引用或者幻影引用</li></ul><h3 id="4-回收方法区"><a href="#4-回收方法区" class="headerlink" title="4. 回收方法区"></a>4. 回收方法区</h3><ul><li>1、主要回收永久代的废弃的常量和无用的类   </li><li>2、无用的类判定条件:  <ul><li>该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例.</li><li>加载该类的ClassLoader已经被回收.</li><li>该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.</li></ul></li></ul><h2 id="四-垃圾回收算法"><a href="#四-垃圾回收算法" class="headerlink" title="四. 垃圾回收算法"></a>四. 垃圾回收算法</h2><h3 id="1-标记-清除算法-Mark-Sweep"><a href="#1-标记-清除算法-Mark-Sweep" class="headerlink" title="1. 标记-清除算法(Mark-Sweep)"></a>1. 标记-清除算法(Mark-Sweep)</h3><ul><li>1、标记与清除2个过程</li><li>2、标记与清除效率都不高,还可能产生大量空间碎片导致大对象找不到连续可用的空间</li></ul><h3 id="2-复制算法-Copying"><a href="#2-复制算法-Copying" class="headerlink" title="2. 复制算法(Copying)"></a>2. 复制算法(Copying)</h3><ul><li>1、将堆内存分为大小相等的2块,每次只是用其中一块,当一块内存用完时将还活着的对象移动到另一块,然后清理该块内存</li><li>2、消除了内存碎片化,代价是牺牲了一半可用堆内存</li><li>3、商用虚拟机都采用这种,但并不是按1:1来划分空间而是将内存分为一块较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中<br>   一块Survivor.当回收时,将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上,最后清理掉Eden和刚才用过的<br>   Survivor空间. HotSpot虚拟机默认Eden和Survivor的大小比例是8:1,也就是每次新生代中可用内存空间为整个新生代容量的<br>   90%(80%+10%),只有10%的内存会被“浪费”. 当然,98%的对象可回收只是一般场景下的数据,我们没有办法保证每次回收都只有不多于<br>   10%的对象存活,当Survivor空间不够用时,需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion).</li><li>4、当存活率高时将会出现大量的内存复制操作还有可能导致进行分配担保</li></ul><h3 id="3-标记-整理算法-Mark-Compact"><a href="#3-标记-整理算法-Mark-Compact" class="headerlink" title="3. 标记-整理算法(Mark-Compact)"></a>3. 标记-整理算法(Mark-Compact)</h3><ul><li>1、老年代内存,标记可回收对象之后,将存活的对象移向一端,然后清理掉端边界以外的内存</li></ul><h3 id="4-分代收集算法-Generational-Collection"><a href="#4-分代收集算法-Generational-Collection" class="headerlink" title="4. 分代收集算法(Generational Collection)"></a>4. 分代收集算法(Generational Collection)</h3><ul><li>1、将堆内存分为老年代和新生代</li><li>2、老年代对象存活率高,再采用标记-清理或标记-整理算法进行GC</li><li>3、新生代存活率低,采用复制算法将少量的存活对象进行复制操作</li></ul><h2 id="五-HotSpot算法实现"><a href="#五-HotSpot算法实现" class="headerlink" title="五. HotSpot算法实现"></a>五. HotSpot算法实现</h2><h3 id="1-枚举根节点"><a href="#1-枚举根节点" class="headerlink" title="1. 枚举根节点"></a>1. 枚举根节点</h3><p>   - 1、虚拟机内OopMap存有对象引用信息，可以得到GC Root根节点</p><h3 id="2-安全点"><a href="#2-安全点" class="headerlink" title="2. 安全点"></a>2. 安全点</h3><ul><li>1、虚拟机会在如方法调用、 循环跳转、 异常跳转等，所以具有这些功能的指令才会产生Safepoint</li><li>2、中断方式  <ul><li>抢先式中断(基本弃用): 给出中断指令，有线程发现未到达安全点则继续执行至下一个安全点</li><li>主动式中断: 给定一个中断标志，每个线程都会去轮询该标志，为真时中断</li></ul></li></ul><h3 id="3-安全区域"><a href="#3-安全区域" class="headerlink" title="3. 安全区域"></a>3. 安全区域</h3><ul><li>1、安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的</li><li>2、在线程执行到安全区域时首先会标记自己进入安全区域，出安全区域前必须等到枚举根节点或整个GC完成，没有则都等到可以出安全区域信号为止</li></ul><h2 id="六-垃圾回收器"><a href="#六-垃圾回收器" class="headerlink" title="六. 垃圾回收器"></a>六. 垃圾回收器</h2><p>   <img src="/resources/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/hotspot_lajihuishou.png" alt="HotSpot虚拟机垃圾回收器"></p><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h3><ul><li>1、JDK1.3.1之前是虚拟机新生代收集的唯一选择</li><li>2、单线程、Stop The World(STW)、复制算法</li><li>3、Client模式下新生代默认的垃圾收集器</li></ul><h3 id="2-PerNew收集器"><a href="#2-PerNew收集器" class="headerlink" title="2. PerNew收集器"></a>2. PerNew收集器</h3><ul><li>1、Serial收集器的多线程版,其他一样</li><li>2、是许多虚拟机Server模式下新生代的首选收集器</li><li>3、ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器,也可以使用-XX:+UseParNewGC选项来强制指定它</li><li>4、单核下效果不一定比Serial效果好,多核更适合,-XX:ParallelGCThreads参数来限制垃圾收集的线程数</li></ul><h3 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3. Parallel Scavenge收集器"></a>3. Parallel Scavenge收集器</h3><ul><li>1、新生代收集器,采用复制算法,并行的多线程收集器,吞吐量优先   </li><li>2、追求可控的吞吐量, 吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)</li><li>3、控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数.</li></ul><h3 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="4. Serial Old收集器"></a>4. Serial Old收集器</h3><ul><li>1、Serial老年代版本、单线程、标记-整理算法</li><li>2、给Client模式下虚拟机用</li></ul><h3 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h3><ul><li>1、Parallel Scavenge收集器的老年代版本,使用多线程和“标记-整理”算法,JDK1.6开始提供</li></ul><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><ul><li>1、CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器. </li><li>2、标记-清除算法实现  <ul><li>初始标记(CMS initial mark)，有短时的STW</li><li>并发标记(CMS concurrent mark)</li><li>重新标记(CMS remark)，有短时的STW</li><li>并发清除(CMS concurrent sweep)</li></ul></li><li>3、并发收集、 低停顿,Sun公司的一些官方文档中也称之为并发低停顿收集器</li><li>4、-XX：+UseCMSCompactAtFullCollection默认开启，表示CMS进行Full GC的时候开启内存碎片的合并整理，该过程无法并发停顿时间变长</li><li>5、-XX：CMSFullGCsBeforeCompaction表示执行多少次不压缩的Full GC后跟着来一次压缩的Full GC，默认是0，每次都压缩</li></ul><h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h3><ul><li>1、G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一,面向服务端应用 </li><li>2、特点: <ul><li>并发与并行:充分利用cpu与多核等硬件优势</li><li>分代收集:</li><li>空间整理:标记-整理算法</li><li>可预测的停顿:将堆内存分为多个区域(Region),还保留有老年代与新生代</li></ul></li><li>3、不计算维护Remembered Set的操作,G1收集器的运作大致可划分为以下几个步骤:  <ul><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ul></li></ul><h3 id="8-垃圾收集器参数"><a href="#8-垃圾收集器参数" class="headerlink" title="8. 垃圾收集器参数"></a>8. 垃圾收集器参数</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">UseSerialGC</td><td align="left">Client模式下默认,使用Serial+Serial Old组合</td></tr><tr><td align="left">UseParNewGC</td><td align="left">ParNew+Serial Old组合</td></tr><tr><td align="left">UseConMarkSweepGC</td><td align="left">ParNew+CMS+Serial Old组合,Serial Old作为CMS失败后备用</td></tr><tr><td align="left">UseParallelGC</td><td align="left">Server模式默认,Parallel Scavenge+Serial Old(PS Mark Sweep)组合</td></tr><tr><td align="left">UseParallelOldGC</td><td align="left">Parallel Scavenge+Parallel Old组合</td></tr><tr><td align="left">UseG1GC</td><td align="left">使用G1</td></tr></tbody></table><h2 id="七-内存分配与回收策略"><a href="#七-内存分配与回收策略" class="headerlink" title="七. 内存分配与回收策略"></a>七. 内存分配与回收策略</h2><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><ul><li>对象优先在Eden新生代分配,内存不足将发生一次Minor GC</li></ul><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><ul><li>-XX:PretenureSizeThreshold参数,令大于这个设置值的对象直接在老年代分配,避免大量内存复制</li></ul><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><ul><li>对象晋升老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold设置,默认15,每次Minor GC对象没死+1</li></ul><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><ul><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等<br>到MaxTenuringThreshold中要求的年龄</li></ul><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><ul><li>Minor GC前先判断老年代可用空间是否大于新生代对象总空间,如果大于则确保安全,如果小于则查看HandlePromotionFailure设置的值是否<br>允许担保失败,若允许则会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行一次Minor<br>GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置不允许冒险,那这时也要改为进行一次Full GC.</li></ul><h3 id="八-Minor-GC、Major-GC与Full-GC"><a href="#八-Minor-GC、Major-GC与Full-GC" class="headerlink" title="八. Minor GC、Major GC与Full GC"></a>八. Minor GC、Major GC与Full GC</h3><ul><li>Minor GC表示新生代GC、Major GC是指老年代GC、Full GC为全部堆内存GC。</li><li>往往他们之间相互影响，相互触发</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-Condition</title>
      <link href="/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/"/>
      <url>/2023/04/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Condition/</url>
      
        <content type="html"><![CDATA[<p>使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，可以替代<code>synchronized</code>进行线程同步。</p><p>但是，<code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用<code>ReentrantLock</code>我们怎么编写<code>wait</code>和<code>notify</code>的功能呢？</p><p>答案是使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p><p>我们仍然以<code>TaskQueue</code>为例，把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class TaskQueue &#123;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    private final Condition condition = lock.newCondition();</span><br><span class="line">    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addTask(String s) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTask() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            return queue.remove();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    // 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用<code>Condition</code>配合<code>Lock</code>，我们可以实现更灵活的线程同步。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Condition</code>可以替代<code>wait</code>和<code>notify</code>；</p><p><code>Condition</code>对象必须从<code>Lock</code>对象获取。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-HotSpot虚拟机创建对象</title>
      <link href="/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/04/24/Java-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java对象的创建"><a href="#Java对象的创建" class="headerlink" title="Java对象的创建"></a>Java对象的创建</h1><p>创建java对象大概归纳为以下步骤</p><ol><li>类加载检查</li><li>为新生对象分配内存</li><li>对类进行初始化操作</li></ol><h2 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1.类加载检查"></a>1.类加载检查</h2><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到<br>一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那<br>必须先执行相应的类加载过程</p><h2 id="2-为新生对象分配内存"><a href="#2-为新生对象分配内存" class="headerlink" title="2.为新生对象分配内存"></a>2.为新生对象分配内存</h2><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The<br>Pointer）</p><h3 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h3><p>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）</p><h4 id="分配内存时线程安全问题"><a href="#分配内存时线程安全问题" class="headerlink" title="分配内存时线程安全问题"></a><em>分配内存时线程安全问题</em></h4><p><em>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象</em><br><em>A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</em></p><ul><li><p><em>采用CAS配上失败重试的方式保证更新操作的原子性</em></p></li><li><p><em>本地线程分配缓冲（Thread Local AllocationBuffer，TLAB）</em></p><p><em>哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定（应该是预留本地内存，只有用完的时候才对内存进行同步锁定，减少锁定内存次数以达到增加并发目的）</em></p></li></ul><h2 id="3-对类进行初始化操作"><a href="#3-对类进行初始化操作" class="headerlink" title="3.对类进行初始化操作"></a>3.对类进行初始化操作</h2><ol><li><p>虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值</p></li><li><p>Java虚拟机还要对对象进行必要的设置</p><p>例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟<br>机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li><li><p>调用类的构造方法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-jvm options</title>
      <link href="/2023/04/24/Java-JVM_Options/"/>
      <url>/2023/04/24/Java-JVM_Options/</url>
      
        <content type="html"><![CDATA[<p>-Xmx10m<br>设置虚拟机最大堆内存</p><p>-Xms10<br>设置虚拟机初始堆内存，可与-Xmx相等避免每次GC重新内存分配</p><p>-Xmn10m<br>设置堆年轻代大小</p><p>-Xss1m<br>设置栈内存</p><p>#出现 OOME 时生成堆 dump:<br>-XX:+HeapDumpOnOutOfMemoryError<br>#生成堆文件地址：<br>-XX:HeapDumpPath&#x3D;&#x2F;temp&#x2F;java.hprof</p><p>-XX:+&#x2F;-UseTLAB<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常<br>频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，<br>可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来<br>分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理<br>——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分<br>配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内<br>存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内<br>存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。<br>虚拟机是否使用TLAB</p><p>JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：<br>-XX:+PrintGC<br>输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs]<br>         [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p><p>-XX:+PrintGCDetails<br>输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>         [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs]<br>         121376K-&gt;10414K(130112K), 0.0436268 secs]</p><p>-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用<br>输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</p><p>-XX:+PrintGCApplicationConcurrentTime:打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用<br>输出形式：Application time: 0.5291524 seconds</p><p>-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用<br>输出形式：Total time for which application threads were stopped: 0.0468229 seconds</p><p>-XX:+PrintHeapAtGC:打印GC前后的详细堆栈信息<br>输出形式：<br>34.702: [GC {Heap before gc invocations&#x3D;7:def new generation   total 55296K, used 52568K [0x1ebd0000,<br>0x227d0000, 0x227d0000)eden space 49152K, 99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)from space 6144K,<br>55% used [0x221d0000, 0x22527e10, 0x227d0000)to   space 6144K,   0% used [0x21bd0000, 0x21bd0000, 0x221d0000)<br>tenured generation   total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)the space 69632K,   3% used<br>[0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)compacting perm gen total 8192K, used 2898K [0x26bd0000,<br>0x273d0000, 0x2abd0000)the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)ro space<br>8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)rw space 12288K, 46% used [0x2b3d0000,<br>0x2b972060, 0x2b972200, 0x2bfd0000)34.735: [DefNew: 52568K-&gt;3433K(55296K), 0.0072126 secs] 55264K-&gt;6615K<br>(124928K)Heap after gc invocations&#x3D;8:def new generation   total 55296K, used 3433K [0x1ebd0000, 0x227d0000,<br> 0x227d0000)eden space 49152K,   0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)from space 6144K, 55% used<br> [0x21bd0000, 0x21f2a5e8, 0x221d0000)to   space 6144K,   0% used [0x221d0000, 0x221d0000, 0x227d0000)<br>tenured generation   total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)the space 69632K,   4%<br>used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)compacting perm gen total 8192K, used 2898K [0x26bd0000,<br> 0x273d0000, 0x2abd0000)the space 8192K, 35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)ro space<br>  8192K, 66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)rw space 12288K, 46% used [0x2b3d0000,<br>  0x2b972060,0x2b972200, 0x2bfd0000)}, 0.0757599 secs]</p><p>-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析。</p><p>-XX:+UseCompressedOops: 指针压缩<br>• 每个Class的属性指针（静态成员变量）<br>• 每个对象的属性指针<br>• 普通对象数组的每个元素指针<br>指向PermGen的Class对象指针，本地变量，堆栈元素，入参，返回值，NULL指针不会被压缩。</p><p>-XX：+TraceClassLoading<br>打印虚拟机类加载情况</p><p>-XX：-UseSplitVerifier<br>-XX：+FailOverToOldVerifier</p><p>-Xverify:none<br>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>-XX:CompileThreshold<br>设置方法调用次数计数器阈值，以判定是否为热点方法</p><p>-XX:-UseCounterDecay<br>设置关闭热度衰减</p><p>-XX:CounterHalfLifeTime<br>参数设置半衰周期的时间，单位是秒</p><p>-XX:-BackgroundCompilation<br>禁止后台编译，在禁止后台编译后，一旦达到JIT的编译条件，执行线程向虚拟机提交编译请求后将会一直等待，<br>直到编译过程完成后再开始执行编译器输出的本地代码</p><p>-XX：+DoEscapeAnalysis来手动开启逃逸分析，开启之后可以通过参数-XX：+PrintEscapeAnalysis来查看分析结果。<br>有了逃逸分析支持之后，用户可以使用参数-XX：+EliminateAllocations来开启标量替换，使用+XX：+EliminateLocks来开启同步消除，<br>使用参数-XX：+PrintEliminateAllocations查看标量的替换情况。</p><p>-XX：MaxDirectMemorySize<br>DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-内存模型</title>
      <link href="/2023/04/24/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/04/24/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1. 内存模型"></a>1. 内存模型</h2><p> <img src="/resources/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="内存模型"></p><h2 id="2-内存间的交互操作"><a href="#2-内存间的交互操作" class="headerlink" title="2. 内存间的交互操作"></a>2. 内存间的交互操作</h2><h3 id="2-1-定义操作"><a href="#2-1-定义操作" class="headerlink" title="2.1. 定义操作"></a>2.1. 定义操作</h3><ul><li>lock(锁定)：作用于主内存的变量,它把一个变量标识为一条线程独占的状态.</li><li>unlock(解锁)：作用于主内存的变量,它把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定.</li><li>read(读取)：作用于主内存的变量,它把一个变量的值从主内存传输到线程的工作内存中,以便随后的load动作使用.</li><li>load(载入)：作用于工作内存的变量,它把read操作从主内存中得到的变量值放入工作内存的变量副本中.</li><li>use(使用)：作用于工作内存的变量,它把工作内存中一个变量的值传递给执行引擎,每当虚拟机遇到一个需要使用到<br>变量的值的字节码指令时将会执行这个操作.</li><li>assign(赋值)：作用于工作内存的变量,它把一个从执行引擎接收到的值赋给工作内存的变量,每当虚拟机遇到一个<br>给变量赋值的字节码指令时执行这个操作.</li><li>store(存储)：作用于工作内存的变量,它把工作内存中一个变量的值传送到主内存中,以便随后的write操作使用.</li><li>write(写入)：作用于主内存的变量,它把store操作从工作内存中得到的变量的值放入主内存的变量中.</li></ul><h3 id="2-2-约束条件"><a href="#2-2-约束条件" class="headerlink" title="2.2. 约束条件"></a>2.2. 约束条件</h3><ol><li>read和load、store和write必须保证顺序操作,不能单独出现,但不需要连续操作,中间可隔有其他操作</li><li>不允许一个线程丢弃它的最近的assign操作,即变量在工作内存中改变了之后必须把该变化同步回主内存.</li><li>不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中.</li><li>一个新的变量只能在主内存中“诞生”,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量,换句话说,<br>就是对一个变量实施use、 store操作之前,必须先执行过了assign和load操作.</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作,但lock操作可以被同一条线程重复执行多次,多次执行lock后,<br>只有执行相同次数的unlock操作,变量才会被解锁</li><li>如果对一个变量执行lock操作,那将会清空工作内存中此变量的值,在执行引擎使用这个变量前,<br>需要重新执行load或assign操作初始化变量的值.</li><li>如果一个变量事先没有被lock操作锁定,那就不允许对它执行unlock操作,也不允许去unlock一个被其他线程锁定住的变量.</li><li>对一个变量执行unlock操作之前,必须先把此变量同步回主内存中(执行store、 write操作)</li></ol><h3 id="2-3-volatile"><a href="#2-3-volatile" class="headerlink" title="2.3. volatile"></a>2.3. volatile</h3><p>   &amp;emsp;&amp;emsp;假定T表示一个线程,V和W分别表示两个volatile型变量,那么在进行read、 load、 use、 assign、store和write操作时<br>   需要满足如下规则:<br>   &amp;emsp;&amp;emsp;只有当线程T对变量V执行的前一个动作是load的时候,线程T才能对变量V执行use动作;并且,只有当线程T对变量V执行的后一个动作是use<br>   的时候,线程T才能对变量V执行load动作. 线程T对变量V的use动作可以认为是和线程T对变量V的load、 read动作相关联,必须连续一起出现<br>   (这条规则要求在工作内存中,每次使用V前都必须先从主内存刷新最新的值,用于保证能看见其他线程对变量V所做的修改后的值).<br>   &amp;emsp;&amp;emsp;只有当线程T对变量V执行的前一个动作是assign的时候,线程T才能对变量V执行store动作;并且,只有当线程T对变量V执行的后一个动作<br>   是store的时候,线程T才能对变量V执行assign动作. 线程T对变量V的assign动作可以认为是和线程T对变量V的store、 write动作相关<br>   联,必须连续一起出现(这条规则要求在工作内存中,每次修改V后都必须立刻同步回主内存中,用于保证其他线程可以看到自己对变量V所做的修改)<br>   &amp;emsp;&amp;emsp;假定动作A是线程T对变量V实施的use或assign动作,假定动作F是和动作A相关联的load或store动作,假定动作P是和动作F相应的对变量V<br>   的read或write动作;类似的,假定动作B是线程T对变量W实施的use或assign动作,假定动作G是和动作B相关联的load或store动作,假定动作<br>   Q是和动作G相应的对变量W的read或write动作. 如果A先于B,那么P先于Q(这条规则要求volatile修饰的变量不会被指令重排序优化,保证代<br>   码的执行顺序与程序的顺序相同).<br>   &amp;emsp;&amp;emsp;volatile不仅保证了共享变量的可见性，还通过内存屏障保证了代码执行顺序与程序顺序相同，通过内存屏障来使变量不被指令重排优化</p><h3 id="2-4-long和double的非原子性协定"><a href="#2-4-long和double的非原子性协定" class="headerlink" title="2.4. long和double的非原子性协定"></a>2.4. long和double的非原子性协定</h3><p>  &amp;emsp;&amp;emsp;读写操作可分为2次32位操作,所以一定不是原子操作<br>  <strong><em>注：现在商用虚拟机本身几乎都已经实现了原子操作,所以不用volatile修饰符</em></strong></p><h3 id="2-5-原子性"><a href="#2-5-原子性" class="headerlink" title="2.5 原子性"></a>2.5 原子性</h3><p>  变量操作的read、load、use、assign、store、write不保证了原子性<br>  通过synchronized对lock、unlock操作也保证了原子性</p><h3 id="2-6-可见性"><a href="#2-6-可见性" class="headerlink" title="2.6 可见性"></a>2.6 可见性</h3><p>  volatile保证在读取共享变量之前去主内存刷最新值，还保证了最新值能及时同步至主内存</p><h3 id="2-7-有序性"><a href="#2-7-有序性" class="headerlink" title="2.7 有序性"></a>2.7 有序性</h3><p>  在本线程内观察所有操作都是有序的，在另一个线程观察所有操作都是无序的</p><h3 id="2-8-先发性"><a href="#2-8-先发性" class="headerlink" title="2.8 先发性"></a>2.8 先发性</h3><p>  先发生的线程对修改了共享变量的值、发送了消息或调用了方法会被后发生的线程所观察到  </p><h3 id="2-9-先行发生-happens-before-规则"><a href="#2-9-先行发生-happens-before-规则" class="headerlink" title="2.9 先行发生(happens-before)规则"></a>2.9 先行发生(happens-before)规则</h3><p>  《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。 </p><ul><li>1、程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li>2、监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>3、volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>4、传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li>5、start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li>6、join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><h2 id="3-常见比较"><a href="#3-常见比较" class="headerlink" title="3. 常见比较"></a>3. 常见比较</h2><h3 id="3-1-volatile与synchronized比较"><a href="#3-1-volatile与synchronized比较" class="headerlink" title="3.1 volatile与synchronized比较"></a>3.1 volatile与synchronized比较</h3><ul><li>1、被volatile描述的共享变量通过内存屏障是代码不被指令重排优化，从而保证了共享变量在线程间的可见性，更新变量时会及时<br>的将最新值同步至主内存，读变量时会及时的去主内存获取最新值，volatile只能修饰变量，只保证可见性，不保证原子性，不能用来<br>同步。</li><li>2、synchronized是通过对象头的锁标志位来实现加锁与释放锁，不仅保证可见性，还保证了原子性，只有获得了对象锁的线程才能<br>进入临界区，其他线程会阻塞等待锁释放后再争抢锁。</li></ul><h3 id="3-2-Lock-ReentrantLock-与synchronized比较"><a href="#3-2-Lock-ReentrantLock-与synchronized比较" class="headerlink" title="3.2 Lock(ReentrantLock)与synchronized比较"></a>3.2 Lock(ReentrantLock)与synchronized比较</h3><ul><li>1、synchronized是JAVA关键字，Lock是一个java接口，ReentrantLock实现了该接口</li><li>2、Lock锁需要在finally{}代码里手动释放，synchronized会自动释放锁</li><li>3、Lock根据实现不同有多种锁类型，如公平锁、非公平锁(默认非公平锁)</li><li>4、性能方面，在锁竞争很大的情况下Lock性能更优于synchronized</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-多线程实现</title>
      <link href="/2023/04/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/04/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JAVA与线程"><a href="#1-JAVA与线程" class="headerlink" title="1. JAVA与线程"></a>1. JAVA与线程</h2><h3 id="1-1-线程的实现"><a href="#1-1-线程的实现" class="headerlink" title="1.1 线程的实现"></a>1.1 线程的实现</h3><ol><li>实现方式:使用内核线程实现、 使用用户线程实现和使用用户线程加轻量级进程混合实现.</li><li>JDK1.2之前是基于用户线程实现的，JDK1.2及以后是基于操作系统原生线程模型实现的.</li></ol><h3 id="1-2-Java线程调度"><a href="#1-2-Java线程调度" class="headerlink" title="1.2 Java线程调度"></a>1.2 Java线程调度</h3><ol><li>线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协同式线程调度(Cooperative Threads-Scheduling)<br>和抢占式线程调度(Preemptive ThreadsScheduling)</li><li>协同式线程调度:线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上;<br>优点是实现简单,缺点是线程执行时间不可控制,容易线程阻塞</li><li>每个线程将由系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时<br>间的话,线程本身是没有什么办法的);优点是线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题.</li><li>JAVA线程有10个优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY)</li></ol><h3 id="1-3-线程转换状态"><a href="#1-3-线程转换状态" class="headerlink" title="1.3 线程转换状态"></a>1.3 线程转换状态</h3><ol><li>JAVA线程定义了6个状态:  <ul><li>新建(New):创建后尚未启动的线程处于这种状态.</li><li>运行(Runable):Runable包括了操作系统线程状态中的Running和Ready,也就是处于此状态的线程有可能正在执行,也有可能正在<br>等待着CPU为它分配执行时间.</li><li>无限期等待(Waiting):处于这种状态的线程不会被分配CPU执行时间,它们要等待被<br>其他线程显式地唤醒. 以下方法会让线程陷入无限期的等待状态:<br>●没有设置Timeout参数的Object.wait()方法.<br>●没有设置Timeout参数的Thread.join()方法.<br>●LockSupport.park()方法.  </li><li>限期等待(Timed Waiting):处于这种状态的线程也不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后<br>它们会由系统自动唤醒. 以下方法会让线程进入限期等待状态:<br>●Thread.sleep()方法.<br>●设置了Timeout参数的Object.wait()方法.<br>●设置了Timeout参数的Thread.join()方法.<br>●LockSupport.parkNanos()方法.<br>●LockSupport.parkUntil()方法 </li><li>阻塞(Blocked):该状态程序在等待获取一个排他锁，程序在同步时会在该状态 </li><li>结束(Terminated):已终止线程的线程状态,线程已经结束执行.</li></ul></li><li>线程状态转换关系图<br><img src="/resources/JVM%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" alt="线程状态转换关系"></li></ol><h2 id="2-线程安全与锁优化"><a href="#2-线程安全与锁优化" class="headerlink" title="2. 线程安全与锁优化"></a>2. 线程安全与锁优化</h2><h3 id="2-1-JAVA中的线程安全"><a href="#2-1-JAVA中的线程安全" class="headerlink" title="2.1 JAVA中的线程安全"></a>2.1 JAVA中的线程安全</h3><ol><li>共享数据分类<ul><li>不可变(Immutable):不可变对象一定是线程安全的,典型的final</li><li>绝对线程安全:</li><li>相对线程安全: java大部分的线程安全都是相对线程安全的</li><li>线程兼容:</li><li>线程对立:</li></ul></li></ol><h3 id="2-2-synchronized的优化"><a href="#2-2-synchronized的优化" class="headerlink" title="2.2 synchronized的优化"></a>2.2 synchronized的优化</h3><ol><li>synchronized自JDK1.6后引入偏向锁和轻量级锁后大大提升了并发的性能</li><li>synchronized锁升级<code>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</code> 所以在锁高竞争下Lock性能更高</li></ol><h2 id="3-锁介绍"><a href="#3-锁介绍" class="headerlink" title="3. 锁介绍"></a>3. 锁介绍</h2><h3 id="3-1-自旋锁"><a href="#3-1-自旋锁" class="headerlink" title="3.1 自旋锁"></a>3.1 自旋锁</h3><ol><li><p>自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。</p><p>使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。</p><p>在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。  </p></li><li><p>问题：  </p><ul><li>可能白占用CPU时间</li><li>死锁问题，自己占用锁，还在等待锁释放</li></ul></li></ol><h3 id="3-2-阻塞锁"><a href="#3-2-阻塞锁" class="headerlink" title="3.2 阻塞锁"></a>3.2 阻塞锁</h3><pre><code>  1. 让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify() </code></pre><h3 id="3-3-可重入锁"><a href="#3-3-可重入锁" class="headerlink" title="3.3 可重入锁"></a>3.3 可重入锁</h3><ol><li><p>可重入锁是一种能够让同一个线程多次获取同一把锁的锁，也就是说，如果一个线程已经持有了某个锁，那么它可以再次请求这个锁而不会被阻塞或者产生死锁。可重入锁可以降低编程的复杂性，避免一些潜在的错误，提高并发性能。</p></li><li><p>可重入锁的实现原理是为每个锁增加一个请求计数器和一个持有者线程的变量。</p><ul><li>当计数器为0时，表示该锁没有被任何线程持有，此时任何线程都可以请求这个锁，如果成功获取，将会把计数器设为1，同时记录持有者为当前线程。</li><li>当同一个线程再次请求这个锁时，计数器会递增，而不会进行阻塞或者竞争；</li><li>当持有者释放这个锁时，计数器会递减</li><li>如果计数器为0，则表示该锁已经完全释放，此时其他线程可以竞争获取该锁。</li></ul><p>JAVA环境下 ReentrantLock 和synchronized 都是可重入锁</p></li></ol><h3 id="3-4-乐观锁和悲观锁"><a href="#3-4-乐观锁和悲观锁" class="headerlink" title="3.4 乐观锁和悲观锁"></a>3.4 乐观锁和悲观锁</h3><ol><li>悲观锁: 每次拿数据都上锁，如行锁、表锁、读锁、写锁</li><li>乐观锁: 每次拿数据都不上锁，只是在修改前验证下数据在此期间有无更新，如版本号控制</li></ol><h3 id="3-5-轮询锁和定时锁"><a href="#3-5-轮询锁和定时锁" class="headerlink" title="3.5 轮询锁和定时锁"></a>3.5 轮询锁和定时锁</h3><ol><li>由tryLock实现，与无条件获取锁模式相比，它们具有更完善的错误恢复机制。可避免死锁的发生：<br>boolean tryLock()：仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 true。<br>如果锁不可用，则此方法将立即返回值 false。<br>boolean tryLock(long time, TimeUnit unit) throws InterruptedException：<br>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</li></ol><h3 id="3-6-显示锁和内置锁"><a href="#3-6-显示锁和内置锁" class="headerlink" title="3.6 显示锁和内置锁"></a>3.6 显示锁和内置锁</h3><ol><li>显示锁用Lock来定义、内置锁用synchronized。</li></ol><h3 id="3-7-对象锁和类锁"><a href="#3-7-对象锁和类锁" class="headerlink" title="3.7 对象锁和类锁"></a>3.7 对象锁和类锁</h3><ol><li>对象锁是用于实例对象(可有多个实例对象)方法上的</li><li>类锁是作用于对象的静态方法和Class(一个类只有一个Class对象)对象上的</li></ol><h3 id="3-8-互斥锁"><a href="#3-8-互斥锁" class="headerlink" title="3.8 互斥锁"></a>3.8 互斥锁</h3><ol><li>互斥锁, 指的是一次最多只能有一个线程持有的锁。如Java的Lock</li></ol><h3 id="3-9-锁粗化"><a href="#3-9-锁粗化" class="headerlink" title="3.9 锁粗化"></a>3.9 锁粗化</h3><ol><li>将多个连续的锁操作合并成一个整体的锁</li></ol><h3 id="3-10-锁消除"><a href="#3-10-锁消除" class="headerlink" title="3.10 锁消除"></a>3.10 锁消除</h3><ol><li>通过逃逸分析，能证明堆上数据不会逃逸出当前线程，则认为是线程安全的，不必要加锁操作</li></ol><h2 id="4-java线程池"><a href="#4-java线程池" class="headerlink" title="4. java线程池"></a>4. java线程池</h2><h3 id="4-1-线程池实现类"><a href="#4-1-线程池实现类" class="headerlink" title="4.1 线程池实现类"></a>4.1 线程池实现类</h3>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(C)ThreadPoolExecutor ---&gt;  (AC)AbstractExecutorService ---&gt; (I)ExecutorService ---&gt; (I)Executor</span><br></pre></td></tr></table></figure><h3 id="4-2-ThreadPoolExecutor构造参数说明"><a href="#4-2-ThreadPoolExecutor构造参数说明" class="headerlink" title="4.2 ThreadPoolExecutor构造参数说明"></a>4.2 ThreadPoolExecutor构造参数说明</h3><p>handler 表示拒接处理任务的策略有一下4种：</p><ul><li><p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常</p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，此时该任务会阻塞主线程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># corePoolSize 核心线程数，当任务多于核心线程数时会进入缓冲阻塞队列workQueue</span><br><span class="line"># maximunPoolSize 线程池最大线程数</span><br><span class="line"># keepAliveTime 多于核心线程数的空闲线程最长存活时间量级与unit参数配合使用</span><br><span class="line"># unit 线程等待时间的单位级</span><br><span class="line"># workQueue 任务缓冲队列</span><br><span class="line"># threadFactory 线程工厂，用于创建线程</span><br><span class="line"># handler 表示拒接处理任务的策略有一下4种：</span><br><span class="line">#  - ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常</span><br><span class="line">#  - ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常</span><br><span class="line">#  - ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">#  - ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br><span class="line"></span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue);</span><br><span class="line">     </span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</span><br><span class="line">     </span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</span><br><span class="line">     </span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-实现原理"><a href="#4-3-实现原理" class="headerlink" title="4.3 实现原理"></a>4.3 实现原理</h3><ol><li>线程池状态：</li></ol><ul><li>RUNNING: 线程池初始化时就是RUNNING状态，表示线程池能够接受任务并处理，并且线程池中线程数默认为0(可以通过调用方法<br> <code>prestartAllCoreThreads() #创建核心线程</code>或者<code>prestartCoreThread() #创建一个核心线程</code>来初始化线程数)</li><li>SHUTDOWN: 线程处于SHUTDOWN状态时,不接收新任务,但能处理已添加的任务;状态切换调用<code>shutdown()</code>时从<code>RUNNING-&gt; SHUTDOWN</code></li><li>STOP: 线程处于STOP状态时，不接收新任务，不处理已添加任务，并会终止正在执行的任务;状态切换调用<code>shutdownNow()</code>时从<br><code>RUNNING or SHUTDOWN -&gt; STOP</code></li><li>TIDYING: 当所有任务已终止，任务数量为0时，线程池会进入TIDYING状态，并且会执行钩子函数<code>terminated()</code>，用户可重载该方法<br>实现自己的业务逻辑;状态切换是所有任务终止就进入TIDYING状态</li><li>TERMINATED: 线程池彻底终止状态;状态切换是TIDYING的钩子函数执行完毕后进入TERMINATED状态</li></ul><ol start="2"><li>任务执行过程</li></ol><ul><li>当任务提交给线程池时，线程首先判断当前池内线程数是否大于corePoolSize(核心线程数)，如果小于这值就会创建一个新的线程来执行该任务；</li><li>当线程数大于核心线程数时，则会尝试将任务放入缓冲队列(workQueue)内，若添加成功，则该任务会被等待的空闲线程取去执行，若添加失败，<br>则会尝试创建新的线程去执行该任务；</li><li>如果线程池内线程数达到了maximumPoolSize(最大线程数)时，则会采取handler(拒绝策略)处理</li><li>如果线程池内的线程数大于corePoolSize时，当线程空闲超时keepAliveTime时，线程将被终止，直到线程数等于corePoolSize；如果允许核心<br>线程数也有超时时间，则当核心线程数内的线程超时时也会被终止，直至线程数为0</li></ul><ol start="3"><li>线程池中的线程初始化</li></ol><ul><li>prestartCoreThread()：初始化一个核心线程</li><li>prestartAllCoreThreads()：初始化所有核心线程</li><li>初始化后线程会执行workQueue的<code>take()</code>方法，该方法是阻塞的，直到有任务提交</li></ul><ol start="4"><li>任务缓存队列及排队策略</li></ol><ul><li>ArrayBlockingQueue：基于数组的FIFO阻塞队列,必须有最大容量的参数</li><li>LinkedBlockingQueue: 基于链表的FIFO阻塞队列,容量动态扩展</li><li>SynchronousQueue: 该队列不保存提交的任务，而是直接新建队列来执行任务</li></ul><ol start="5"><li><p>任务拒绝策略</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></li><li><p>线程池的关闭</p></li></ol><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 </li><li>shutdownNow(): 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li></ul><ol start="7"><li>线程池容量动态调整</li></ol><ul><li>setCorePoolSize()：设置核心池大小</li><li>setMaximumPoolSize()：设置线程池最大能创建的线程数目大小</li></ul><h3 id="4-4-Executors"><a href="#4-4-Executors" class="headerlink" title="4.4 Executors"></a>4.4 Executors</h3><ul><li>newFixedThreadPool: 定容量的线程池，核心线程数与最大线程数相等</li><li>newSingleThreadExecutor: 单线程线程池，线程池内核心线程数与最大线程数为1</li><li>newCachedThreadPool: 无线大小线程池，核心线程数为0，最大线程数为<code>Integer.MAX_VALUE</code>, 缓冲队列为<code>SynchronousQueue</code></li><li>newScheduledThreadPool：创建一个ScheduledThreadPoolExecutor定时执行线程池,最大线程数为<code>Integer.MAX_VALUE</code>,内部是<br>一个DelayedWorkQueue实现</li><li>newSingleThreadScheduledExecutor: 创建一个ScheduledThreadPoolExecutor定时执行线程池,最大线程数为<code>Integer.MAX_VALUE</code>,<br>内部是一个DelayedWorkQueue实现</li></ul><h2 id="5-AbstractQueuedSynchronizer"><a href="#5-AbstractQueuedSynchronizer" class="headerlink" title="5. AbstractQueuedSynchronizer"></a>5. AbstractQueuedSynchronizer</h2><p>   内部类：</p><ul><li>ConditionObject：</li><li>Node：存放线程信息队列</li></ul><h3 id="5-1-AQS之ReentrantLock独占锁源码分析"><a href="#5-1-AQS之ReentrantLock独占锁源码分析" class="headerlink" title="5.1 AQS之ReentrantLock独占锁源码分析"></a>5.1 AQS之ReentrantLock独占锁源码分析</h3><ul><li><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer">AbstractQueuedSynchronizer独占锁</a></li><li><code>ReentrantLock.lock()</code>保证在<code>ReentrantLock.unlock()</code>之间的代码只有一个线程在执行；ReentrantLock为可重入锁，它有一个与<br>锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。</li><li>内部类<code>Syn</code>实现了<code>AbstractQueuedSynchronizer</code>接口</li><li>构造方法有公平锁和非公平锁，公平锁与非公平锁的区别在于公平锁在尝试获取锁时会放入等待队列的后面，获取锁的顺序是按先后顺序执行的，<br>而非公平锁在尝试获取锁时首先会去尝试获取锁，若获取失败在进入等待队列按顺序执行。</li></ul><h3 id="5-2-AQS之CountDownLatch共享锁源码分析"><a href="#5-2-AQS之CountDownLatch共享锁源码分析" class="headerlink" title="5.2 AQS之CountDownLatch共享锁源码分析"></a>5.2 AQS之CountDownLatch共享锁源码分析</h3><ul><li><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer">AbstractQueuedSynchronizer共享锁</a></li><li><code>CountDownLatch.countDown()</code>实现锁计数-1，直到减至0是，唤醒<code>CountDownLatch.await()</code>等待线程</li></ul><h3 id="5-3-公平锁和非公平锁"><a href="#5-3-公平锁和非公平锁" class="headerlink" title="5.3 公平锁和非公平锁"></a>5.3 公平锁和非公平锁</h3><p>   公平锁是严格按照FIFO队列获得锁，但带来了大量的线程切换的消耗，非公平锁极大的降低了线程切换带来的消耗，虽然可能造成线程饥饿的情况，<br>   但也提高了吞吐量。</p><h2 id="6-synchronized与Lock比较"><a href="#6-synchronized与Lock比较" class="headerlink" title="6. synchronized与Lock比较"></a>6. <code>synchronized</code>与<code>Lock</code>比较</h2><ol><li><code>synchronized</code>是JVM层面实现的’重量级锁’，可通过监控工具监控<code>synchronized</code>的锁定，而且代码出现异常时会自动释放锁</li><li><code>Lock</code>是纯JAVA实现的，为多种实现留下空间，可以实现不同的调度算法、性能特性或者锁定语义，<code>Lock</code>必须自己手动的释放锁<br>形如<code>finally&#123;lock.unlock();&#125;</code></li><li>当锁竞争激烈时用<code>Lock</code>,锁竞争较弱时用<code>synchronized</code></li></ol><h2 id="7-阻塞队列BlockingQueue"><a href="#7-阻塞队列BlockingQueue" class="headerlink" title="7. 阻塞队列BlockingQueue"></a>7. 阻塞队列<code>BlockingQueue</code></h2><ol><li>阻塞队列是一个FIFO队列</li><li>主要方法</li></ol><table><thead><tr><th align="center">Ops</th><th align="center">Throws Exception</th><th align="center">Special Value</th><th align="center">Blocks Times Out</th></tr></thead><tbody><tr><td align="center">Insert</td><td align="center">add(o)</td><td align="center">offer(o)</td><td align="center">put(o) &amp; offer(o, timeout, timeUnit)</td></tr><tr><td align="center">Remove</td><td align="center">remove(o)</td><td align="center">poll()</td><td align="center">take()&amp; poll(timeout, timeUnit)</td></tr><tr><td align="center">Examine</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td></tr></tbody></table><ol start="3"><li>主要实现</li></ol><ul><li>ArrayBlockingQueue：基于数组的有界阻塞队列，必须指定长度</li><li>LinkedBlockingQueue: 基于链表的有界阻塞队列，长度可指定也可动态扩张，默认长度为<code>Integer.MAX_VALUE</code></li><li>SynchronousQueue: 无缓冲区的阻塞队列，<code>put()</code>要阻塞等待<code>take()</code></li><li>PriorityBlockingQueue: 优先级阻塞队列，队列元素必须实现<code>Comparator</code>接口，基于数组，自动扩展长度</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><ol start="4"><li>注意<br>如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。</li></ol><h2 id="8-ConcurrentLinkedQueue"><a href="#8-ConcurrentLinkedQueue" class="headerlink" title="8. ConcurrentLinkedQueue"></a>8. ConcurrentLinkedQueue</h2><p>   非阻塞线程安全的FIFO队列，基于单向链表实现，循环CAS操作实现，由于是根据Node.NEXT是否为NULL来判断是否为TAIL节点，因此<br>   队列的元素值不可为NULL。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Ioc和Aop</title>
      <link href="/2023/04/24/Spring-Ioc%E5%92%8CAop/"/>
      <url>/2023/04/24/Spring-Ioc%E5%92%8CAop/</url>
      
        <content type="html"><![CDATA[<h4 id="IoC、Bean、依赖注入"><a href="#IoC、Bean、依赖注入" class="headerlink" title="IoC、Bean、依赖注入"></a>IoC、Bean、依赖注入</h4><p>IoC是控制反转，含义是把创建对象的操作交给Spring执行</p><p>把创建好的对象放到IoC容器，放到IoC容器的对象叫做Bean。放入IoC容器之前的赋值这个动作叫做依赖注入</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>指的是在执行某个方法这个时刻，会先执行一些预定义好的操作。这个执行过程叫做切面。比较常见的例子是打印日志、Spring的事务</p><p>Bean创建的过程有一个步骤可以对bean进行扩展，aop本身是一个扩展功能。所以在BeanPostProcessor的后置处理方法中来进行实现。</p><p>1.代理对象的创建过程</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-CyclicBarrier</title>
      <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier/"/>
      <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<p>CyclicBarrier是java提供的同步辅助类。<br>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)，才得以继续执行。阻塞子线程，当阻塞数量到达定义的参与线程数后，才可继续向下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarrierMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadPoolExecutor executor=<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>, TimeUnit.SECONDS</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>))&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.afterExecute(r, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        CyclicBarrier cyclicBarrier=<span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=====当前阶段已完成&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">BarrierDemo</span>(cyclicBarrier));</span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">BarrierDemo</span>(cyclicBarrier));</span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">BarrierDemo</span>(cyclicBarrier));</span><br><span class="line">        System.out.println(<span class="string">&quot;====主线程执行完毕&quot;</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarrierDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BarrierDemo</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;到达现场&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="comment">//阻塞子线程</span></span><br><span class="line">            barrier.await();</span><br><span class="line">            <span class="comment">//继续执行</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始表演&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/resources/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CyclicBarrier/623878-20210216210246833-334764710.png" alt="img"></p><p>CountDownLatch与CyclicBarrier:<br>CountDownLatch是一个同步的辅助类，允许一个或多个线程，等待其他一组线程完成操作，被等待线程（例如主线程）再继续执行。<br>CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，达到一个共同点，子线程再继续执行。CyclicBarrier可以被重用，比如有三个线程，执行逻辑到达同步点阻塞，到齐后被唤醒，又再次执行逻辑，到达下一个同步点，到齐后再被唤醒<br>区别:</p><ol><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次</li><li>CyclicBarrier还提供getNumberWaiting(可以获得CyclicBarrier阻塞的线程数量)、isBroken(用来知道阻塞的线程是否被中断)等方法。</li><li>CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-CountDownLatch</title>
      <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CountDownLatch/"/>
      <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-CountDownLatch/</url>
      
        <content type="html"><![CDATA[<p><code>CountDownLatch</code> 是多线程控制的一种工具，它被称为 <code>门阀</code>、 <code>计数器</code>或者 <code>闭锁</code>。这个工具经常用来用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。下面我们就来一起认识一下 CountDownLatch</p><h2 id="认识-CountDownLatch"><a href="#认识-CountDownLatch" class="headerlink" title="认识 CountDownLatch"></a>认识 CountDownLatch</h2><p>CountDownLatch  能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。它相当于是一个计数器，这个计数器的初始值就是线程的数量，每当一个任务完成后，计数器的值就会减一，当计数器的值为 0 时，表示所有的线程都已经任务了，然后在 CountDownLatch 上等待的线程就可以恢复执行接下来的任务。</p><h2 id="CountDownLatch-的使用"><a href="#CountDownLatch-的使用" class="headerlink" title="CountDownLatch 的使用"></a>CountDownLatch 的使用</h2><p>CountDownLatch 提供了一个构造方法，你必须指定其初始值，还指定了 <code>countDown</code> 方法，这个方法的作用主要用来减小计数器的值，当计数器变为 0 时，在 CountDownLatch 上 <code>await</code> 的线程就会被唤醒，继续执行其他任务。当然也可以延迟唤醒，给 CountDownLatch 加一个延迟时间就可以实现。</p><p><img src="https://s3.ax1x.com/2020/12/21/rdcSKK.png" alt="img"></p><p>其主要方法如下</p><p><img src="https://s3.ax1x.com/2020/12/21/rd6xv6.png" alt="img"></p><p>CountDownLatch 主要有下面这几个应用场景</p><h3 id="CountDownLatch-应用场景"><a href="#CountDownLatch-应用场景" class="headerlink" title="CountDownLatch 应用场景"></a>CountDownLatch 应用场景</h3><p>典型的应用场景就是当一个服务启动时，同时会加载很多组件和服务，这时候主线程会等待组件和服务的加载。当所有的组件和服务都加载完毕后，主线程和其他线程在一起完成某个任务。</p><p>CountDownLatch  还可以实现学生一起比赛跑步的程序，CountDownLatch  初始化为学生数量的线程，鸣枪后，每个学生就是一条线程，来完成各自的任务，当第一个学生跑完全程后，CountDownLatch  就会减一，直到所有的学生完成后，CountDownLatch 会变为 0 ，接下来再一起宣布跑步成绩。</p><p>顺着这个场景，你自己就可以延伸、拓展出来很多其他任务场景。</p><h3 id="CountDownLatch-用法"><a href="#CountDownLatch-用法" class="headerlink" title="CountDownLatch 用法"></a>CountDownLatch 用法</h3><p>下面我们通过一个简单的计数器来演示一下 CountDownLatch 的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCountDownLatch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Increment</span> <span class="variable">increment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Increment</span>(latch);</span><br><span class="line">        <span class="type">Decrement</span> <span class="variable">decrement</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Decrement</span>(latch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(increment).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(decrement).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decrement</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decrement</span><span class="params">(CountDownLatch countDownLatch)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> countDownLatch.getCount();i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;countdown&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Increment</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Increment</span><span class="params">(CountDownLatch countDownLatch)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;await&quot;</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiter Released&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 方法中我们初始化了一个计数器为 5 的 CountDownLatch，在 Decrement 方法中我们使用 <code>countDown</code> 执行减一操作，然后睡眠一段时间，同时在 Increment 类中进行等待，直到 Decrement 中的线程完成计数减一的操作后，唤醒 Increment 类中的 run 方法，使其继续执行。</p><p>下面我们再来通过学生赛跑这个例子来演示一下 CountDownLatch 的具体用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentRunRace</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">stopLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">runLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitSignal</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;选手&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在等待裁判发布口令&quot;</span>);</span><br><span class="line">        stopLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;选手&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;已接受裁判口令&quot;</span>);</span><br><span class="line">        Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;选手&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;到达终点&quot;</span>);</span><br><span class="line">        runLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitStop</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;裁判&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;即将发布口令&quot;</span>);</span><br><span class="line">        stopLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">&quot;裁判&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;已发送口令，正在等待所有选手到达终点&quot;</span>);</span><br><span class="line">        runLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有选手都到达终点&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;裁判&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;汇总成绩排名&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">StudentRunRace</span> <span class="variable">studentRunRace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentRunRace</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    studentRunRace.waitSignal();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            studentRunRace.waitStop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就来一起分析一下 <code>CountDownLatch </code> 的源码</p><h2 id="CountDownLatch-源码分析"><a href="#CountDownLatch-源码分析" class="headerlink" title="CountDownLatch 源码分析"></a>CountDownLatch 源码分析</h2><p>CountDownLatch 使用起来比较简单，但是却非常有用，现在你可以在你的工具箱中加上 CountDownLatch 这个工具类了。下面我们就来深入认识一下 CountDownLatch。</p><p>CountDownLatch 的底层是由 <code>AbstractQueuedSynchronizer</code> 支持，而 AQS 的数据结构的核心就是两个队列，一个是 <code>同步队列(sync queue)</code>，一个是<code>条件队列(condition queue)</code>。</p><h3 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h3><p>CountDownLatch 在其内部是一个 Sync ，它继承了 AQS 抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 其实其内部只有一个 <code>sync</code> 属性，并且是 final 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>CountDownLatch 只有一个带参数的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，初始化的时候必须指定计数器的数量，如果数量为负会直接抛出异常。</p><p>然后把 count 初始化为 Sync 内部的 count，也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">  setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里有一个 setState(count)，这是什么意思呢？见闻知意这只是一个设置状态的操作，但是实际上不单单是，还有一层意思是 state 的值代表着待达到条件的线程数。这个我们在聊 countDown 方法的时候再讨论。</p></blockquote><p><code>getCount()</code> 方法的返回值是 <code>getState()</code> 方法，它是 AbstractQueuedSynchronizer 中的方法，这个方法会返回当前线程计数，具有 volatile 读取的内存语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---- CountDownLatch ----</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- AbstractQueuedSynchronizer ----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryAcquireShared()</code> 方法用于获取·共享状态下对象的状态，判断对象是否为 0 ，如果为 0 返回 1 ，表示能够尝试获取，如果不为 0，那么返回 -1，表示无法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----  getState() 方法和上面的方法相同 ----</span></span><br></pre></td></tr></table></figure><p>这个 <code>共享状态</code> 属于 AQS 中的概念，在 AQS 中分为两种模式，一种是 <code>独占模式</code>，一种是 <code>共享模式</code>。</p><ul><li>tryAcquire 独占模式，尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryAcquireShared 共享方式，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li></ul><p><code>tryReleaseShared()</code> 方法用于共享模式下的释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">  <span class="comment">// 减小数量，变为 0 的时候进行通知。</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">      <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是一个无限循环，获取线程状态，如果线程状态是 0  则表示没有被线程占有，没有占有的话那么直接返回 false ，表示已经释放；然后下一个状态进行 - 1 ，使用  compareAndSetState CAS 方法进行和内存值的比较，如果内存值也是 1 的话，就会更新内存值为 0 ，判断 nextc 是否为 0 ，如果 CAS 比较不成功的话，会再次进行循环判断。</p><blockquote><p>如果 CAS 用法不清楚的话，读者朋友们可以参考这篇文章 <a href="https://mp.weixin.qq.com/s/vbXAgNH9PyL16PmjgnGKZA">告诉你一个 AtomicInteger 的惊天大秘密！</a></p></blockquote><h3 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h3><p><code>await()</code> 方法是  CountDownLatch 一个非常重要的方法，基本上可以说只有 countDown 和 await 方法才是 CountDownLatch  的精髓所在，这个方法将会使当前线程在 CountDownLatch 计数减至零之前一直等待，除非线程被中断。</p><p>CountDownLatch 中的 await 方法有两种，一种是不带任何参数的 <code>await()</code>，一种是可以等待一段时间的<code>await(long timeout, TimeUnit unit)</code>。下面我们先来看一下  await() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 方法内部会调用 acquireSharedInterruptibly 方法，这个 acquireSharedInterruptibly 是 AQS 中的方法，以共享模式进行中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，acquireSharedInterruptibly 方法的内部会首先判断线程是否<code>中断</code>，如果线程中断，则直接抛出线程中断异常。如果没有中断，那么会以共享的方式获取。如果能够在共享的方式下不能获取锁，那么就会以共享的方式断开链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">      <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          setHeadAndPropagate(node, r);</span><br><span class="line">          p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有些长，我们分开来看</p><ul><li>首先，会先构造一个共享模式的 Node 入队</li><li>然后使用无限循环判断新构造 node 的前驱节点，如果 node 节点的前驱节点是头节点，那么就会判断线程的状态，这里调用了一个 setHeadAndPropagate ,其源码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">  <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">  setHead(node);</span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会设置头节点，然后进行一系列的判断，获取节点的获取节点的后继，以共享模式进行释放，就会调用 doReleaseShared 方法，我们再来看一下 doReleaseShared 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会以无限循环的方式首先判断头节点是否等于尾节点，如果头节点等于尾节点的话，就会直接退出。如果头节点不等于尾节点，会判断状态是否为 SIGNAL，不是的话就继续循环 compareAndSetWaitStatus，然后断开后继节点。如果状态不是  SIGNAL，也会调用  compareAndSetWaitStatus 设置状态为 PROPAGATE，状态为 0 并且不成功，就会继续循环。</p><p>也就是说 setHeadAndPropagate 就是设置头节点并且释放后继节点的一系列过程。</p><ul><li>我们来看下面的 if 判断，也就是 <code>shouldParkAfterFailedAcquire(p, node) </code> 这里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br></pre></td></tr></table></figure><p>如果上面 Node p &#x3D; node.predecessor() 获取前驱节点不是头节点，就会进行 park 断开操作，判断此时是否能够断开，判断的标准如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会判断 Node p 的前驱节点的<code>结点状态(waitStatus)</code>，节点状态一共有五种，分别是</p><ol><li><code>CANCELLED(1)</code>：表示当前结点已取消调度。当超时或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><code>SIGNAL(-1)</code>：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为 SIGNAL。</li><li><code>CONDITION(-2)</code>：表示结点等待在 Condition 上，当其他线程调用了 Condition 的 signal() 方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li><li><code>PROPAGATE(-3)</code>：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><code>0</code>：新结点入队时的默认状态。</li></ol><p>如果前驱节点是 SIGNAL 就会返回 true  表示可以断开，如果前驱节点的状态大于 0 (此时为什么不用 ws &#x3D;&#x3D; Node.CANCELLED ) 呢？因为 ws 大于 0 的条件只有  CANCELLED 状态了。然后就是一系列的查找遍历操作直到前驱节点的 waitStatus &gt; 0。如果 ws &lt;&#x3D; 0  ，而且还不是 SIGNAL 状态的话，就会使用 CAS 替换前驱节点的 ws 为 SIGNAL 状态。</p><p>如果检查判断是中断状态的话，就会返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">  LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法使用 <code>LockSupport.park</code> 断开连接，然后返回线程是否中断的标志。</p><ul><li><code>cancelAcquire()</code> 用于取消等待队列，如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  node.thread = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">  <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">  <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">  node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">    compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> ws;</span><br><span class="line">    <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">        ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">         (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">        pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">      <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">        compareAndSetNext(pred, predNext, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">    node.next = node; <span class="comment">// help GC</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，对 CountDownLatch 的 await 调用大致会有如下的调用过程。</p><p><img src="https://s3.ax1x.com/2020/12/21/rd6vgx.png" alt="img"></p><p>一个和 await 重载的方法是 <code>await(long timeout, TimeUnit unit)</code>，这个方法和 await 最主要的区别就是这个方法能够可以等待计数器一段时间再执行后续操作。</p><h3 id="countDown-方法"><a href="#countDown-方法" class="headerlink" title="countDown 方法"></a>countDown 方法</h3><p>countDown 是和 await 同等重要的方法，countDown 用于减少计数器的数量，如果计数减为 0 的话，就会释放所有的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会调用 releaseShared 方法，此方法用于共享模式下的释放操作，首先会判断是否能够进行释放，判断的方法就是 CountDownLatch 内部类 Sync 的 tryReleaseShared 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- CountDownLatch ----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">      <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 会进行 for 循环判断线程状态值，使用 CAS 不断尝试进行替换。</p><p>如果能够释放，就会调用 doReleaseShared 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，doReleaseShared 其实也是一个无限循环不断使用 CAS 尝试替换的操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是 CountDownLatch  的基本使用和源码分析，CountDownLatch 就是一个基于 AQS 的计数器，它内部的方法都是围绕 AQS  框架来谈的，除此之外还有其他比如 ReentrantLock、Semaphore 等都是 AQS 的实现，所以要研究并发的话，离不开对 AQS  的探讨。CountDownLatch 的源码看起来很少，比较简单，但是其内部比如 await 方法的调用链路却很长，也值得花费时间深入研究。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-ReentrantLock使用</title>
      <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>从Java 5开始，引入了一个高级的处理并发的<code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p><p>我们知道Java语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁，我们来看一下传统的<code>synchronized</code>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public void add(int n) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<code>ReentrantLock</code>替代，可以把代码改造为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private final Lock lock = new ReentrantLock();</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public void add(int n) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p><p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p><p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>ReentrantLock</code>可以替代<code>synchronized</code>进行同步；</p><p><code>ReentrantLock</code>获取锁更安全；</p><p>必须先获取到锁，再进入<code>try &#123;...&#125;</code>代码块，最后使用<code>finally</code>保证释放锁；</p><p>可以使用<code>tryLock()</code>尝试获取锁。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-ReentrantLock原理</title>
      <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ReentrantLock%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>如果你在之前的文章中我们已经了解过了 java中的管程sychronized实现原理，那么再来看AbstractQueuedSynchronizer的实现就会非常简单了，虽然使用的加锁技术有不同之处，但是他们都是基于同样的理念去实现的.</p><p>打开ReentrantLock 的源码你会发现，ReentrantLock  的所有操作都是基于Sycn对象去操作的，而Sycn继承于AbstractQueuedSynchronizer的一个子类，而不管是NonfairSync非公平锁，还是FairSync 公平锁都继承于Sycn，这也说明了ReentrantLock  里面最终维护的其实就是一个AQS对象。</p><p><img src="/resources/ReentrantLock/v2-2ee1014090c1b443b24f6e69c28442e9_1440w-1682070247235-29.webp" alt="img"></p><h3 id="1、AQS的初始化。"><a href="#1、AQS的初始化。" class="headerlink" title="1、AQS的初始化。"></a><strong>1、AQS的初始化。</strong></h3><p>当我们调用new ReentrantLock()时其实就是初始化了一个AQS对象，该对象包括如下几个属性</p><p>1、<strong>state</strong> （锁的状态 0代表未加锁，&gt;0则代表已加锁，和重入次数）</p><p>2、<strong>exclusiveOwnerThread</strong> （拥有当前锁的线程）</p><p>3、由 Node节点组成的双向链表，Node节点保存了等待线程的相关信息。</p><p><img src="/resources/ReentrantLock/v2-9a8eb3fe3514e624707ad18d4f859ed6_1440w.webp" alt="img"></p><p><strong>当AQS初始化之后，会初始化一个如下对象</strong></p><p>1、state状态为0</p><p>2、exclusiveOwnerThread &#x3D;null</p><p> 3、由head 和tail两个空节点组成的首尾双向链表。</p><p><img src="/resources/ReentrantLock/v2-141518a2df8159ef365bf773eec152f7_1440w.webp" alt="img"></p><h3 id="2、AQS的加锁过程"><a href="#2、AQS的加锁过程" class="headerlink" title="2、AQS的加锁过程"></a><strong>2、AQS的加锁过程</strong></h3><p>一个线程通过ReentrantLock .lock()  首先会获得当前AQS锁的状态，然后根据锁的对应状态做出不同的处理，具体分为以下几种情况；</p><p>1、<strong>第一种情况：</strong>初次加锁，还没有任何线程获得AQS的锁；</p><p>2、<strong>第二种情况：</strong>已经有线程获得了AQS的锁，但是加锁的线程和当前线程是同一个;</p><p>3、<strong>第三种情况三：</strong>已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；</p><p>下面我们针对每种情况进行分析</p><h3 id="2-1、-第一种情况：初次加锁，还没有任何线程获得AQS的锁；"><a href="#2-1、-第一种情况：初次加锁，还没有任何线程获得AQS的锁；" class="headerlink" title="2-1、 第一种情况：初次加锁，还没有任何线程获得AQS的锁；"></a><strong>2-1、</strong> <strong>第一种情况：初次加锁，还没有任何线程获得AQS的锁；</strong></h3><p>线程A调用ReentrantLock .lock()  进行加锁，当还没有任何对象获得AQS锁时候会执FairSync.tryAcquire（）方法的如下代码：</p><p><img src="/resources/ReentrantLock/v2-fb7582a703962a9fc69ef7471b5dce1e_1440w.webp" alt="img"></p><p><strong>以上标注代码的逻辑：</strong></p><p>1、判断队列中是否有正在等待锁的节点，因为是初次加锁，所以这里head和tail节点都是空；</p><p>2、使用compareAndSetState（）方法对AQS进行加锁（此方法能保证操作的原子性）。</p><p>3、设置当前获得锁对象的线程；</p><p><img src="/resources/ReentrantLock/v2-ff8e996407749e929af483f439558b64_1440w.webp" alt="img"></p><h3 id="2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个"><a href="#2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个" class="headerlink" title="2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个;"></a><strong>2-2、第二种情况：已经有线程获得了AQS的锁，但是获得锁的线程和当前线程是同一个;</strong></h3><p><img src="/resources/ReentrantLock/v2-d68554183594cc5a083fef223da2f088_1440w.webp" alt="img"></p><p>如上面代码，当线程A调用demo1()方法，已经获得了AQS锁，当调用demo2时又会去竞争AQS锁，这样允许同一个线程多次获得同一把锁的情况称为 <strong>“可重入锁”</strong></p><p>当线程A再次调用ReentrantLock .lock() 时会执行FairSync.tryAcquire（）对应重入锁逻辑的代码：</p><p><img src="/resources/ReentrantLock/v2-9c6b1c975e6c1ffc5defd0f79ee5c71a_1440w.webp" alt="img"></p><p><strong>以上标注代码的逻辑：</strong></p><p>1、首先拿当前线程和已经获得AQS锁的线程对比是否是同一个线程；</p><p>2、是同一个线程的话获得 当前AQS的state ，执行state+1累计重入次数；</p><p>3、修改AQS的state;</p><p><strong>最后执行结果如下图：</strong></p><p><img src="/resources/ReentrantLock/v2-fdab126d61043d8e8b45c9be725c7dad_1440w.webp" alt="img"></p><h3 id="2-3、第三种情况：已经有线程获得了AQS的锁-并且加锁的线程和当前线程不是同一个；"><a href="#2-3、第三种情况：已经有线程获得了AQS的锁-并且加锁的线程和当前线程不是同一个；" class="headerlink" title="2-3、第三种情况：已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；"></a><strong>2-3、第三种情况：已经有线程获得了AQS的锁,并且加锁的线程和当前线程不是同一个；</strong></h3><p>当前面的线程A已经获得了AQS锁，还没进行释放，此时线程B调用ReentrantLock .lock() 方法获取锁会执行AbstractQueuedSynchronizer.acquire()的如下代码：</p><p><img src="/resources/ReentrantLock/v2-1652935801412dc6fb63c19fbef4940c_1440w.webp" alt="img"></p><p><strong>以上代码逻辑：</strong></p><p><strong>1、首先执行 addWaiter（）把获得锁不成功的线程加入到阻塞队列</strong></p><p>A、把线程B封装为一个Node节点（这里我们定义为nodeB）;</p><p>B、如果当前AQS中双向链表tail节点不为空，则把nodeB设置为tail节点，把nodeB.pre指向原来的tail节点，并把原来的tail节点的nex指向nodeB；</p><p>C、如果当前AQS中双向链表tail节点为空，则说明当前链表里面没有其他等待的节点，那么首先创建一个Node  节点（这里定义为nodeN）作为head节点，然后把nodeN.nex指向nodeB节点，把tail指向nodeB节点,nodeB.pre指向nodeN节点； </p><p><strong>2、addWwaiter()成功后调用 acquireQueued（）方法</strong>；</p><p>F、首先会再次尝试获取一下锁；</p><p>G、当获取锁失败后，把双向链表中nodeB.pre指向的节点的waitStatus 设置为 -1；</p><p><strong>注：</strong></p><p><strong>waitStatus&#x3D;0</strong>  新加的节点，处于阻塞状态。</p><p><strong>waitStatus&#x3D; 1</strong> 表示该线程节点已释放（超时、中断），已取消的节点不会再阻塞。</p><p><strong>waitStatus&#x3D;-1</strong> 表示该线程的后续线程需要阻塞，即只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程 。</p><p><strong>waitStatus&#x3D;-2</strong>  表示该节点的线程处于等待Condition条件状态,不会被当作是同步队列上的节点,直到被唤醒(signal),设置其值为0,重新进入阻塞状。</p><p><strong>waitStatus&#x3D;-3</strong>  表示该线程以及后续线程进行无条件传播（CountDownLatch中有使用）共享模式下，        PROPAGATE 状态的线程处于可运行状态。</p><p>因为我们的案例是第一加锁，所以head 和tail节点都为null ，所以代码会走A、C、F、G逻辑 。</p><p>最后结果如图。</p><p><img src="/resources/ReentrantLock/v2-d4d66759f2761c7f2873a1d28ce7ae1c_1440w.webp" alt="img"></p><p><strong>最后整个AQS初始化、线程A两次加锁、线程B加锁的流程如图：</strong></p><p><img src="/resources/ReentrantLock/v2-0e5c82fd5518713879a7e2c13bc71259_1440w.webp" alt="img"></p><h3 id="3、AQS的解锁过程"><a href="#3、AQS的解锁过程" class="headerlink" title="3、AQS的解锁过程"></a><strong>3、AQS的解锁过程</strong></h3><p>通过上面的流程，我们已经了解了AQS的加锁过程，当线程加锁不成功之后，会把当前线程放到一个等待队列中去，这个队列是由head和tail构建出来的一个双向链表，下面我们继续上面的案例继续分析AQS的解锁过程。</p><p>因为上面AQS的锁获得线程为线程A ，所以现在只有线程A可以进行释放锁，当线程A调用ReentrantLock .unlock() 时，最终执行ReentrantLock.tryRelease()方法，代码如下：</p><p><img src="/resources/ReentrantLock/v2-0deb9cd7199f5fb6b5b1959154e86ec3_1440w.webp" alt="img"></p><p>1、获得当前AQS的state 并进行减1(state每减1代表释放一次锁)；</p><p>2、当state&#x3D;0的时候说明当前锁已经完全释放了，此时会设置拥有AQS 锁的线程为null;</p><p>3、当state不等于0说明锁还没有释放完全，此时修改state的值。</p><p>因为上面案例中线程A获得了2次锁，所以线程A需要调用两次ReentrantLock .unlock()才能释放锁，整个流程如下图：</p><p><img src="/resources/ReentrantLock/v2-3c93d8482ca4623f3362a4ca491b6a46_1440w.webp" alt="img"></p><p>当线程A释放完锁之后程序会调用AbstractQueuedSynchronizer.release()方法的如下代码：</p><p><img src="/resources/ReentrantLock/v2-c2671edb6cf3db997e1d2348f4752438_1440w.webp" alt="img"></p><p>我想如果明白了AQS的加锁过程，那么你已经猜到了，当线程释放锁完毕之后接下来肯定是唤醒等待队列里面的线程了，这段代码也的确是在做这些事情：</p><p>1、获得等待队列链表中的head节点；</p><p>2、当head节点不为空，并且head节点的waitStatus!&#x3D;0（这里代表线程状态正常）时，调用unparkSuccessor（）方法唤醒链表中head.next节点中的线程，。</p><p>3、当前链表里面head.next 为nodeB,所以线程B会被唤醒，然 后重新去获取锁，同时重构链表节点.</p><p><strong>最后结果如图：</strong></p><p><img src="/resources/ReentrantLock/v2-1a23525fdccec60ce0d88fd32f1c3701_1440w.webp" alt="img"></p><h3 id="4、公平锁非公平锁的区别"><a href="#4、公平锁非公平锁的区别" class="headerlink" title="4、公平锁非公平锁的区别"></a><strong>4、公平锁非公平锁的区别</strong></h3><p>公平锁进行lock()的时候，如果AQS为无锁状态，公平锁首先会判断AQS里面是否有等待的线程，如果有的话会添加到队列里面排队，队列里面没有线程的话才会去尝试获取锁。</p><p>非公平锁 进行lock()的时候，只要是AQS是无锁状态，不管队列里面是否有等待线程都会直接去尝试获得锁。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-信号量</title>
      <link href="/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Semaphore/"/>
      <url>/2023/04/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B-Semaphore/</url>
      
        <content type="html"><![CDATA[<hr><p>前面我们讲了各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p><p>还有一种受限资源，它需要保证同一时刻最多有N个线程能访问，比如同一时刻最多创建100个数据库连接，最多允许10个用户下载等。</p><p>这种限制数量的锁，如果用Lock数组来实现，就太麻烦了。</p><p>这种情况就可以使用<code>Semaphore</code>，例如，最多允许3个线程同时访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AccessLimitControl &#123;</span><br><span class="line">    // 任意时刻仅允许最多3个线程获取许可:</span><br><span class="line">    final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">    public String access() throws Exception &#123;</span><br><span class="line">        // 如果超过了许可数量,其他线程将在此等待:</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        try &#123;</span><br><span class="line">            // TODO:</span><br><span class="line">            return UUID.randomUUID().toString();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>Semaphore</code>先调用<code>acquire()</code>获取，然后通过<code>try ... finally</code>保证在<code>finally</code>中释放。</p><p>调用<code>acquire()</code>可能会进入等待，直到满足条件为止。也可以使用<code>tryAcquire()</code>指定等待时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    // 指定等待时间3秒内获取到许可:</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO:</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Semaphore</code>本质上就是一个信号计数器，用于限制同一时间的最大访问数量。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果要对某一受限资源进行限流访问，可以使用<code>Semaphore</code>，保证同一时间最多N个线程访问受限资源。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据-CheckPoint</title>
      <link href="/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-CheckPoint/"/>
      <url>/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-CheckPoint/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据-状态后端</title>
      <link href="/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-Flink%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/"/>
      <url>/2023/04/24/%E5%A4%A7%E6%95%B0%E6%8D%AE-Flink%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="可用的State-Backend"><a href="#可用的State-Backend" class="headerlink" title="可用的State Backend"></a>可用的State Backend</h3><p>Flink提供三种开箱即用的State Backend：</p><ul><li>HashMapStateBackend </li><li>EmbeddedRocksDBStateBackend</li></ul><h3 id="HashMapStateBackend"><a href="#HashMapStateBackend" class="headerlink" title="HashMapStateBackend"></a>HashMapStateBackend</h3><p>HashMapStateBackend在java堆上保存数据，健值对的状态和windows函数使用hashtable存储值或者触发器。</p><p>HashMapStateBackend优势：</p><ul><li>job的状态（state）很大，window很长，状态的键值对很大</li><li>所有高可用性设置</li></ul><p>还建议将托管内存设置为零。 这将确保为 JVM 上的用户代码分配最大量的内存。 与 EmbeddedRocksDBStateBackend 不同，HashMapStateBackend 将数据作为对象存储在堆上，因此重用对象是不安全的。</p><h3 id="EmbeddedRocksDBStateBackend"><a href="#EmbeddedRocksDBStateBackend" class="headerlink" title="EmbeddedRocksDBStateBackend"></a>EmbeddedRocksDBStateBackend</h3><p>EmbeddedRocksDBStateBackend 将动态数据保存在 RocksDB 数据库中，该数据库（默认情况下）存储在 TaskManager 本地数据目录中。 与在 HashMapStateBackend 中存储 java 对象不同，数据存储为序列化的字节数组，主要由类型序列化器定义，因此导致键的比较是按字节进行的，而不是使用 Java 的 hashCode() 和 equals() 方法。</p><p>EmbeddedRocksDBStateBackend 始终执行异步快照。</p><p>EmbeddedRocksDBStateBackend优缺点</p><p>缺点：</p><ul><li>由于 RocksDB 的 JNI 桥接 API 基于 byte[]，每个键和每个值支持的最大大小为 2^31 字节。 在 RocksDB 中使用合并操作的状态（例如 ListState）可以静默地累积大于 2^31 字节的值大小，然后在下一次检索时失败。 这是目前 RocksDB JNI 的一个限制。</li></ul><p>优点：</p><ul><li>具有非常大状态、长窗口、大键&#x2F;值状态的作业（比HashMapStateBackend 更好的处理更大的状态）</li><li>所有高可用性设置。</li></ul><p>注意：EmbeddedRocksDBStateBackend可以保留的状态大小仅受磁盘空大小的限制。与将状态保存在内存中的 HashMapStateBackend 相比，这允许保存非常大的状态。 但是，这也意味着使用此状态后端的最大吞吐量会更低。 此后端的所有读取写都必须通过反序列化或者序列化来查询或者写入状态对象，这也比始终使用堆上表示更昂贵。由于反序列化，EmbeddedRocksDBStateBackend 可以安全地重用对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 HashMapStateBackend 和 RocksDB 之间做出选择时，它是性能和可伸缩性之间的选择。 HashMapStateBackend 非常快，因为每个状态访问和更新都对 Java 堆上的对象进行操作； 但是，状态大小受集群内可用内存的限制。 另一方面，RocksDB 可以根据可用磁盘空间进行扩展，并且是唯一支持增量快照的状态后端。 但是，每个状态访问和更新都需要（反）序列化并可能从磁盘读取，这导致平均性能比内存状态后端慢一个数量级。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-Java内存模型</title>
      <link href="/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/04/15/%E6%A6%82%E5%BF%B5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2.垃圾收集算法"></a>2.垃圾收集算法</h3><p>基于分代收集理论，可以分为年轻代、年老代两类收集算法。</p><p>年轻代：标记复制</p><p>年老代：标记整理</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>其中标记清除算法是最基础的算法，后续算法都是基于标记清楚算法改进得到的</p><p>标记清除算法缺点：</p><ul><li>执行效率不稳定，当年轻代有大量回收对象时候，需要执行大量标记清除动作，而标记动作通常是需要stop the world的，所以可能存在性能问题</li><li>内存碎片问题</li></ul><h4 id="标记复制"><a href="#标记复制" class="headerlink" title="标记复制"></a>标记复制</h4><p>标记复制是将存活对象复制到两个Eden区的其中一个，然后回收剩下内存里的所有对象</p><p>年轻代特点是”朝生夕死”，需要复制对象数量少，所以使用标记复制进行垃圾回收效率高</p><p>一个Survivor区，两个Eden区，比例为8：1：1</p><ul><li>执行第一次垃圾回收时候，将存活对象放到某个Enden区，剩下的Survivor和Eden执行回收操作</li><li>执行第二次垃圾回收时候，将存活对象copy到另一个Enden区，剩下的Survivor和Eden执行回收操作</li></ul><h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>年老代特点是垃圾回收比较少，标记整理算法是年老代算法。老年代如果使用标记复制算法需要复制很多对象，效率比较低</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>年轻代回收器：</p><ul><li>Serial收集器        使用标记-复制的单线程垃圾回收器</li><li>ParNew收集器    使用标记-复制的多线程垃圾回收器</li><li>Parallel Scavenge收集器     <em>和parnew区别：控制吞吐量</em></li></ul><p>年老代回收器：</p><ul><li>Serial Old收集器    <em>使用标记-整理算法单线程垃圾回收器</em></li><li>Parallel Old收集器 <em>使用标记-整理算法多线程垃圾回收器</em></li><li>CMS收集器</li></ul><p>全年龄收集器：G1</p><h4 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h4><p>CMS是年老代回收器</p><ul><li>初始标记（CM S initial mark） <em>单线程，会stop the world</em></li><li>并发标记（CM S concurrent mark）</li><li>重新标记（CM S remark） <em>多线程，会stop the world</em></li><li>并发清除（CM S concurrent sweep）</li></ul><p><img src="/resources/%E9%9D%A2%E8%AF%95-%E4%B8%AD%E4%BF%A1/cms.jpg" alt="cms"></p><h4 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h4><p>G1是基于分代理论设计的，可以同时在年轻代年老代使用。</p><p>G1将Java堆内存分成数个相等大小的区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>Region还有一种是专门存储大对象的Region，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</p><p>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的<br>运作过程大致可划分为以下四个步骤：</p><ul><li>初始标记（Initial M arking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAM S<br>指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要<br>停顿线程，但耗时很短，而且是借用进行M inor GC的时候同步完成的，所以G1收集器在这个阶段实际<br>并没有额外的停顿。</li><li>并发标记（Concurrent M arking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆<br>里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以<br>后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li>最终标记（Final M arking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留<br>下来的最后那少量的SATB记录。</li><li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回<br>收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region<br>构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧<br>Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行<br>完成的。</li></ul><p><img src="/resources/%E9%9D%A2%E8%AF%95-%E4%B8%AD%E4%BF%A1/g1.jpg" alt="g1"></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-在Spring中如何解决循环依赖的问题</title>
      <link href="/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/05/31/%E6%A6%82%E5%BF%B5-%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>一般场景是一个Bean A依赖Bean B,而Bean B也依赖Bean A.<br>Bean A → Bean B → Bean A</p><p>当然我们也可以添加更多的依赖层次，比如：<br>Bean A → Bean B → Bean C → Bean D → Bean E → Bean A</p><h2 id="Spring发生了什么"><a href="#Spring发生了什么" class="headerlink" title="Spring发生了什么"></a>Spring发生了什么</h2><p>当 Spring 上下文加载所有 bean 时，它会尝试按照它们完全工作所需的顺序创建 bean。例如，如果我们没有循环依赖，就像下面的例子：</p><p>bean A → bean B → bean C</p><p>Spring将创建bean C，然后创建bean B（并将bean C注入其中），然后创建bean A（并将bean B注入其中）。</p><p>但是，当有循环依赖时，Spring 无法决定首先创建哪个 bean，因为它们相互依赖。在这些情况下，Spring 将在加载上下文时引发<em>BeanCurrentlyInCreationException</em>。</p><p>在 Spring 中使用<strong>构造函数注入</strong>时可能会发生这种情况；如果您使用其他类型的注入，您应该不会发现此问题，因为依赖项将在需要时注入，而不是在上下文加载时注入。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>让我们定义两个相互依赖的 bean（通过构造函数注入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularDependencyA</span><span class="params">(CircularDependencyB circB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circB = circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularDependencyB</span><span class="params">(CircularDependencyA circA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以为测试编写一个 Configuration 类，我们称之为<em>TestConfig</em>，它指定要扫描组件的基本包。假设我们的 bean 定义在包“ <em>com.baeldung.circulardependency</em> ”中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123; &quot;com.baeldung.circulardependency&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们可以编写一个 JUnit 测试来检查循环依赖。测试可以为空，因为在上下文加载期间将检测到循环依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123; TestConfig.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenCircularDependency_whenConstructorInjection_thenItFails</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Empty test; we just want the context to load</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您尝试运行此测试，您将收到以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;circularDependencyA&#x27;</span>:</span><br><span class="line">Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure><h2 id="应对办法"><a href="#应对办法" class="headerlink" title="应对办法"></a>应对办法</h2><h3 id="重新设计"><a href="#重新设计" class="headerlink" title="重新设计"></a>重新设计</h3><p>当您具有循环依赖关系时，可能是您遇到了设计问题，并且职责没有很好地分开。您应该尝试正确地重新设计组件，以使它们的层次结构设计得很好，并且不需要循环依赖项。</p><p>如果您无法重新设计组件（可能有很多可能的原因：遗留代码、已经过测试且无法修改的代码、没有足够的时间或资源进行完整的重新设计……），可以尝试一些变通方法。</p><h3 id="使用-Lazy"><a href="#使用-Lazy" class="headerlink" title="使用@Lazy"></a>使用@Lazy</h3><p>打破循环的一种简单方法是说 Spring 懒惰地初始化其中一个 bean。也就是说：它不会完全初始化 bean，而是创建一个代理以将其注入另一个 bean。注入的Bean仅在首次需要时才完全创建。</p><p>要使用我们的代码尝试此操作，您可以将 CircularDependencyA 更改为以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircularDependencyA</span><span class="params">(<span class="meta">@Lazy</span> CircularDependencyB circB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circB = circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您现在运行测试，您将看到这次错误不会发生。</p><h3 id="使用-Setter-x2F-Field-注入"><a href="#使用-Setter-x2F-Field-注入" class="headerlink" title="使用 Setter&#x2F;Field 注入"></a>使用 Setter&#x2F;Field 注入</h3><p>最流行的解决方法之一，也是<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html">Spring 文档提出的</a>，是使用 setter 注入。</p><p>简单地说，如果您更改 bean 的连接方式以使用 setter 注入（或字段注入）而不是构造函数注入 - 这确实解决了问题。通过这种方式，Spring 创建了 bean，但在需要它们之前不会注入依赖项。</p><p>让我们这样做——让我们改变我们的类以使用 setter 注入，并将另一个字段 ( <em>message</em> )添加到<em>CircularDependencyB</em>以便我们可以进行适当的单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircB</span><span class="params">(CircularDependencyB circB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circB = circB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CircularDependencyB <span class="title function_">getCircB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircA</span><span class="params">(CircularDependencyA circA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们必须对单元测试进行一些更改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123; TestConfig.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CircularDependencyA <span class="title function_">getCircularDependencyA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircularDependencyA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CircularDependencyB <span class="title function_">getCircularDependencyB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CircularDependencyB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenCircularDependency_whenSetterInjection_thenItWorks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CircularDependencyA</span> <span class="variable">circA</span> <span class="operator">=</span> context.getBean(CircularDependencyA.class);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Hi!&quot;</span>, circA.getCircB().getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释上面看到的注释：</p><p><em>@Bean</em>：告诉 Spring 框架必须使用这些方法来检索要注入的 bean 的实现。</p><p><em>@Test</em>：测试将从上下文中获取 CircularDependencyA bean 并断言其 CircularDependencyB 已正确注入，检查其<em>message</em>属性的值。</p><h3 id="使用-PostConstruct"><a href="#使用-PostConstruct" class="headerlink" title="使用@PostConstruct"></a>使用@PostConstruct</h3><p>打破循环的另一种方法是在其中一个 bean 上使用*@Autowired<em>注入一个依赖项，然后使用一个用</em>@PostConstruct*注释的方法来设置另一个依赖项。</p><p>我们的 bean 可以有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        circB.setCircA(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CircularDependencyB <span class="title function_">getCircB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> circB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircA</span><span class="params">(CircularDependencyA circA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以运行与之前相同的测试，因此我们检查循环依赖异常仍然没有被抛出并且依赖被正确注入。</p><h3 id="实现ApplicationContextAware和InitializingBean"><a href="#实现ApplicationContextAware和InitializingBean" class="headerlink" title="实现ApplicationContextAware和InitializingBean"></a>实现ApplicationContextAware和InitializingBean</h3><p>如果其中一个 bean 实现了<em>ApplicationContextAware</em>，则该 bean 可以访问 Spring 上下文并可以从那里提取另一个 bean。实现<em>InitializingBean</em>我们表明这个 bean 在它的所有属性都被设置后必须做一些动作；在这种情况下，我们想手动设置我们的依赖项。</p><p>我们的 bean 的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyA</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyB circB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CircularDependencyB <span class="title function_">getCircB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> circB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        circB = context.getBean(CircularDependencyB.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(<span class="keyword">final</span> ApplicationContext ctx)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        context = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularDependencyB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircularDependencyA circA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCircA</span><span class="params">(CircularDependencyA circA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circA = circA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，我们可以运行之前的测试，并看到没有抛出异常并且测试按预期工作。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-jstack查看线程状态</title>
      <link href="/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
      <url>/2021/05/26/Java-jstack%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增</p><p>高了、出现了死锁、死循环等，我们该如何分析呢？</p><p>由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要</p><p>看下jvm的内部线程的执行情况，然后再进行分析查找出原因。</p><p>用法：jstack <pid></p><p><img src="/images/jstack-1.png" alt="img"></p><p>java线程的6种状态</p><p><strong>初始态（NEW）</strong></p><p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p><p><strong>运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。</strong></p><p>就绪态</p><p>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。</p><p>所有就绪态的线程存放在就绪队列中。</p><p>运行态</p><p>获得CPU执行权，正在执行的线程。</p><p>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</p><p><strong>阻塞态（BLOCKED）</strong></p><p>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。</p><p>而在Java中，阻塞态专指请求锁失败时进入的状态。</p><p>由一个阻塞队列存放所有阻塞态的线程。</p><p>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。</p><p><strong>等待态（WAITING）</strong></p><p>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。</p><p>也有一个等待队列存放所有等待态的线程。</p><p>线程处于等待态表示它需要等待其他线程的指示才能继续运行。</p><p>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</p><p><strong>超时等待态（TIMED_WAITING）</strong></p><p>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；</p><p>进入该状态后释放CPU执行权 和 占有的资源。</p><p>与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p><p><strong>终止态（TERMINATED）</strong></p><p>线程执行结束后的状态。</p><p><strong>使用jstack查找死锁</strong></p><p>构造死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread2</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 拿到了 obj1 的锁！&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 停顿2秒的意义在于，让Thread2线程拿到obj2的锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1 拿到了 obj2 的锁！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 拿到了 obj2 的锁！&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 停顿2秒的意义在于，让Thread1线程拿到obj1的锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 拿到了 obj1 的锁！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jstack 11464</p><p><img src="/images/jstack-2.png" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000017bfeca3e80 (object 0x000000008a0e36e8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000017bfeca5e80 (object 0x000000008a0e36f8, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">        at TestDeadLock$Thread2.run(TestDeadLock.java:40)</span><br><span class="line">        - waiting to lock &lt;0x000000008a0e36e8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000008a0e36f8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(java.base@9.0.4/Thread.java:844)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">        at TestDeadLock$Thread1.run(TestDeadLock.java:22)</span><br><span class="line">        - waiting to lock &lt;0x000000008a0e36f8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000008a0e36e8&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(java.base@9.0.4/Thread.java:844)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-使用guava缓存的例子</title>
      <link href="/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
      <url>/2021/04/29/Java-%E4%BD%BF%E7%94%A8guava%E7%BC%93%E5%AD%98%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>使用guava缓存数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; dataSourceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, String&gt; localCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuavaTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        initDataSource();</span><br><span class="line">        initLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLocalCache</span><span class="params">()</span> &#123;</span><br><span class="line">        localCache = CacheBuilder.newBuilder().maximumSize(<span class="number">5</span>).expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getFromDataSource(key);</span><br><span class="line">                        localCache.put(key, value);</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFromDataSource</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSourceMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFromLocalCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> localCache.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">GuavaTest</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuavaTest</span>();</span><br><span class="line">        System.out.println(g.getFromLocalCache(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">        System.out.println(g.getFromLocalCache(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的的例子，需要使用数据源，读不到数据从数据源里读取。如果单纯使用guava当作缓存，读取不到返回null怎么实现呢？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.cpp.cache.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Optional;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.RemovalListener;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.RemovalNotification;</span><br><span class="line"><span class="keyword">import</span> com.yidian.cpp.cache.LocalCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalCacheImpl</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">LocalCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;K, Optional&lt;V&gt;&gt; caches = CacheBuilder.newBuilder().maximumSize(MAX_SIZE)</span><br><span class="line">            .expireAfterAccess(EXPIRE_TIME, TimeUnit.HOURS).removalListener(<span class="keyword">new</span> <span class="title class_">RemovalListener</span>&lt;K, Optional&lt;V&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRemoval</span><span class="params">(RemovalNotification&lt;K, Optional&lt;V&gt;&gt; notification)</span> &#123;</span><br><span class="line">                    <span class="comment">// TODO</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).build();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Optional&lt;V&gt; opt = caches.get(key, <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Optional&lt;V&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Optional&lt;V&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// TODO获取数据，加入缓存</span></span><br><span class="line">                <span class="keyword">return</span> Optional.fromNullable(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> opt.isPresent() ? opt.get() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        caches.put(key, Optional.of(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        caches.invalidate(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.cpp.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LocalCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value associated with &#123;<span class="doctag">@code</span> key&#125; in this cache, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; if there is no cached value for &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates &#123;<span class="doctag">@code</span> value&#125; with &#123;<span class="doctag">@code</span> key&#125; in this cache. If the cache</span></span><br><span class="line"><span class="comment">     * previously contained a value associated with &#123;<span class="doctag">@code</span> key&#125;, the old value</span></span><br><span class="line"><span class="comment">     * is replaced by &#123;<span class="doctag">@code</span> value&#125;.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Discards any cached value for key &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Object key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx.cpp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yidian.cpp.cache.LocalCache;</span><br><span class="line"><span class="keyword">import</span> com.yidian.cpp.cache.impl.LocalCacheImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        LocalCache&lt;String, String&gt; localCache = <span class="keyword">new</span> <span class="title class_">LocalCacheImpl</span>();</span><br><span class="line">        localCache.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">        localCache.remove(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> localCache.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        System.out.println(a == <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-Mysql之redolog_binglog_mvcc.md</title>
      <link href="/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/"/>
      <url>/2021/04/14/%E6%A6%82%E5%BF%B5-Mysql%E4%B9%8Bredolog_binglog_mvcc/</url>
      
        <content type="html"><![CDATA[<h2 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h2><p>数据在内存中的这个过程叫做data buffer，数据已经存储在磁盘上叫data file。</p><p>事务的日志也一样，在内存中叫log  buffer，在磁盘上叫log file。</p><p>data buffer的数据定时写入到data file，这个定时执行的过程是checkpoint。</p><p>如果checkpoint失败，在恢复时候，只需要做最后一次redo log或者undo log的操作就可以完成故障恢复</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>确保事务的持久性。<br>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p><h3 id="什么时候产生"><a href="#什么时候产生" class="headerlink" title="什么时候产生"></a>什么时候产生</h3><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p><h3 id="什么时候释放"><a href="#什么时候释放" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><h3 id="对应的物理文件"><a href="#对应的物理文件" class="headerlink" title="对应的物理文件"></a>对应的物理文件</h3><p>默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2<br>innodb_log_group_home_dir 指定日志文件组所在的路径，默认.&#x2F; ，表示在数据库的数据目录下。<br>innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2<br>关于文件的大小和数量，由一下两个参数配置<br>innodb_log_file_size 重做日志文件的大小。<br>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。<br>之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p><p>　　<img src="https://images2017.cnblogs.com/blog/380271/201801/380271-20180128095300756-752816619.png" alt="img"></p><p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<br>1 Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。<br>2 每个事务提交时会将重做日志刷新到重做日志文件。<br>3 当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件<br>由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。<br>因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。<br>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：<br>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。<br>这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</p><h3 id="什么时候产生-1"><a href="#什么时候产生-1" class="headerlink" title="什么时候产生"></a>什么时候产生</h3><p>事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p><h3 id="什么时候释放-1"><a href="#什么时候释放-1" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>当事务提交之后，undo log并不能立马被删除，<br>而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><h2 id="binglog"><a href="#binglog" class="headerlink" title="binglog"></a>binglog</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</p><p>用于数据库的基于时间点的还原</p><h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h2><p>逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p><p>但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息</p><p>也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p><h3 id="什么时候产生-2"><a href="#什么时候产生-2" class="headerlink" title="什么时候产生"></a>什么时候产生</h3><p>事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p><p>这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p><p>因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。<br>这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p><h3 id="什么时候释放-2"><a href="#什么时候释放-2" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Es排除节点</title>
      <link href="/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/"/>
      <url>/2021/04/08/Linux-Es%E6%8E%92%E9%99%A4%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Es集群中有一个节点性能很差，会导致Es整体查询变慢，当该物理节点被关闭但存在部分分片没有分配到其他节点上。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因为配置文件中被关闭的机器ip是存在的，Es存在一个探活过程，所以这些分片没有被自动迁移到其他节点。</p><p>可以通过Exclude该机器的IP来动态删除该机器，删除10.1.1.1节点命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT http://10.1.1.10:9210/_cluster/settings -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&quot;transient&quot; :&#123;</span></span><br><span class="line"><span class="string">&quot;cluster.routing.allocation.exclude._ip&quot; : &quot;10.1.1.1&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-数组中的第K个最大元素</title>
      <link href="/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/2021/04/08/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你可以假设 k 总是有效的，且 <span class="number">1</span> ≤ k ≤ 数组的长度。</span><br></pre></td></tr></table></figure><p>该题可以使用堆排序进行实现，时间复杂度为nlogk</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.tree.BinaryHeap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBigHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> parent, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[child] &lt;= arr[parent]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(arr, child, parent);</span><br><span class="line"></span><br><span class="line">            parent = child;</span><br><span class="line">            child = <span class="number">2</span> * child + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">BinaryHeap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryHeap</span>();</span><br><span class="line">        b.insertLevelOrder(arr);</span><br><span class="line">        b.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            buildBigHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            buildBigHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[arr.length - k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution2</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>,<span class="number">4</span>,<span class="number">123</span>&#125;;</span><br><span class="line"></span><br><span class="line">        s.print(arr);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s.findKthLargest(arr, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-八大排序算法之堆排序</title>
      <link href="/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/07/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，请你将该数组升序排列。 </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="堆排序的性质"><a href="#堆排序的性质" class="headerlink" title="堆排序的性质"></a>堆排序的性质</h3><ol><li>堆是一颗满二叉树</li><li>子节点和父节点下标关系：leftChild &#x3D; parent * 2 + 1</li><li>构建大顶堆是上浮操作，上浮操作是选择子节点中较大的节点，并和parent节点比较，子节点较大则交换子节点和parent节点</li><li>不稳定排序，时间复杂度O(nlogn)</li></ol><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>使用堆排序进行排序操作，堆排序可以分成两个步骤</p><ol><li>构建大顶堆，应该是从第向上执行遍历（上浮），所以循环从数组末尾向前循环</li><li>打印或者保存第一个节点</li><li>交换第一个和最后一个节点，缩小数组范围并继续执行第一步</li></ol><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.tree.UnOrderBTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建大顶堆</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * child = parent * 2 + 1;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBigHeap</span><span class="params">(Integer[] nums, <span class="type">int</span> parent, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[child] &lt; nums[parent]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            swap(nums, child, parent);</span><br><span class="line"></span><br><span class="line">            parent = child;</span><br><span class="line">            child = child * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            buildBigHeap(nums, i, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line"></span><br><span class="line">            buildBigHeap(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Integer[] arr1)</span> &#123;</span><br><span class="line">        <span class="type">UnOrderBTree</span> <span class="variable">unOrderBTree2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnOrderBTree</span>();</span><br><span class="line">        unOrderBTree2.insertLevelOrder(arr1);</span><br><span class="line">        unOrderBTree2.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        Integer[] arr1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        s.print(arr1);</span><br><span class="line">        s.heapSort(arr1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-快速排序</title>
      <link href="/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/02/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序1"><a href="#快速排序1" class="headerlink" title="快速排序1"></a>快速排序1</h2><p>以第一个数字6作为基数，使用双指针i,j进行双向遍历：</p><ul><li>1、i从左往右寻找第一位大于基数（6）的数字，j从右往左寻找第一位小于基数（6）的数字；</li><li>2、找到后将两个数字进行交换。继续循环交换直到i&gt;&#x3D;j结束循环；</li><li>3、最终指针i&#x3D;j,此时交换基数和i(j)指向的数字即可将数组划分为小于基数（6）&#x2F;基数（6）&#x2F;大于基数（6）的三部分，即完成一趟快排；<img src="/images/quickSort1.jpeg" alt="quickSort1"  /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, p - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, l, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, l, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        m.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序2"><a href="#快速排序2" class="headerlink" title="快速排序2"></a>快速排序2</h2><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（交换后index++，结束后返回index-1）。在这个分区退出之后，该基准就处于数列的中间位置（index-1）。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree.quicksort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">partitionIndex</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        s.quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        log.info(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-Java内存模型</title>
      <link href="/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/"/>
      <url>/2021/03/24/%E6%A6%82%E5%BF%B5-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="Java内存模型被提出的背景"><a href="#Java内存模型被提出的背景" class="headerlink" title="Java内存模型被提出的背景"></a>Java内存模型被提出的背景</h3><p>Java内存模型被提出主要是为解决如下问题</p><ul><li>硬件效率问题</li><li>计算机内存比CPU慢很多，所以需要在CPU和主存之间加寄存器和高速缓存。</li><li>缓存一致性问题</li><li>代码指令重排导致多线程执行的“乱序问题”</li></ul><h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，简称 JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。</p><h3 id="Java内存模型的组成"><a href="#Java内存模型的组成" class="headerlink" title="Java内存模型的组成"></a>Java内存模型的组成</h3><ul><li><p>主内存</p><p>Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与介绍物理硬件的主内存名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。</p></li><li><p>本地内存</p><p>每个线程都有自己的本地内存。线程本地内存存有主存中变量的副本。</p></li></ul><img src="/images/JMM2.png" alt="JMM2"/><h3 id="Java内存模型和计算机内存架构"><a href="#Java内存模型和计算机内存架构" class="headerlink" title="Java内存模型和计算机内存架构"></a>Java内存模型和计算机内存架构</h3><h4 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h4><img src="/images/JMM3.png" alt="JMM3"  /><h4 id="Java线程与硬件处理器"><a href="#Java线程与硬件处理器" class="headerlink" title="Java线程与硬件处理器"></a>Java线程与硬件处理器</h4><img src="/images/JMM4.png" alt="JMM4"  /><h4 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h4><p>通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有本地内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p><img src="/images/JMM5.png" alt="JMM5"  /><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>Java中的synchronize是使用监视器（monitor）实现的。Java中的每个对象都与一个可以锁定或者解锁的监视器相关联。只有一个线程能够持有某个监视器上的锁，任何其他试图锁定该监视器的线程都将阻塞，直至他们可以获得该监视器上的锁。线程t可以多次锁定某个特定的监视器，而每个解锁操作都会抵消一次锁定操作的效果。</p><p>synchronized计算的是对象的引用，然后它试图执行在该对象的监视器上的锁定动作，并且锁定动作成功完成之前不会执行下一步动作。在锁定动作执之后，synchronized语句体被执行。如果该语句体执行结束，无论是正常结束还是猝然结束都会在相同的监视器上执行解锁动作。</p><p>synchronized方法在被调用时会自动执行锁定动作。它的方法体在该锁定动作成功完成之前是不会被执行的。如果该方法是实例方法，那么它会锁定与在其上调用该方法的<strong>实例相关联的监视器</strong>。如果该方法是static的，那么它会锁定与与表示定义该方法的类的Class对象相关联的监视器。</p><h4 id="wait、notify和notifyAll"><a href="#wait、notify和notifyAll" class="headerlink" title="wait、notify和notifyAll"></a>wait、notify和notifyAll</h4><p>每个对象，除了具有相关联的监视器，还有相关联的等待集，即一个线程集。</p><p>当一个对象被创建时，它的等待集为空。向等待集中添加线程或者移除线程的基础动作都是原子性的。等待集只能通过wait、notify、notifyAll方法进行操作</p><h4 id="内存模型定义"><a href="#内存模型定义" class="headerlink" title="内存模型定义"></a>内存模型定义</h4><p>给定一个程序和该程序的执行轨迹，内存模型可以描述该执行轨迹是否是该程序的一次合法执行。Java编程语言的内存模型是通过如下方式实现的：检查在执行轨迹中的每个读操作。并依据特定的规则，检查该读操作观察到的写操作是否有效。</p><p>内存模型描述了程序的可能的行为。Java语言实现可以按照其喜好产生任何代码，只要程序所有的执行过程都会产生内存模型可以预测的结果。</p><p>这对Java语言的实现着提供了很大的自由度区执行大量的代码转换，包括冲排序动作和移除不必要的同步。</p><h4 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h4><p>两个动作可以通过happen-before来进行关系排序。如果一个动作在另一个动作之前发生，那么第一个动作对于第二个动作就是可视的，并且第一个动作排在第二个动作之前。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树剪枝</title>
      <link href="/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/"/>
      <url>/2021/03/08/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/buildTree.png" alt="buildTree.png"></p><ol start="2"><li>这个题得用后序遍历，用前序遍历删不干净</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-重建二叉树</title>
      <link href="/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/03/08/%E7%AE%97%E6%B3%95-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/buildTree.png" alt="buildTree.png"></p><p>题目分析</p><ol><li>前序遍历的特点是preorder[0]是根节点</li><li>中序遍历的特点是跟节点左边是左子树，跟节点右边是右子树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, rootIndex + <span class="number">1</span>),</span><br><span class="line">                Arrays.copyOfRange(inorder, <span class="number">0</span>, rootIndex));</span><br><span class="line"></span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder, rootIndex+<span class="number">1</span>, len),</span><br><span class="line">                Arrays.copyOfRange(inorder, rootIndex+<span class="number">1</span>, len));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] preorder = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] inorder = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> test.buildTree(preorder, inorder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python版本更好理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder , inorder</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        loc = inorder.index(preorder[<span class="number">0</span>]) <span class="comment"># 在中序遍历中查询当前层的根节点</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span> : loc + <span class="number">1</span>], inorder[ : loc])  <span class="comment"># 每次都是去掉头节点所以从1开始</span></span><br><span class="line">        root.right = self.buildTree(preorder[loc + <span class="number">1</span> : ], inorder[loc + <span class="number">1</span>: ])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-vim正则查找</title>
      <link href="/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/"/>
      <url>/2021/03/05/Linux-VIM%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>使用vim查询<strong>spend&#x3D;14435</strong>的命令是,</p><p>&#x2F;spend&#x3D;[1-9]\{5,5\}</p><p>其中[1-9]表示任意一个1～9的数字</p><p>\{5,5\}上面的数字表示出现了5次，即匹配14435</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-CMS垃圾回收器</title>
      <link href="/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2021/03/05/%E6%A6%82%E5%BF%B5-CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="CMS垃圾回收"><a href="#CMS垃圾回收" class="headerlink" title="CMS垃圾回收"></a>CMS垃圾回收</h3><p>CMS垃圾回收收集所有代。它会使用最小的资源来进行大多数垃圾回收工作，通常低停顿并发收集器不会复制或者压缩活动的对象。在不移动活动对象的情况下完成垃圾回收。如果内存碎片导致无法正常分配内存，请分配更大的堆内存。</p><p>CMS在年老带执行垃圾收集会氛围以下几个阶段</p><table><thead><tr><th align="left">Phase</th><th>Description</th></tr></thead><tbody><tr><td align="left">(1) Initial Mark <em>(Stop the World Event)</em></td><td>Objects in old generation are “marked” as reachable including those objects which may be reachable from young generation. Pause times are typically short in duration relative to minor collection pause times.</td></tr><tr><td align="left">(2) Concurrent Marking</td><td>Traverse the tenured generation object graph for reachable objects concurrently while Java application threads are executing. Starts scanning from marked objects and transitively marks all objects reachable from the roots. The mutators are executing during the concurrent phases 2, 3, and 5 and any objects allocated in the CMS generation during these phases (including promoted objects) are immediately marked as live.</td></tr><tr><td align="left">(3) Remark <em>(Stop the World Event)</em></td><td>Finds objects that were missed by the concurrent mark phase due to updates by Java application threads to objects after the concurrent collector had finished tracing that object.</td></tr><tr><td align="left">(4) Concurrent Sweep</td><td>Collects the objects identified as unreachable during marking phases. The collection of a dead object adds the space for the object to a free list for later allocation. Coalescing of dead objects may occur at this point. Note that live objects are not moved.</td></tr><tr><td align="left">(5) Resetting</td><td>Prepare for next concurrent collection by clearing data structures.</td></tr></tbody></table><h3 id="查看垃圾收集步骤"><a href="#查看垃圾收集步骤" class="headerlink" title="查看垃圾收集步骤"></a>查看垃圾收集步骤</h3><p>我们来一步一步查看CMS垃圾收集器的动作：</p><ol><li><p>CMS的堆结构</p><p>堆被分成如下三个部分</p><p><img src="/images/jvm-Slide1.png" alt="img"></p><p>年轻代被划分成多个区域，分别是一个Eden区和两个survivor区。</p><p>年老代被划分成一整个连续的区域，年老代垃圾回收通常在原位置进行回收，除非有full GC，否则年老代不进行压缩。</p></li><li><p>CMS在年轻代GC如何工作</p><p><img src="/images/jvm-Slide2.png" alt="img"></p><p>在下图，年轻代是绿色表示，年老代是蓝色表示。如果你的程序已经运行了一段时间，CMS有可能是这样，对象在年老代是散落分布的。</p><p>对于CMS的年老代的内存释放，如果不是FullGC，不会进行内存空间压缩。</p></li><li><p>收集年轻代</p><p>活着的对象从Eden区和survivior区拷贝到另一个survivor区。任何旧对象达到年龄阈值都会被允许进入老年代</p><p><img src="/images/jvm-Slide3.png" alt="jvm-Slide3.png"></p></li><li><p>年轻代收集之后</p><p>年轻代收集之后，Eden区被清理，且两个survivor中的一个被清空</p><p><img src="/images/jvm-Slide4.png" alt="jvm-Slide4.png"></p><p>新提升对象在图中以深蓝色表示。绿色代表是年轻代存活且没有被允许进入老年代的对象</p></li><li><p>CMS收集器的年老代</p><p>两次Stop the world发生在：初始化标记和重新标记。当年老代达到一定占用率，CMS开始收集垃圾。</p><p><img src="/images/jvm-Slide5.png" alt="jvm-Slide5.png"></p><p>（1）可达的对象被标记时候，初始化标记会发生短暂stop-the-world现象、</p><p>（2）并发标记寻找存活的对象并继续执行寻找</p><p>（3）在重新标记阶段，会重新标记在并发标记阶段中没有标记且满足被标记条件的对象</p></li><li><p>年老代收集 - 并发清除</p><p>对象没有再上一个阶段被标记将会被释放，且没有内存区域压缩</p><p><img src="/images/jvm-Slide6.png" alt="jvm-Slide6.png"></p><p>注意：Unmarked objects &#x3D;&#x3D; Dead Objects</p></li><li><p>年老代收集 - 清除之后</p><p>在（4）清除阶段，你可以看到大量的内存被释放，并且可以看出没有执行压缩内存操作</p><p><img src="/images/jvm-Slide7.png" alt="jvm-Slide7.png"></p></li></ol><p>​        最后CMS收集器将进入（5）重置阶段，并且等待达到下次GC阈值</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="">G1垃圾回收器</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-G1垃圾回收器1</title>
      <link href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/"/>
      <url>/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A81/</url>
      
        <content type="html"><![CDATA[<h3 id="G1垃圾回收"><a href="#G1垃圾回收" class="headerlink" title="G1垃圾回收"></a>G1垃圾回收</h3><p>G1（Garbage-First） 收集器是为服务器准备的垃圾回收器，是为很多核大内存服务器准备的垃圾回收器。它在达到高吞吐量时满足了GC停顿时间可预测这样的一个目标。在Oracle JDK 7 update4 及以后的版本被支持。G1收集器是为如下程序设计：</p><ul><li>垃圾收集于应用线程之间是并发的</li><li>紧凑的自由空间且没有较长的GC停顿时间</li><li>需要更可以预测的GC停顿时间</li><li>不想牺牲很多吞吐性能</li><li>不需要更大的Java堆</li></ul><p>G1计划被当作CMS的长期的替代品。相比CMS，很多不同把G1变成一个更好的解决方案。</p><ul><li>G1是一个压缩收集器，G1垃圾回收器依赖于区域（regions），避免使用空闲列表进行分配（avoid the use of fine-grained free lists for allocation）。这大大简化了垃圾回收器的各个部分，并消除了潜在的碎片问题</li><li>对比CMS，G1垃圾收集器提供更加可预测的GC停顿时间，并允许用户指定暂停的目标（and allows users to specify desired pause targets）</li></ul><h3 id="G1垃圾回收器概述"><a href="#G1垃圾回收器概述" class="headerlink" title="G1垃圾回收器概述"></a>G1垃圾回收器概述</h3><p>旧的老年代收集器（serial,parallel,CMS）把堆分成了三个部分，年轻代，年老代，永久代，并且永久代是固定的内存大小</p><p><img src="/images/HeapStructure.png" alt="HeapStructure.png"></p><p>所有内存对象都最终属于这三部分之一</p><p>G1垃圾收集器使用了不同的步骤</p><p><img src="/images/Slide9.png" alt="Slide9.png"></p><p>堆被分成了相等大小的内存区域，每一个都是连续虚拟内存。某些区域被集合被分配成于旧回收器同样的角色（eden,surivivor,old）但他们的大小并没有固定。这在内存使用方面提供了更大的灵活性。</p><p>当执行垃圾回收的时候，G1操作在某方面和CMS类似。G1执行并发的全局标记，以决定堆内存里对象的存活性。在标记阶段完成之后，G1知道了那一个内存区域（regions）几乎为空，它会首先收集这些区域，这样通常回收出较大空白内存。这也是为什么这种垃圾回收器被叫做Garbage-First。顾名思义，G1优先在充满垃圾对象内存区域执行收集和压缩行动。G1使用暂停预测模型来满足用户自定义的暂停时间目标，并且根据制定暂停时间目标选择收集的收集的区域。</p><p>由G1标识哪些区域充满垃圾对象，G1从一个或多个区域区域拷贝对象到一个堆内存区域，在这个过程中压缩并清理内存。这个过程是在多个处理器上执行的，用以减少暂停时间并增加吞吐量。因此每个垃圾收集，G1都在用户定义的暂停时间内连续的工作以减少内存碎片。这个超出了前面两种方法的能力。<strong>CMS垃圾回收器不会压缩ParallelOld垃圾回收器仅执行整个堆压缩，这导致相当长的停顿时间</strong></p><p>值得注意的是，G1不是一个实时的回收器。它有可能满足设定的目标时间，但不是绝对的。G1根据先前收集的数据，估算用户指定的目标时间可以收集多少区域。收集器有一个合理准确的垃圾收集模型，并使用此模型来确定要收集那些区域，同时stop-the-world暂停时间在用户指定的时间范围内。</p><p>注意：G1由并发（concurrent）（与应用程序一起运行，例如优化、标记、清理）和并行（parallel）（多线程）阶段。完整的垃圾回收仍然是单线程的，如果想调整jvm参数，您的应用程序应该避免fullGC。</p><h3 id="G1足迹"><a href="#G1足迹" class="headerlink" title="G1足迹"></a>G1足迹</h3><p>如果你从ParallelOldGC或者CMS改成G1，你可以观察到G1 jvm进程占用资源更大。这在很大程度上与“记账”数据结构有关，例如Remembered Sets 和 Collection Sets。</p><p><strong>Remembered Sets</strong> </p><p>Remembered Sets 或 Rset：将对象引用跟踪到给定区域中。堆中每个区域（region）有一个Rset。Rset可以并行和独立的收集一个区域的垃圾对象，Rset的对jvm占用内存大小不超过5%。</p><p><strong>Collection Sets</strong> </p><p>Collection Sets或 CSets：在一个GC过程中CSets是一种将被回收的区域集。在GC过程中，所有在CSet中活着的对象将要被移动、复制。区域集合可以是Eden、survivor或者是年老代。CSet堆jvm内存占用大小不超过1%</p><h3 id="G1的推荐用例"><a href="#G1的推荐用例" class="headerlink" title="G1的推荐用例"></a>G1的推荐用例</h3><p>G1的首要重点是为运行需要大堆且GC延迟有限的应用程序的用户提供解决方案。 这意味着堆大小约为6GB或更大，并且稳定且可预测的暂停时间低于0.5秒。</p><p>如果当前具有CMS或ParallelOldGC垃圾收集器的应用程序具有以下一个或多个特征，则将其切换到G1很有用。</p><ul><li>完整的GC持续时间太长或太频繁。</li><li>对象分配率或提升率差异很大。</li><li>不必要的长时间垃圾收集或压缩暂停（长于0.5到1秒）</li></ul><p>注意：如果您使用的是CMS或ParallelOldGC，并且您的应用程序未经历长时间的垃圾收集暂停，则可以继续使用当前的收集器。 使用最新的JDK不需要更改为G1收集器。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-G1垃圾回收器2</title>
      <link href="/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/"/>
      <url>/2021/03/05/%E6%A6%82%E5%BF%B5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A82/</url>
      
        <content type="html"><![CDATA[<p>G1收集器采用了另一种分配堆的方法。 后面的图片逐步检查了G1系统。</p><h3 id="G1堆结构"><a href="#G1堆结构" class="headerlink" title="G1堆结构"></a>G1堆结构</h3><p>G1堆事一个内存区域被切分为多个相同大小的区域（regions）</p><p><img src="/images/Slide8.png" alt="Slide8.png"></p><p>区域大小是在jvm一启动就被选择的。JVM通常会生成两千个区域，每个区域大小相同，在1到32MB之间</p><h3 id="G1堆分配"><a href="#G1堆分配" class="headerlink" title="G1堆分配"></a>G1堆分配</h3><p>事实上，这些区域被映射成Eden、Survivor和年老代</p><p><img src="/images/G1-Slide9.png" alt="G1-Slide9.png"></p><p>图片中的颜色显示了哪个区域与哪个角色相关联。 将活动对象从一个区域撤离（即复制或移动）到另一个区域。 区域被设计为并行或不停止其他应用程序线程的情况下并行垃圾收集。</p><p>如图所示，区域被分成Eden、Suivivor和年老代。此外还有第四种巨大区域。这些区域被设计成存放大于标准区域50%的对象。他们被一个连续集合区域进行存储。最后一种区域是堆未使用区域。</p><p>注意：在撰写本文时，尚未优化庞大对象的过程。因此应避免创建这种大小的对象。</p><h3 id="G1年轻代"><a href="#G1年轻代" class="headerlink" title="G1年轻代"></a>G1年轻代</h3><p>年轻代堆被分成了大概两千个区域，区域大小在1MB到32MB之间。蓝色区域存储年老代对象，绿色区域存储年轻代对象。</p><p><img src="/images/G1-Slide10.png" alt="G1-Slide10.png"></p><p>注意：这些区域不需要像旧的垃圾收集器一样是内存连续的</p><h3 id="G1的一次Young-GC"><a href="#G1的一次Young-GC" class="headerlink" title="G1的一次Young GC"></a>G1的一次Young GC</h3><p>存活的对象撤离（移动或者拷贝）一个或者多个存活区域，如果年龄阈值满足，一些对象会被提升到年老代区域。</p><p><img src="/images/G1-Slide11.png" alt="G1-Slide11.png"></p><p>这是一次stop-the-world的暂停。Eden大小和survivor大小在下一次yongGC被计算。“计票”（accounting）信息被保存用来帮助计算这些区域的大小。诸如暂停时间目标之类的事情也要考虑在内。</p><p>这种方法使调整区域大小变得非常容易，可以根据需要增大或缩小区域。</p><h3 id="G1的YoungGC结束"><a href="#G1的YoungGC结束" class="headerlink" title="G1的YoungGC结束"></a>G1的YoungGC结束</h3><p>存活的对象已经“撤离”到survivor区域或者年老代区域。</p><p><img src="/images/G1-Slide12.png" alt="G1-Slide12.png"></p><p>最近提升对象用dark blue表示，survivor区域时绿色。</p><p>关于G1，总结如下：</p><ol><li>堆是一整个内存被切分成区域</li><li>年轻代由一组不连续的区域组成，这使得改变区域大小非常容易</li><li>年轻代垃圾回收或者yong GC会stop-the-world，所有的应用线程都会被停止。(Young generation garbage collections, or young GCs, are stop the world events. All application threads are stopped for the operation.)</li><li>年轻的GC使用多个线程并行完成。</li><li>将活动对象复制到新的幸存者或较旧的地区。</li></ol><h3 id="G1年老代的垃圾收集"><a href="#G1年老代的垃圾收集" class="headerlink" title="G1年老代的垃圾收集"></a>G1年老代的垃圾收集</h3><p>像CMS收集器一样，G1收集器被设计为用于旧对象的低暂停收集器。 下表描述了旧版本的G1收集阶段。</p><h4 id="G1收集阶段-并发标记周期阶段"><a href="#G1收集阶段-并发标记周期阶段" class="headerlink" title="G1收集阶段-并发标记周期阶段"></a>G1收集阶段-并发标记周期阶段</h4><p>G1收集器在老年代上执行以下阶段。 请注意，某些阶段是年轻一代收集的一部分。</p><table><thead><tr><th>Phase</th><th>Description</th></tr></thead><tbody><tr><td>(1) 初始标记 <em>(Stop the World Event)</em></td><td>这会stop-the-world。 对于G1来说, 它可以像普通young GC一样执行。标记survivor区域(root regions) ，因为这些区域可能引用了老年代对象。</td></tr><tr><td>(2) 根区域扫描</td><td>扫描survivor区域来获得年老代的参考（Scan survivor regions for references into the old generation），当程序在运行时会发生这种情况。这个阶段必须完成之后fullGC才能发生。</td></tr><tr><td>(3) 并发标记</td><td>在堆中查找活动对象，在应用运行时候发生，。这个阶段可以被Young GC打断。</td></tr><tr><td>(4) 重新标记(Stop the World Event)</td><td>完成堆中存活对象的标记。使用一个叫snapshot-at-the-beginning (SATB)的算法要比CMS用的算法要快的多。</td></tr><tr><td>(5) 清除 <em>(Stop the World Event and Concurrent)</em></td><td>对活动对象进行计数（accounting）和并完全清空区域。 （停止世界）<br/>清除RememberSet（RSet）。 （停止世界）<br/>重置空区域并将他们返回到空闲列表。 （并发）</td></tr><tr><td>(*) Copying <em>(Stop the World Event)</em></td><td>这些操作会stop-the-world 以保证活着的对象撤离到新的未使用的区域。该操作可以被记录为[GC pause(young)]。或者年轻、年老代区域被标记为[GC pause (mixed)].</td></tr></tbody></table><h3 id="G1老年代垃圾收集详解"><a href="#G1老年代垃圾收集详解" class="headerlink" title="G1老年代垃圾收集详解"></a>G1老年代垃圾收集详解</h3><p>在定义了阶段之后，让我们看一下，他们如何与G1收集器中的旧版本就行交互。</p><h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h4><p>初始标记对象，在年轻代被执行。在日志中被记录为GC pause (young)(inital-mark).</p><p><img src="/images/G1-Slide13.png" alt="G1-Slide13.png"></p><h4 id="并发标记阶段"><a href="#并发标记阶段" class="headerlink" title="并发标记阶段"></a>并发标记阶段</h4><p>如果空的区域被找到，他们在重新标记阶段会被立即移除。并且，计数（acounting）信息会决定存活度计算结果。</p><p><img src="/images/G1-Slide14.png" alt="G1-Slide14.png"></p><h4 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h4><p>空区域被删除并回收，并且在这阶段会计算所有区域的区域存活度（Region liveness ）。</p><p><img src="/images/G1-Slide15.png" alt="G1-Slide15.png"></p><h4 id="拷贝-x2F-清除阶段"><a href="#拷贝-x2F-清除阶段" class="headerlink" title="拷贝&#x2F;清除阶段"></a>拷贝&#x2F;清除阶段</h4><p>G1选择“存活度”(liveness)最低的区域，这些区域可以以最快速度被收集。这些区域在执行young GC时候被收集。在日志中被记录为[GC pause (mixed)]。所以年轻代和年老代可以被同时收集。</p><h4 id="拷贝-x2F-清除阶段之后"><a href="#拷贝-x2F-清除阶段之后" class="headerlink" title="拷贝&#x2F;清除阶段之后"></a>拷贝&#x2F;清除阶段之后</h4><p>选定的区域被收集且被压缩，在图中分别用深蓝色和深绿色所表示</p><p><img src="/images/G1-Slide17.png" alt="G1-Slide17.png"></p><h3 id="G1年老代总结"><a href="#G1年老代总结" class="headerlink" title="G1年老代总结"></a>G1年老代总结</h3><p>总而言之，关于旧一代的G1垃圾回收，我们可以提出一些关键点:</p><ul><li>并发标记阶段<ul><li>活跃度信息是在应用线程运行的被并行计算的</li><li>在活着的对象“撤离”时间段内，并且这些区域即将被回收，在这个时候定义活跃度信息。</li></ul></li><li>并发标记阶段<ul><li>使用SATB算法，该算法比CMS使用的算法快得多。</li><li>完全为空的区域将被回收</li></ul></li><li>拷贝清理阶段<ul><li>年轻代年老代可以同时执行回收操作</li><li>年老代区域基于它们的活跃度被选择是否回收</li></ul></li></ul><p><strong>剩下的日志查看还没有翻译</strong></p><h4 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h4><p><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-Spring源码</title>
      <link href="/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/"/>
      <url>/2021/03/05/%E6%A6%82%E5%BF%B5-Spring%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="聊聊Spring"><a href="#聊聊Spring" class="headerlink" title="聊聊Spring"></a>聊聊Spring</h2><ol><li>控制反转思想IOC</li><li>依赖注入AOP</li><li>bean的生命周期</li><li>循环依赖</li><li>三级缓存</li><li>FactoryBean和BeanFactory区别</li><li>ApplicationContxt和BeanFactory区别</li><li>Spring中的设计模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-B树和B+树</title>
      <link href="/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/"/>
      <url>/2021/03/03/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点</p><ol><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li><li>子节点数：非叶节点的子节点数&gt;1，且&lt;&#x3D;M ，且M&gt;&#x3D;2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M&#x3D;M路,当M&#x3D;2则是2叉树,M&#x3D;3则是3叉）；</li><li>关键字数：枝节点的关键字数量大于等于ceil(m&#x2F;2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li></ol><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="/images/BTree.png" alt="img"></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p><h2 id="B树和B-树区别"><a href="#B树和B-树区别" class="headerlink" title="B树和B+树区别"></a>B树和B+树区别</h2><ol><li>B+树的非叶子节点不保存键值对应的数据，这样使得B+树每个节点所能保存的键值大大增加；</li><li>B+树叶子节点保存了父节点的所有键值和键值对应的数据，每个叶子节点的键值从小到大链接；</li><li>非叶子节点的子节点数&#x3D;关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数&#x3D;子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</li><li>B+的非叶子节点只进行数据索引，不会存实际的键值对应的数据，所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</li></ol><p><img src="/images/B+Tree.png" alt="img"></p><blockquote><h4 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h4><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1&#x2F;120&#x2F;2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 &#x3D; 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-Mysql索引面试题</title>
      <link href="/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/03/03/%E6%A6%82%E5%BF%B5-Mysql%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="hash索引和B-Tree索引区别"><a href="#hash索引和B-Tree索引区别" class="headerlink" title="hash索引和B+Tree索引区别"></a>hash索引和B+Tree索引区别</h2><ol><li>hash索引只适合等值查询，无法进行范围查询</li><li>存在大量键值重复时候，hash索引效率很低</li><li>hash索引无法利用索引进行排序</li><li>hash索引无法利用联合索引做前缀匹配原则</li></ol><h2 id="B-Tree叶子节点能存储哪些东西"><a href="#B-Tree叶子节点能存储哪些东西" class="headerlink" title="B+Tree叶子节点能存储哪些东西"></a>B+Tree叶子节点能存储哪些东西</h2><p>可以存储整行数据或者是主键索引值，当存储整行数据时候为主键索引，存储主键索引时候是非主键索引。非主键索引在进行查询时候需要先寻找主键索引，根据主键索引获取需要的数据，这个查询两次的过程叫做回表。非主键索引中的联合索引可以通过做前缀原则实现覆盖索引的效果</p><h2 id="创建联合索引的时候，如何选择联合索引的字段顺序"><a href="#创建联合索引的时候，如何选择联合索引的字段顺序" class="headerlink" title="创建联合索引的时候，如何选择联合索引的字段顺序"></a>创建联合索引的时候，如何选择联合索引的字段顺序</h2><p>创建联合索引需要考虑联合索引字段的顺序，where子句中使用最频繁的一列放在最左边。比如我们创建了联合索引idx_k1_k2_k3(key1,key2,key3)三个索引相当于创建了idx(key1,key2,key3) idx(key1,key2) idx(key1)三个索引。</p><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>平衡二叉树查找效率确实很高，但是频繁的IO才是阻碍提高性能的瓶颈，怎样减少IO次数呢？前辈们很聪明的提出了局部性原理，分为时间局部性原理和空间局部性原理</p><p>时间局部性原理：即假如你查询id为1的用户数据，过一段时间你还会查询id为1的数据，所以会将这部分数据缓存下来。</p><p>空间局部性原理：当你查询id为1的用户数据的时候，你有很大的概率会去查询id为2，3，4的用户的数据，所以会一次性的把id为1，2，3，4的数据都读到内存中去，这个最小的单位就是页。页大小是由linux系统决定的，4k或者8k</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="/2021/03/02/%E6%A6%82%E5%BF%B5-B%E6%A0%91%E5%92%8CB+%E6%A0%91/">B树和B+树</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-书写高质量SQL的若干建议</title>
      <link href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/"/>
      <url>/2021/03/03/%E6%A6%82%E5%BF%B5-%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>表结构：（有一个联合索引idx_userid_age，userId在前，age在后）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `userId` int(11) NOT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_userid_age` (`userId`,`age`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="建议1"><a href="#建议1" class="headerlink" title="建议1"></a>建议1</h2><p>查询SQL尽量不要使用select *，而是select具体字段</p><p>理由：</p><ol><li><p>只取需要的字段，节省资源、减少网络开销。</p></li><li><p>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</p></li></ol><h2 id="建议2"><a href="#建议2" class="headerlink" title="建议2"></a>建议2</h2><p>优化limit分页</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id，name，age from employee limit 10000，10</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//方案一 ：返回上次查询的最大记录(偏移量)</span><br><span class="line">select id，name from employee where id&gt;10000 limit 10.</span><br><span class="line"></span><br><span class="line">//方案二：order by + 索引， id是主键索引</span><br><span class="line">select id，name from employee order by id  limit 10000，10</span><br><span class="line"></span><br><span class="line">//方案三：在业务允许的情况下限制页数：</span><br></pre></td></tr></table></figure><h2 id="建议3"><a href="#建议3" class="headerlink" title="建议3"></a>建议3</h2><p>优化like语句</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId，name from user where userId like &#x27;%123&#x27;;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select userId，name from user where userId like &#x27;123%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="建议4"><a href="#建议4" class="headerlink" title="建议4"></a>建议4</h2><p>尽量避免在索引列上使用mysql的内置函数</p><p>业务需求：查询最近七天内登陆过的用户(假设loginTime加了索引)</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select userId,loginTime from loginuser where Date_ADD(loginTime,Interval 7 DAY) &gt;=now();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain  select userId,loginTime from loginuser where  loginTime &gt;= Date_ADD(NOW(),INTERVAL - 7 DAY);</span><br></pre></td></tr></table></figure><h2 id="建议5"><a href="#建议5" class="headerlink" title="建议5"></a>建议5</h2><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age-1 =10；</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age =11；</span><br></pre></td></tr></table></figure><h2 id="建议6"><a href="#建议6" class="headerlink" title="建议6"></a>建议6</h2><p>Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</p><blockquote><p>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</p><p>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</p><p>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</p></blockquote><h2 id="建议7"><a href="#建议7" class="headerlink" title="建议7"></a>建议7</h2><p>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select age,name  from user where age &lt;&gt;18;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//可以考虑分开两条sql写</span><br><span class="line">select age,name  from user where age &lt;18;</span><br><span class="line">select age,name  from user where age &gt;18;</span><br></pre></td></tr></table></figure><h2 id="建议8"><a href="#建议8" class="headerlink" title="建议8"></a>建议8</h2><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age = 10;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//符合最左匹配原则</span><br><span class="line">select * from user where userid=10 and age =10；</span><br><span class="line">//符合最左匹配原则</span><br><span class="line">select * from user where userid =10;</span><br></pre></td></tr></table></figure><h2 id="建议9"><a href="#建议9" class="headerlink" title="建议9"></a>建议9</h2><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where address =&#x27;深圳&#x27; order by age ;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_no_idx.png" alt="img"></p><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table user add index idx_address_age (address,age)</span><br><span class="line">select * from user where address =&#x27;深圳&#x27; order by age ;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_add_idx.png" alt="img"></p><h2 id="建议10"><a href="#建议10" class="headerlink" title="建议10"></a>建议10</h2><p>在适当的时候，使用覆盖索引</p><p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// like模糊查询，不走索引了</span><br><span class="line">select * from user where userid like &#x27;%123%&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/combine_idx1.png" alt="img"></p><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//id为主键，那么为普通索引，即覆盖索引登场了。</span><br><span class="line">select id,name from user where userid like &#x27;%123%&#x27;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/combine_idx2.png" alt="img"></p><h2 id="建议11"><a href="#建议11" class="headerlink" title="建议11"></a>建议11</h2><p>删除冗余和重复索引</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEY `idx_userId` (`userId`)  </span><br><span class="line">KEY `idx_userId_age` (`userId`,`age`)</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引</span><br><span class="line">KEY `idx_userId_age` (`userId`,`age`)</span><br></pre></td></tr></table></figure><h2 id="建议12"><a href="#建议12" class="headerlink" title="建议12"></a>建议12</h2><p>where子句中考虑使用默认值代替null</p><p>反例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where age is not null;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_idex_default_num1.png" alt="img"></p><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//设置0为默认值</span><br><span class="line">select * from user where age&gt;0;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/images/mysql_suggest_idex_default_num2.png" alt="img"></p><p>理由：</p><p>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</p><blockquote><p>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件<code>！=，&gt;is null，is not null</code>经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。</p></blockquote><p>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-基本数据类型</title>
      <link href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/03/03/%E6%A6%82%E5%BF%B5-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本数据类型枚举"><a href="#基本数据类型枚举" class="headerlink" title="基本数据类型枚举"></a>基本数据类型枚举</h3><ol><li>数字类型：byte，short，int，long</li><li>浮点型：float，double</li><li>布尔类型：boolean</li><li>字符型：char</li></ol><p>计算机内存的最小存储单元是字节（byte），<strong>一个字节就是一个8位二进制数，即8个bit</strong>。它的二进制表示范围从<code>00000000~11111111</code>，换算成十进制是<code>0～255</code>，换算成十六进制是<code>00 ~ ff</code>。其中最高位是符号位，所以数据范围是<code>-128～127</code>，即<code>-2^7～2^8 - 1</code></p><p>一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。</p><h3 id="每个字节占大小"><a href="#每个字节占大小" class="headerlink" title="每个字节占大小"></a>每个字节占大小</h3><p>不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：</p><p>以下一个方块代表一个字节（byte），一个字节有8位（bits），所以byte大小是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">  byte │   │</span><br><span class="line">       └───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line"> short │   │   │</span><br><span class="line">       └───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line">   int │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">  long │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line"> float │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">double │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line">  char │   │   │</span><br><span class="line">       └───┴───┘</span><br></pre></td></tr></table></figure><p><code>byte</code>恰好就是一个字节，而<code>long</code>和<code>double</code>需要8个字节。</p><h3 id="32位JVM和64位JVM基本类型大小区别"><a href="#32位JVM和64位JVM基本类型大小区别" class="headerlink" title="32位JVM和64位JVM基本类型大小区别"></a>32位JVM和64位JVM基本类型大小区别</h3><p>那么问题来了32位jvm和64位jvm各个基本类型所占用字节数相同吗？</p><p>下面是32位系统与64位系统各数据类型对比：除了*与long随操作系统子长变化而变化外，其他的都固定不变(32位和64位相比)</p><table><thead><tr><th>数据类型</th><th>说明</th><th>32位字节数</th><th>64位字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>bool</td><td>布尔型</td><td>1</td><td>1</td><td>true，false</td></tr><tr><td>char</td><td>字符型</td><td>1</td><td>1</td><td>-128~127</td></tr><tr><td>unsigned char</td><td>无符号字符型</td><td>1</td><td>1</td><td>0~255</td></tr><tr><td>short</td><td>短整型</td><td>2</td><td>2</td><td>-32768~32767</td></tr><tr><td>unsigned short</td><td>无符号短整型</td><td>2</td><td>2</td><td>0~65535</td></tr><tr><td>int</td><td>整型</td><td>4</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned int</td><td>无符号整型</td><td>4</td><td>4</td><td>0~4294967295</td></tr><tr><td><strong>long</strong></td><td><strong>长整型</strong></td><td><strong>4</strong></td><td><strong>8</strong></td><td><strong>–</strong></td></tr><tr><td><strong>unsigned long</strong></td><td><strong>无符号长整型</strong></td><td><strong>4</strong></td><td><strong>8</strong></td><td><strong>–</strong></td></tr><tr><td>long long</td><td>长整型</td><td>8</td><td>8</td><td>-2^64~2^64-1</td></tr><tr><td>float</td><td>单精度浮点数</td><td>4</td><td>4</td><td>范围-2^128<del>2^128精度为6</del>7位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>8</td><td>8</td><td>范围-2^1024<del>2^1024精度为15</del>16位</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>8</td><td>8</td><td>范围-2^1024<del>2^1024精度为15</del>16位</td></tr><tr><td>*</td><td>地址</td><td>4</td><td>8</td><td>-</td></tr></tbody></table><h3 id="对于long和double的特殊规则"><a href="#对于long和double的特殊规则" class="headerlink" title="对于long和double的特殊规则"></a>对于long和double的特殊规则</h3><p>考虑到Java语言的内存模型，对非volatile的long或double的单个写操作会当成两个分离的写操作进行处理，每个操作处理32位。这会导致这样的情况：一个线程会看到由某个写操作写入的64位值的头32位和由另一个写操作写入的后32位。</p><p>对volatile的long和double值读操作和写操作总是原子性的。</p><p>对引用的读操作和写操作总是原子行的。</p><p><strong>所以我们鼓励程序员将共享的64位声明称volatile的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-面试题整理</title>
      <link href="/2021/03/03/%E6%A6%82%E5%BF%B5-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2021/03/03/%E6%A6%82%E5%BF%B5-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="hash索引和b-tree索引区别"><a href="#hash索引和b-tree索引区别" class="headerlink" title="hash索引和b+tree索引区别"></a>hash索引和b+tree索引区别</h4><p>hash索引只能等值查询，无法进行范围查询<br>hash索引无法索引自动排序<br>hash索引键值重复严重效率变得很低<br>hash索引无法使用做匹配前缀原则</p><h4 id="B-Tree数据叶子结点数据存储"><a href="#B-Tree数据叶子结点数据存储" class="headerlink" title="B+Tree数据叶子结点数据存储"></a>B+Tree数据叶子结点数据存储</h4><p>B+Tree叶子节点可以存储整行的数据，也可以存储主键索引。存储整行数据表示是主键索引。存储主键索引值表示是非主键索引。非主键索引查找数据需要先找到主键索引再根据主键索引查询数据。这个过程叫做回表。覆盖索引查询数据不需要回表。联合索引就是覆盖索引的一种。比如建了一个联合索引index(key1,key2,key3)，那么可以同时有三种索引，分别是index(key1), index(key1,key2)和index(key1,key2,key3)。创建联合索引需要注意字段顺序，排顺序的规则是where子句中最常用字段放在前面。</p><h4 id="G1与CMS区别"><a href="#G1与CMS区别" class="headerlink" title="G1与CMS区别"></a>G1与CMS区别</h4><ol><li>CMS只适合年老代，因为CMS只有在fullGC时候会压缩内存。新生代产生无法接受该算法产生的碎片垃圾。</li><li>G1适合年老代同时适合年轻代，它会把存活的数据从一个区域复制到另一个区域并且进行压缩，没有内存碎片。因为G1是基于区域的，会记录那个区域活跃度更低，会把活跃度低的放到一个集合里。回收的时候根据用户设置的期望停顿时间来决定回收哪些区域</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念-String为什么被设计为不可变的</title>
      <link href="/2021/03/02/%E6%A6%82%E5%BF%B5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/"/>
      <url>/2021/03/02/%E6%A6%82%E5%BF%B5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><img src="/images/string_pool.png" alt="img"></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-回文链表</title>
      <link href="/2021/03/02/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/03/02/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/images/isPalindrome.png" alt="isPalindrome"></p><p>这个题用链表方式可以实现，但效率很低</p><p>因为是回文链表，使用快慢指针，每次循环让fast走两步，slow走一步</p><p>反转后半段链表，反转起始节点为当前slow节点</p><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fast结束时候slow在中间</span></span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="literal">null</span> &amp;&amp; fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转后半段</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="literal">null</span> &amp;&amp; head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newHead.val != head.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            newHead = newHead.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode newHead)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseList(tmp, newHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-反转链表</title>
      <link href="/2021/03/01/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/03/01/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><img src="/images/reverseList.png" alt="反转链表"></p><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><p>迭代解法</p><ol><li>3和4 ：反转节点</li><li>1、2:   后移旧头节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        head.next = newHead; <span class="comment">// 3</span></span><br><span class="line">        newHead = head;      <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        head = tmp; <span class="comment">// 2 后移head节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在迭代解法的基础上可以衍生出其递归解法</p><ol><li>结束条件是：当头节点遍历到末尾，且为空时，返回newHead</li><li>1、2步是遍历所有节点操作</li><li>3、4步是将head.next指向前一个节点（newHead），并将newHead后移一位（newHead &#x3D; head; ）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode newHead)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head.next;          <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        head.next = newHead;               <span class="comment">// 3</span></span><br><span class="line">        newHead = head;   <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseList(tmp, newHead);  <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上可以解决<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/">面试题 02.06. 回文链表</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-两数、三数之和</title>
      <link href="/2021/02/28/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%92%8C%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/02/28/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E5%92%8C%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><ol><li>两数之和的话需要遍历两次</li><li>条件是nums[i] + nums[j] &#x3D;&#x3D; target</li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    arr[<span class="number">0</span>] = i;</span><br><span class="line">                    arr[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TwoSum</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoSum</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = t.twoSum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;, <span class="number">9</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><img src="/images/threeSum.png" alt="三数之和"></p><ol><li>因为leetcode测试用例比较大，使用三次遍历会有超时问题，所以我们需要使用排序 + 二分查找优化查询</li><li>其中寻找的第三个值为前两个相加值的负数</li><li>二分查找第三个值时候low位置的值应该是j+1，避免返回重复值</li><li>二分查找第三个值时候high位置需要避免最后一位出现多次问题，我这里是在第二个循环上限制 <strong>j&lt;nums.length-1</strong>，避免出现在[-4,-1,0,1,1,2]中出现[-4，2，2]这种情况</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; arr = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> -(nums[i] + nums[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(nums, target, j+<span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">                    addNewElement(arr, nums[i], nums[j], nums[index]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, pIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pIndex; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[pivot]) &#123;</span><br><span class="line">                swap(nums, i, pIndex);</span><br><span class="line">                pIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, pivot, pIndex - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> high;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (h + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                h = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNewElement</span><span class="params">(Set&lt;List&lt;Integer&gt;&gt; arr, <span class="type">int</span> num, <span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        a.add(num);</span><br><span class="line">        a.add(num1);</span><br><span class="line">        a.add(num2);</span><br><span class="line">        arr.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树的镜像</title>
      <link href="/2021/02/24/%E7%AE%97%E6%B3%95-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2021/02/24/%E7%AE%97%E6%B3%95-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p><img src="/images/mirrorTree.png" alt="二叉树的镜像"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ol><li><p>递归结束条件：root为空返回true</p></li><li><p>递归每层做什么：前序遍历所有节点，并交换left和right节点</p></li><li><p>递归返回：当前root节点</p></li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(root);</span><br><span class="line"></span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树的最近公共祖先</title>
      <link href="/2021/02/19/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2021/02/19/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p><img src="/images/lowestCommonAncestor.png" alt="isBalanceTree"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ol><li>递归结束条件：返回节点为空时结束递归</li><li>根据题目可以得知p、q节点分布存在三种情况：<ol><li>p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先（即根节点root）</li><li>p q 都在左子树 （先被找到的即为最近父节点）</li><li>p q 都在右子树</li></ol></li><li>递归返回：无返回</li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的最近公共祖先</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     * 三种情况：</span></span><br><span class="line"><span class="comment">     * 1、p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先</span></span><br><span class="line"><span class="comment">     * 2、p q 都在左子树 </span></span><br><span class="line"><span class="comment">     * 3、p q 都在右子树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p q 一个在左，一个在右</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p q 都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p q 都在右子树</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树的最近公共祖先</title>
      <link href="/2021/02/19/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACdouble/"/>
      <url>/2021/02/19/%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACdouble/</url>
      
        <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>输入字符串转成double数字</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ol><li>字符串是否为空</li><li>字符串是否包含非数字</li><li>字符串是否包含正负号</li><li>是否超过double最大值</li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">parseDouble</span><span class="params">(String n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">isNegative</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">numStr</span> <span class="operator">=</span> n.trim();</span><br><span class="line">        <span class="keyword">if</span> (numStr == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0D</span>;</span><br><span class="line">        <span class="keyword">if</span> (numStr.length() &gt; <span class="number">0</span> &amp;&amp; numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            isNegative = -<span class="number">1</span>;</span><br><span class="line">            numStr = numStr.substring(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numStr.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            numStr = numStr.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!numStr.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) getHighPosNum(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] arr = numStr.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sumHigh</span> <span class="operator">=</span> getHighPosNum(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sumLow</span> <span class="operator">=</span> getLowPosNum(arr[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isNegative * (sumLow + sumHigh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getHighPosNum</span><span class="params">(String highStr1)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sumHigh</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">highStr</span> <span class="operator">=</span> highStr1;</span><br><span class="line">        <span class="type">char</span>[] highChars = highStr.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] highIntNums = <span class="keyword">new</span> <span class="title class_">int</span>[highChars.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highIntNums.length; i++) &#123;</span><br><span class="line">            sumHigh += Math.pow(<span class="number">10</span>, highIntNums.length - <span class="number">1</span> - i) * isDigit(highChars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumHigh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">char</span> highChar)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(highChar)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumberFormatException</span>(<span class="string">&quot;非法数字&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) highChar - (<span class="type">int</span>) <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">getLowPosNum</span><span class="params">(String lowStr1)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sumLow</span> <span class="operator">=</span> <span class="number">0D</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lowStr</span> <span class="operator">=</span> lowStr1;</span><br><span class="line">        <span class="type">char</span>[] lowChars = lowStr.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] lowIntNums = <span class="keyword">new</span> <span class="title class_">int</span>[lowChars.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lowIntNums.length; i++) &#123;</span><br><span class="line">            sumLow += Math.pow(<span class="number">10</span>, -<span class="number">1</span> * (i + <span class="number">1</span>)) * (isDigit(lowChars[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumLow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> s.parseDouble(<span class="string">&quot;-1.456&quot;</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树的最近公共祖先</title>
      <link href="/2021/02/19/%E7%AE%97%E6%B3%95-%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/19/%E7%AE%97%E6%B3%95-%E6%9E%84%E5%BB%BA%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">https://leetcode-cn.com/problems/maximum-binary-tree/</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ol><li><p>二叉树的根是数组 nums 中的最大元素（写一个函数获取当前数组中的最大index）</p></li><li><p>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</p><p>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</p><p>写一个函数用来返回</p></li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.tree.TreeNode;</span><br><span class="line"><span class="keyword">import</span> com.code.note.util.BTreePrinter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(Integer[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findMaxIndex(nums, start, end);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[index]);</span><br><span class="line">        t.left = helper(nums, start, index - <span class="number">1</span>);</span><br><span class="line">        t.right = helper(nums, index + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxIndex</span><span class="params">(Integer[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bigIndex</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[bigIndex]) &#123;</span><br><span class="line">                bigIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bigIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        Integer[] arr1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> s.constructMaximumBinaryTree(arr1);</span><br><span class="line">        BTreePrinter.printNode(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉搜索树第K大节点值</title>
      <link href="/2021/02/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%E5%80%BC/"/>
      <url>/2021/02/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p><img src="/images/kthLargestVal.png" alt="isBalanceTree"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>为什么在中序遍历时候更改cnt值？大概是因<strong>二叉搜索树的中序遍历是有序的</strong></p><ol><li>递归结束条件：当x节点为空时结束递归</li><li>递归每层做什么：right -&gt; mid -&gt; left 依次访问，在中序遍历修改cnt值，当++cnt &#x3D;&#x3D; k时记录val并结束遍历</li><li>递归返回：无返回</li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans, cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kthLargestNode(root, k);</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kthLargestNode</span><span class="params">(TreeNode x, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kthLargestNode(x.right, k);</span><br><span class="line">    <span class="keyword">if</span> (++cnt == k) &#123;</span><br><span class="line">        ans = (<span class="type">int</span>) x.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kthLargestNode(x.left, k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然根据根据中序遍历的有序性，遍历所有k个大的数并返回最后一个元素即为第K个大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest2</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kthLargestNode2(root, k);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> kthLargestValList.get(k - <span class="number">1</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树特点：中序遍历是有序的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kthLargestNode2</span><span class="params">(TreeNode x, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kthLargestNode2(x.right, k);</span><br><span class="line">    kthLargestValList.add((Integer) x.val);</span><br><span class="line">    <span class="keyword">if</span> (kthLargestValList.size() == k) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    kthLargestNode2(x.left, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-平衡二叉树</title>
      <link href="/2021/02/14/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/14/%E7%AE%97%E6%B3%95-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><h4 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h4><p><img src="/images/isBalanceTree.png" alt="isBalanceTree"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><strong>左右子树高度差大于1返回false，这个需要递归到每一层</strong></p><ol><li><p>递归结束条件：root为空返回true，左右子树高度差值大于1返回false</p></li><li><p>递归每层做什么：计算左树、右树高度</p></li><li><p>递归返回：高度值</p></li></ol><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> getDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(l - r) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(getDepth(x.left), getDepth(x.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-是否是对称二叉树</title>
      <link href="/2021/02/14/%E7%AE%97%E6%B3%95-%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/14/%E7%AE%97%E6%B3%95-%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><img src="/images/isMirriorBTree.png" alt="Screen Shot 2021-02-12 at 15.03.27"></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>递归的难点在于：找到可以递归的点 为什么很多人觉得递归一看就会，一写就废。 或者说是自己写无法写出来，关键就是你对递归理解的深不深。</p><p>对于此题： 递归的点怎么找？从拿到题的第一时间开始，思路如下：</p><p>1.怎么判断一棵树是不是对称二叉树？ 答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对称时，他对称</p><p>2.那么怎么知道左子树与右子树对不对称呢？在这我直接叫为左树和右树 答案：如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称。</p><p>仔细读这句话，是不是有点绕？怎么感觉有一个功能A我想实现，但我去实现A的时候又要用到A实现后的功能呢？</p><p>当你思考到这里的时候，递归点已经出现了： 递归点：我在尝试判断左树与右树对称的条件时，发现其跟两树的孩子的对称情况有关系。</p><p>想到这里，你不必有太多疑问，上手去按思路写代码，函数A（左树，右树）功能是返回是否对称</p><p>def 函数A（左树，右树）： 左树节点值等于右树节点值 且 函数A（左树的左子树，右树的右子树），函数A（左树的右子树，右树的左子树）均为真 才返回真</p><p>实现完毕。。。</p><p>写着写着。。。你就发现你写出来了。。。。。。</p><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为对称树树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode l, TreeNode r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span> &amp;&amp; r == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span> || r == <span class="literal">null</span> || l.val != r.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> isSymmetric(l.left, r.right);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> isSymmetric(l.right, r.left);</span><br><span class="line">    <span class="keyword">return</span> flag1 &amp;&amp; flag2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-合并二叉树</title>
      <link href="/2021/02/12/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/02/12/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><img src="/images/mergeTrees.png" alt="Screen Shot 2021-02-12 at 15.03.27"></p><p>这道题其实就是把二叉树每个节点的值相加，并放到新的二叉树节点，如果某棵树当前节点为空，他的value值是0</p><p>其实这个题主要考察的是二叉树遍历，只不过需要同时遍历两棵树，二叉树遍历代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">walk</span><span class="params">(Node x)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(x.value);</span><br><span class="line">    x.left = walk(x.left);</span><br><span class="line">    x.right = walk(x.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><ol><li><p>结束条件：当两个数节点都为空，结束当前递归</p></li><li><p>每层递归做了什么：计算两个val相加（需要判空），根据该值生成新的节点</p></li><li><p>每层递归返回什么：返回上次计算接Node引用</p></li></ol><p>整体代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> t1 == <span class="literal">null</span> ?  <span class="number">0</span> : t1.val ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> t2 == <span class="literal">null</span> ?  <span class="number">0</span> :t2.val ;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> val1 + val2;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        node.left = mergeTrees(t1 == <span class="literal">null</span> ? <span class="literal">null</span> : t1.left, t2 == <span class="literal">null</span> ? <span class="literal">null</span> : t2.left);</span><br><span class="line">        node.right = mergeTrees(t1 == <span class="literal">null</span>? <span class="literal">null</span> : t1.right,t2 == <span class="literal">null</span> ? <span class="literal">null</span> : t2.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会写递归？如何写递归文章地址：</p><p><a href="https://lyl0724.github.io/2020/01/25/1/">https://lyl0724.github.io/2020/01/25/1/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis拼装复杂条件sql</title>
      <link href="/2021/01/27/Mybatis-%E6%8B%BC%E8%A3%85%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6sql/"/>
      <url>/2021/01/27/Mybatis-%E6%8B%BC%E8%A3%85%E5%A4%8D%E6%9D%82%E6%9D%A1%E4%BB%B6sql/</url>
      
        <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>因为mybatis不好拼装如下sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> doc_id,encourage_card_id </span><br><span class="line"><span class="keyword">from</span> encourage_card_quantitative_fake_progress </span><br><span class="line"><span class="keyword">where</span> (doc_id <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> encourage_card_id <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>) <span class="keyword">or</span>  (doc_id <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> encourage_card_id <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span>) </span><br></pre></td></tr></table></figure><span id="more"></span><p>所以我们在编写sql是可以使用concat函数拼装column来完成上面的sql的效果，sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> encourage_card_quantitative_fake_progress</span><br><span class="line"><span class="keyword">WHERE</span> (concat(doc_id,<span class="string">&#x27;_&#x27;</span>,encourage_card_id) <span class="keyword">in</span> (<span class="string">&#x27;1jshdfjka_12345&#x27;</span>,<span class="string">&#x27;2jshdfjka_2&#x27;</span>))</span><br></pre></td></tr></table></figure><p>在mybatis中实现上面sql代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EncourageCardQuantitativeFakeProgressMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SelectProvider(type = EncourageCardQuantitativeFakeProgressBuilder.class, method = &quot;buildListByCondition&quot;)</span></span><br><span class="line">    List&lt;EncourageCardQuantitativeFakeProgress&gt; <span class="title function_">listByCondition</span><span class="params">(<span class="meta">@Param(&quot;postDatas&quot;)</span> List&lt;ProgressBarReq.PostData&gt; postDatas)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EncourageCardQuantitativeFakeProgressBuilder</span> <span class="keyword">implements</span> <span class="title class_">ProviderMethodResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">buildListByCondition</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">            List&lt;ProgressBarReq.PostData&gt; postDatas = (List&lt;ProgressBarReq.PostData&gt;) parameters.get(<span class="string">&quot;docRelationIds&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">SQL</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SQL</span>();</span><br><span class="line">            sql.SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            sql.FROM(MysqlTable.encourage_card_quantitative_fake_progress.name());</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; strArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ProgressBarReq.PostData postData : postDatas) &#123;</span><br><span class="line">                strArr.add(<span class="string">&quot;&#x27;&quot;</span> + postData.getDocId() + <span class="string">&quot;_&quot;</span> + postData.getEncourageCardId() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sql.WHERE(<span class="string">&quot;concat(doc_id,&#x27;_&#x27;,encourage_card_id) in (&quot;</span> + StringUtils.join(strArr, <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sql.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要注意的是绑定类的代码形参是</p><p>Map&lt;String, Object&gt; parameters</p><p>如果想获取传入的List参数需要增加如下代码</p><p>List&lt;ProgressBarReq.PostData&gt; postDatas &#x3D; (List&lt;ProgressBarReq.PostData&gt;) parameters.get(“docRelationIds”);</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式-策略模式+工厂解决复杂ifelse过多问题</title>
      <link href="/2021/01/27/%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82ifelse%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/27/%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F+%E5%B7%A5%E5%8E%82%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82ifelse%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>1.按小时、天查询不同表</p><p>2.按照特定领域、全领域按照不同字段排序</p><p>3.按照文章类型进行排序</p><p>因此条件很多，需要多个if条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getHourOrDayDocs</span><span class="params">(String cate, BillboardScheduleReq.PostType postType, BillboardScheduleReq.SortType sortType)</span> &#123;</span><br><span class="line">        List&lt;MysqlBillboardCateTopviewDoc&gt; hourOrDayDocs;</span><br><span class="line">        <span class="keyword">if</span> (sortType == BillboardScheduleReq.SortType.hour) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(cate)) &#123;<span class="comment">// 全领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocHourlyService.listAllCatePostTypeHourly(postType.getValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//分领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocHourlyService.listTypeCatePostTypeHourly(cate, postType.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 天排行榜</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Strings.isBlank(cate)) &#123; <span class="comment">// 全领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocDailyService.listAllCatePostTypeDaily(postType.getValue());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//分领域</span></span><br><span class="line">                hourOrDayDocs = mysqlBillboardCateTopviewDocDailyService.listTypeCatePostTypeDaily(cate, postType.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hourOrDayDocs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h2><p>使用策略模式加工厂模式能够很好的解决该问题，使用设计模式修改后的代码，直接根据传入的类型获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getHourOrDayDocs</span><span class="params">(String cate, BillboardEnum.PostType postType, BillboardEnum.SortType sortType)</span> &#123;</span><br><span class="line">    String key;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isNotBlank(cate)) &#123;</span><br><span class="line">        key = CateStrategyFactory.buildKey(<span class="string">&quot;type&quot;</span>, sortType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        key = CateStrategyFactory.buildKey(<span class="string">&quot;&quot;</span>, sortType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> CateStrategyFactory.get(key);</span><br><span class="line">    <span class="keyword">return</span> strategy.getViewDocs(cate, postType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>定义了一个策略接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getViewDocs</span><span class="params">(String cate, BillboardEnum.PostType postType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个生产策略的工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CateStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CateStrategyFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Strategy&gt; services = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> services.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">buildKey</span><span class="params">(String cate, BillboardEnum.SortType sortType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sortType_&quot;</span> + sortType + CommonValue.STR_SEMICOLON + <span class="string">&quot;cate_&quot;</span> + cate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String key, Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;strategy can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        services.put(key, strategy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeCateHourStrategy小时细分领域策略类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCateHourStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MysqlBillboardCateTopviewDocHourlyService mysqlBillboardCateTopviewDocHourlyService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getViewDocs</span><span class="params">(String cate, BillboardEnum.PostType postType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mysqlBillboardCateTopviewDocHourlyService.listTypeCatePostTypeHourly(cate, postType.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cate</span> <span class="operator">=</span> <span class="string">&quot;type&quot;</span>; <span class="comment">// 特定领域</span></span><br><span class="line">        BillboardEnum.<span class="type">SortType</span> <span class="variable">sortType</span> <span class="operator">=</span> BillboardEnum.SortType.hour;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CateStrategyFactory.buildKey(cate, sortType);</span><br><span class="line">        CateStrategyFactory.register(key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TypeCateDayStrategy日细分领域策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCateDayStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MysqlBillboardCateTopviewDocDailyService mysqlBillboardCateTopviewDocDailyService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getViewDocs</span><span class="params">(String cate, BillboardEnum.PostType postType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mysqlBillboardCateTopviewDocDailyService.listTypeCatePostTypeDaily(cate, postType.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cate</span> <span class="operator">=</span> <span class="string">&quot;type&quot;</span>; <span class="comment">// 特定领域</span></span><br><span class="line">        BillboardEnum.<span class="type">SortType</span> <span class="variable">sortType</span> <span class="operator">=</span> BillboardEnum.SortType.day;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CateStrategyFactory.buildKey(cate, sortType);</span><br><span class="line">        CateStrategyFactory.register(key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllCateHourStrategy全领域小时策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllCateHourStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MysqlBillboardCateTopviewDocHourlyService mysqlBillboardCateTopviewDocHourlyService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getViewDocs</span><span class="params">(String cate, BillboardEnum.PostType postType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mysqlBillboardCateTopviewDocHourlyService.listAllCatePostTypeHourly(postType.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cate</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 全领域</span></span><br><span class="line">        BillboardEnum.<span class="type">SortType</span> <span class="variable">sortType</span> <span class="operator">=</span> BillboardEnum.SortType.hour;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CateStrategyFactory.buildKey(cate, sortType);</span><br><span class="line">        CateStrategyFactory.register(key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllCateDayStrategy全领域日策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有领域天排行策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllCateDayStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MysqlBillboardCateTopviewDocDailyService mysqlBillboardCateTopviewDocDailyService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MysqlBillboardCateTopviewDoc&gt; <span class="title function_">getViewDocs</span><span class="params">(String cate, BillboardEnum.PostType postType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mysqlBillboardCateTopviewDocDailyService.listAllCatePostTypeDaily(postType.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cate</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 全领域</span></span><br><span class="line">        BillboardEnum.<span class="type">SortType</span> <span class="variable">sortType</span> <span class="operator">=</span> BillboardEnum.SortType.day;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CateStrategyFactory.buildKey(cate, sortType);</span><br><span class="line">        CateStrategyFactory.register(key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink-SingleOutputStreamOperator用法</title>
      <link href="/2020/11/30/Flink-SingleOutputStreamOperator%E7%94%A8%E6%B3%95/"/>
      <url>/2020/11/30/Flink-SingleOutputStreamOperator%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>Flink DataStream</code>中<code>union</code>和<code>connect</code>都有一个共同的作用，就是将2个流或多个流合成一个流。但是两者的区别是：<code>union</code>连接的2个流的类型必须一致，<code>connect</code>连接的流可以不一致，但是可以统一处理。</p><p>具体看下面示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectOperator</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect可以将2个不同类型的流同时用不同的逻辑处理好，形成一个流。</p><p>union是将2个同类型的流，合成一个，进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-构造最大二叉树</title>
      <link href="/2020/11/30/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20/"/>
      <url>/2020/11/30/%E7%AE%97%E6%B3%95-%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20/</url>
      
        <content type="html"><![CDATA[<p>原题链接：<a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><span id="more"></span><p>示例 ：</p><p>输入：[3,2,1,6,0,5]<br>输出：返回下面这棵树的根节点：</p><pre><code>   6    /   \   3     5    \    /      2  0          \        1</code></pre><p>BinaryTree代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.listnode.ListNode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树深度优先和广度优先遍历</title>
      <link href="/2020/11/15/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2020/11/15/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="深度优先遍历算法（DFS）"><a href="#深度优先遍历算法（DFS）" class="headerlink" title="深度优先遍历算法（DFS）"></a>深度优先遍历算法（DFS）</h2><p>深度优先遍历算法（Depth-First-Search），是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v所在的边都一杯探寻过，搜索将回溯到发现节点v的那条边的节点。选择其中一个座位源节点并重复以上过程，整个进程反复进行，直到所有节点都被访问位置。</p><p>前序、中序、后序遍历都属于深度优先遍历算法</p><span id="more"></span><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>F, B, A, D, C, E, G, I, H.</p><p><img src="/images/Sorted_binary_tree_preorder.svg" alt="前序遍历"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>A, B, C, D, E, F, G, H, I.</p><p><img src="/images/Sorted_binary_tree_inorder.svg" alt="中序遍历"></p><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3><p>A, C, E, D, B, H, I, G, F.</p><p><img src="/images/Sorted_binary_tree_postorder.svg" alt="后续遍历"></p><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><p>广度优先遍历（Breadth-First Search），又名宽度优先搜索，或者横向优先搜索，是一种图形搜索演算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点，如果所有节点均被访问，则算法终止。</p><p>F, B, G, A, D, I, C, E, H.</p><p><img src="/images/Sorted_binary_tree_breadth-first_traversal.svg" alt="广度遍历"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">initTree</span><span class="params">()</span> &#123;</span><br><span class="line">        BinaryTree&lt;Integer&gt; binaryTree = <span class="keyword">new</span> <span class="title class_">BinaryTree</span>&lt;Integer&gt;();</span><br><span class="line">        binaryTree.put(<span class="number">3</span>);</span><br><span class="line">        binaryTree.put(<span class="number">5</span>);</span><br><span class="line">        binaryTree.put(<span class="number">1</span>);</span><br><span class="line">        binaryTree.put(<span class="number">2</span>);</span><br><span class="line">        binaryTree.put(<span class="number">10</span>);</span><br><span class="line">        binaryTree.put(<span class="number">0</span>);</span><br><span class="line">        binaryTree.put(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> binaryTree.getRoot();</span><br><span class="line"></span><br><span class="line">        BTreePrinter.printNode(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先 - 递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> initTree();</span><br><span class="line">        DFS(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(x.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        DFS(x.left);</span><br><span class="line">        DFS(x.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">()</span> &#123;</span><br><span class="line">        Queue&lt;Comparable&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> initTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 出队</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">e</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(e.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(e.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            res.offer(e.value);</span></span><br><span class="line">            System.out.print(e.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(res);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeSearch</span> <span class="variable">treeSearch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSearch</span>();</span><br><span class="line">        treeSearch.BFS();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        treeSearch.DFS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   3       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 1   5   </span><br><span class="line">/ \ / \ </span><br><span class="line">0 2 4 10 </span><br><span class="line">                </span><br><span class="line">3 1 5 0 2 4 10 </span><br><span class="line">   3       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 1   5   </span><br><span class="line">/ \ / \ </span><br><span class="line">0 2 4 10 </span><br><span class="line">                </span><br><span class="line">3 1 0 2 5 4 10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-单链表</title>
      <link href="/2020/11/07/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/11/07/%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>单链表代码如下</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.listnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(T value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFromHead</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = n;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n.next = head;</span><br><span class="line">        head = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToTail</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = n;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (x.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">        x.next = n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         // 这里哪里不对？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         Node x1 = head;</span></span><br><span class="line"><span class="comment">         while (x1 != null) &#123;</span></span><br><span class="line"><span class="comment">         x1 = x1.next;</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         x1 = n;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, x.value);</span><br><span class="line">            x = x.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        ListNode&lt;Integer&gt; listNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>&lt;&gt;();</span><br><span class="line">        listNode.addToTail(<span class="number">1</span>);</span><br><span class="line">        listNode.addToTail(<span class="number">2</span>);</span><br><span class="line">        listNode.addToTail(<span class="number">3</span>);</span><br><span class="line">        listNode.addToTail(<span class="number">4</span>);</span><br><span class="line">        listNode.addToTail(<span class="number">5</span>);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, listNode.size());</span><br><span class="line">        listNode.traverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[2020-11-07 18:12:48,443] [INFO ] [main ] [main] [ListNode:84] - hello</span><br><span class="line">[2020-11-07 18:12:48,460] [INFO ] [main ] [main] [ListNode:91] - 5</span><br><span class="line">[2020-11-07 18:12:48,461] [INFO ] [main ] [traverse] [ListNode:78] - 1</span><br><span class="line">[2020-11-07 18:12:48,461] [INFO ] [main ] [traverse] [ListNode:78] - 2</span><br><span class="line">[2020-11-07 18:12:48,461] [INFO ] [main ] [traverse] [ListNode:78] - 3</span><br><span class="line">[2020-11-07 18:12:48,462] [INFO ] [main ] [traverse] [ListNode:78] - 4</span><br><span class="line">[2020-11-07 18:12:48,462] [INFO ] [main ] [traverse] [ListNode:78] - 5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-自定义注解</title>
      <link href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/"/>
      <url>/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h4 id="元注解-Target"><a href="#元注解-Target" class="headerlink" title="元注解@Target"></a>元注解@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p><h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>第一步，用<code>@interface</code>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-自定义注解（二）</title>
      <link href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%BA%8C)/"/>
      <url>/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>再读完Java自定义注解（一）我们可以通过代码来实现我们自己的自定义注解</p><h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>EventBean类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventName(&quot;coding now...&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventType(eventType = EventType.Type.MEETING)</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@User(id = 1, name = &quot;testName&quot;, email = &quot;15090552277@163.com&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-自定义注解(一)</title>
      <link href="/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/11/05/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="元注解-Target"><a href="#元注解-Target" class="headerlink" title="元注解@Target"></a>元注解@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p><h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>第一步，用<code>@interface</code>定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p>第二步，添加参数、默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，用元注解配置注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二叉树</title>
      <link href="/2020/11/05/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/11/05/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉树需要声明一个Node节点，包含节点得值，以及左右两个子节点</p><p>Node节点代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;&#123;</span><br><span class="line">    T value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    Node(T value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><p>BinaryTree代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.note.listnode.ListNode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        root = put(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; <span class="title function_">put</span><span class="params">(Node&lt;T&gt; x, T value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> value.compareTo(x.value);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.left = put(x.left, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x.right = put(x.right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        BTreePrinter.printNode(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">()</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + count(x.left) + count(x.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, node.value);</span><br><span class="line">        traverse(node.left);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        traverse(node.right);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">        reverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Node x)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> x.left;</span><br><span class="line">        x.left = x.right;</span><br><span class="line">        x.right = tmp;</span><br><span class="line"></span><br><span class="line">        reverse(x.left);</span><br><span class="line">        reverse(x.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树得深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(Node x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(getDepth(x.left), getDepth(x.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode&lt;Comparable&gt; listNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">toListNode</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        toListNode(root);</span><br><span class="line">        <span class="keyword">return</span> listNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树转单链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">toListNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        listNode.addToTail(node.value);</span><br><span class="line"></span><br><span class="line">        toListNode(node.left);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        toListNode(node.right);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以图形的格式打印二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTreePrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;?&gt;&gt; <span class="keyword">void</span> <span class="title function_">printNode</span><span class="params">(Node&lt;T&gt; root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLevel</span> <span class="operator">=</span> BTreePrinter.maxLevel(root);</span><br><span class="line"></span><br><span class="line">        printNodeInternal(Collections.singletonList(root), <span class="number">1</span>, maxLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;?&gt;&gt; <span class="keyword">void</span> <span class="title function_">printNodeInternal</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes, <span class="type">int</span> level, <span class="type">int</span> maxLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty() || BTreePrinter.isAllElementsNull(nodes))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">floor</span> <span class="operator">=</span> maxLevel - level;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endgeLines</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, (Math.max(floor - <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstSpaces</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, (floor)) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">betweenSpaces</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>, (floor + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        BTreePrinter.printWhitespaces(firstSpaces);</span><br><span class="line"></span><br><span class="line">        List&lt;Node&lt;T&gt;&gt; newNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;T&gt; node : nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(node.value);</span><br><span class="line">                newNodes.add(node.left);</span><br><span class="line">                newNodes.add(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newNodes.add(<span class="literal">null</span>);</span><br><span class="line">                newNodes.add(<span class="literal">null</span>);</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BTreePrinter.printWhitespaces(betweenSpaces);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= endgeLines; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nodes.size(); j++) &#123;</span><br><span class="line">                BTreePrinter.printWhitespaces(firstSpaces - i);</span><br><span class="line">                <span class="keyword">if</span> (nodes.get(j) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    BTreePrinter.printWhitespaces(endgeLines + endgeLines + i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nodes.get(j).left != <span class="literal">null</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    BTreePrinter.printWhitespaces(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                BTreePrinter.printWhitespaces(i + i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nodes.get(j).right != <span class="literal">null</span>)</span><br><span class="line">                    System.out.print(<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    BTreePrinter.printWhitespaces(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                BTreePrinter.printWhitespaces(endgeLines + endgeLines - i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printNodeInternal(newNodes, level + <span class="number">1</span>, maxLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printWhitespaces</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;?&gt;&gt; <span class="type">int</span> <span class="title function_">maxLevel</span><span class="params">(Node&lt;T&gt; node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(BTreePrinter.maxLevel(node.left), BTreePrinter.maxLevel(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isAllElementsNull</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.code.note.tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        BinaryTree&lt;Integer&gt; binaryTree = <span class="keyword">new</span> <span class="title class_">BinaryTree</span>&lt;Integer&gt;();</span><br><span class="line">        binaryTree.put(<span class="number">3</span>);</span><br><span class="line">        binaryTree.put(<span class="number">5</span>);</span><br><span class="line">        binaryTree.put(<span class="number">1</span>);</span><br><span class="line">        binaryTree.put(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        binaryTree.put(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        binaryTree.traverse();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> binaryTree.count();</span><br><span class="line">        log.info(<span class="string">&quot;count:&#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> binaryTree.getDepth();</span><br><span class="line">        log.info(<span class="string">&quot;depth:&#123;&#125;&quot;</span>, depth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转二叉树</span></span><br><span class="line">        binaryTree.print();</span><br><span class="line">        binaryTree.reverse();</span><br><span class="line">        binaryTree.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[2020-11-07 18:04:20,793] [INFO ] [main ] [traverse] [BinaryTree:52] - 3</span><br><span class="line">[2020-11-07 18:04:20,811] [INFO ] [main ] [traverse] [BinaryTree:52] - 1</span><br><span class="line">[2020-11-07 18:04:20,811] [INFO ] [main ] [traverse] [BinaryTree:52] - 0</span><br><span class="line">[2020-11-07 18:04:20,811] [INFO ] [main ] [traverse] [BinaryTree:52] - 2</span><br><span class="line">[2020-11-07 18:04:20,812] [INFO ] [main ] [traverse] [BinaryTree:52] - 5</span><br><span class="line">[2020-11-07 18:04:20,812] [INFO ] [main ] [traverse] [BinaryTree:52] - 4</span><br><span class="line">[2020-11-07 18:04:20,812] [INFO ] [main ] [traverse] [BinaryTree:52] - 10</span><br><span class="line">[2020-11-07 18:04:20,812] [ERROR] [main ] [main] [BinaryTreeTest:25] - count:7</span><br><span class="line">[2020-11-07 18:04:20,839] [ERROR] [main ] [main] [BinaryTreeTest:28] - depth:3</span><br><span class="line">   3       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 1   5   </span><br><span class="line">/ \ / \ </span><br><span class="line">0 2 4 10 </span><br><span class="line">                </span><br><span class="line">[2020-11-07 18:04:20,843] [INFO ] [main ] [traverse] [ListNode:78] - 3</span><br><span class="line">[2020-11-07 18:04:20,843] [INFO ] [main ] [traverse] [ListNode:78] - 1</span><br><span class="line">[2020-11-07 18:04:20,844] [INFO ] [main ] [traverse] [ListNode:78] - 0</span><br><span class="line">[2020-11-07 18:04:20,844] [INFO ] [main ] [traverse] [ListNode:78] - 2</span><br><span class="line">[2020-11-07 18:04:20,844] [INFO ] [main ] [traverse] [ListNode:78] - 5</span><br><span class="line">[2020-11-07 18:04:20,844] [INFO ] [main ] [traverse] [ListNode:78] - 4</span><br><span class="line">[2020-11-07 18:04:20,844] [INFO ] [main ] [traverse] [ListNode:78] - 10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Connect和Union区别</title>
      <link href="/2020/11/03/Flink%20Connect%E5%92%8CUnion%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/11/03/Flink%20Connect%E5%92%8CUnion%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>Flink DataStream</code>中<code>union</code>和<code>connect</code>都有一个共同的作用，就是将2个流或多个流合成一个流。但是两者的区别是：<code>union</code>连接的2个流的类型必须一致，<code>connect</code>连接的流可以不一致，但是可以统一处理。</p><p>具体看下面示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectOperator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">sEnv</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        sEnv.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        p.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Student&gt; student = sEnv</span><br><span class="line">                .addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer010</span>&lt;String&gt;(<span class="string">&quot;student&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), p))</span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Student&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Student <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(value, Student.class);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        student.print();</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Teacher&gt; teacher = sEnv</span><br><span class="line">                .addSource(<span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer010</span>&lt;String&gt;(<span class="string">&quot;teacher&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), p))</span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Teacher&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Teacher <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(value, Teacher.class);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        teacher.print();</span><br><span class="line"></span><br><span class="line">        ConnectedStreams&lt;Student, Teacher&gt; connect = student.connect(teacher);</span><br><span class="line"></span><br><span class="line">        connect.process(<span class="keyword">new</span> <span class="title class_">CoProcessFunction</span>&lt;Student, Teacher, Tuple5&lt;String, Integer, String, String, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement1</span><span class="params">(Student value, Context ctx, Collector&lt;Tuple5&lt;String, Integer, String, String, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> <span class="title class_">Tuple5</span>&lt;&gt;(value.name, value.age, value.sex, value.classId, value.timestamp));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement2</span><span class="params">(Teacher value, Context ctx, Collector&lt;Tuple5&lt;String, Integer, String, String, Long&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> <span class="title class_">Tuple5</span>&lt;&gt;(value.name, value.age, value.sex, value.classId, value.timestamp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).print(<span class="string">&quot;process&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// connect</span></span><br><span class="line">        connect.map(<span class="keyword">new</span> <span class="title class_">CoMapFunction</span>&lt;Student, Teacher, Tuple5&lt;String, Integer, String, String, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple5&lt;String, Integer, String, String, Long&gt; <span class="title function_">map1</span><span class="params">(Student value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple5</span>&lt;&gt;(value.name, value.age, value.sex, value.classId, value.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple5&lt;String, Integer, String, String, Long&gt; <span class="title function_">map2</span><span class="params">(Teacher value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple5</span>&lt;&gt;(value.name, value.age, value.sex, value.classId, value.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).print(<span class="string">&quot;map&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// union</span></span><br><span class="line">        student.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;Student, Tuple5&lt;String, Integer, String, String, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple5&lt;String, Integer, String, String, Long&gt; <span class="title function_">map</span><span class="params">(Student value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple5</span>&lt;&gt;(value.name, value.age, value.sex, value.classId, value.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).union(teacher.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;Teacher, Tuple5&lt;String, Integer, String, String, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple5&lt;String, Integer, String, String, Long&gt; <span class="title function_">map</span><span class="params">(Teacher value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple5</span>&lt;&gt;(value.name, value.age, value.sex, value.classId, value.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).print(<span class="string">&quot;union&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sEnv.execute(<span class="string">&quot;ConnectOperator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect可以将2个不同类型的流同时用不同的逻辑处理好，形成一个流。</p><p>union是将2个同类型的流，合成一个，进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8的Function和BI_Function</title>
      <link href="/2020/10/20/Java8%E7%9A%84Function%E5%92%8CBI_Function/"/>
      <url>/2020/10/20/Java8%E7%9A%84Function%E5%92%8CBI_Function/</url>
      
        <content type="html"><![CDATA[<h1 id="Function函数"><a href="#Function函数" class="headerlink" title="Function函数"></a>Function函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> Function作为一个函数式接口，主要方法apply接受一个参数，返回一个值</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Function&lt;Integer, Integer&gt; f1 = x -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x * x;</span><br><span class="line">        &#125;;</span><br><span class="line">        Function&lt;Integer, Integer&gt; f2 = x -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + x;</span><br><span class="line">        &#125;;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示f1参数由f2函数构成，即(x + x) * (x + x)</span></span><br><span class="line">        <span class="comment">//（3+3）*（3+3）= 36</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, f1.compose(f2).apply(<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示先执行f1函数，再执行f2函数</span></span><br><span class="line">        <span class="comment">//（3*3）+（3*3）=18</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, f1.andThen(f2).apply(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function接口源码如下"><a href="#Function接口源码如下" class="headerlink" title="Function接口源码如下"></a>Function接口源码如下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 表示f1参数由f2函数构成，即(x + x) * (x + x)</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示先执行f1函数，再执行f2函数</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BIFunction函数"><a href="#BIFunction函数" class="headerlink" title="BIFunction函数"></a>BIFunction函数</h1><p>BiFunction也是一个函数式接口，和Function接口不同的是，它在接口中声明了3个泛型，其中前两个作为方法参数类型，最后一个作为返回类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BiFunction&lt;String, String, String&gt; f1 = (x, y) -&gt; <span class="string">&quot;world &quot;</span> + x + y;</span><br><span class="line">        Function&lt;String, String&gt; f2 = (x) -&gt; <span class="string">&quot;hello &quot;</span> + x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// world lisi</span></span><br><span class="line">        log.info(f1.apply(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;si&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hello + world lisi</span></span><br><span class="line">        log.info(f1.andThen(f2).apply(<span class="string">&quot;li&quot;</span>, <span class="string">&quot;si&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个例子可以看出</p><p>f1.andThen(f2)是<strong>先计算f1且将结果作为参数传入f2中</strong></p><p>BiFunction接口源码如下，可以看出由after（f2参数）调用apply方法执行f1的apply方法，即将f1计算结果传入f2中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiFunction</span>&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; BiFunction&lt;T, U, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中如何自动调用父类中的资源初始化方法</title>
      <link href="/2020/10/20/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/10/20/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在写程序时候常常有一些资源初始化方法，我们希望这些方法能够被自动调用 ，可以使用如下方式实现自动调用</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>父类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.autocall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Super</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">call0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 在这里调用子类中的call0方法</span></span><br><span class="line">        <span class="built_in">this</span>.call0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.autocall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里写被初始化的方法</span></span><br><span class="line">        log.info(<span class="string">&quot;son call0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        a.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 [main] INFO com.bd.autocall.Sub - son call0</span><br></pre></td></tr></table></figure><p>其中，call方法是对外方法，会被其他人调用</p><p>其他人调用父类的call方法的时，子类的call0方法也会被调用，从而实现call0方法被自动调用</p><h1 id="复杂例子"><a href="#复杂例子" class="headerlink" title="复杂例子"></a>复杂例子</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>在Flink中，自定义一个RichFunction，其中open函数里是初始化缓存或者数据资源的方法，该方法会被Flink框架自动调用且只调用一次。我们希望在实现子类时候，即能继承open函数原有的资源，又能向open函数中添加新的资源初始化</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRichFunction</span> <span class="keyword">implements</span> <span class="title class_">RichFunction</span>, AthenaCodisInterface, AthenaHbaseInterface, AthenaMediaJdbcInterface, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(AbstractRichFunction.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> External external;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> CodisExternalClient&lt;String, MediaMessage&gt; mediaCodisClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> CodisExternalClient&lt;String, PostMessage&gt; postCodisClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> CodisExternalClient&lt;String, Long&gt; shunCodisClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HbaseExternalClient&lt;String, PostMessage&gt; postHbaseClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> JdbcExternalClient&lt;String, MediaPostEventMessage&gt; weMediaJdbcClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ParameterTool</span> <span class="variable">parameterTool</span> <span class="operator">=</span> (ParameterTool)getRuntimeContext().getExecutionConfig().getGlobalJobParameters();</span><br><span class="line">        <span class="type">String</span> <span class="variable">athenaConfig</span> <span class="operator">=</span> parameterTool.get(ATHENA_CONFIG_NAME);</span><br><span class="line">        <span class="built_in">this</span>.external = JSONObject.parseObject(athenaConfig, External.class);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.open0(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open0</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Runtime context access</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> RuntimeContext runtimeContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRuntimeContext</span><span class="params">(RuntimeContext t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runtimeContext = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RuntimeContext <span class="title function_">getRuntimeContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.runtimeContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.runtimeContext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The runtime context has not been initialized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IterationRuntimeContext <span class="title function_">getIterationRuntimeContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.runtimeContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The runtime context has not been initialized.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.runtimeContext <span class="keyword">instanceof</span> IterationRuntimeContext) &#123;</span><br><span class="line">            <span class="keyword">return</span> (IterationRuntimeContext) <span class="built_in">this</span>.runtimeContext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This stub is not part of an iteration step function.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Default life cycle methods</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> CodisExternalClient&lt;String, MediaMessage&gt; <span class="title function_">getMediaCodisClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mediaCodisClient != <span class="literal">null</span>) <span class="keyword">return</span> mediaCodisClient;</span><br><span class="line">        Map&lt;AthenaExternalEnum, CodisExternal&gt; map = external.getCodis();</span><br><span class="line">        <span class="type">CodisExternal</span> <span class="variable">codisExternal</span> <span class="operator">=</span> map.get(AthenaExternalEnum.MEDIA_CACHE_EVENT);</span><br><span class="line">        mediaCodisClient = codisExternal.getClient();</span><br><span class="line">        <span class="keyword">return</span> mediaCodisClient;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> CodisExternalClient&lt;String, PostMessage&gt; <span class="title function_">getPostCodisClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(postCodisClient != <span class="literal">null</span>) <span class="keyword">return</span> postCodisClient;</span><br><span class="line">        Map&lt;AthenaExternalEnum, CodisExternal&gt; map = external.getCodis();</span><br><span class="line">        <span class="type">CodisExternal</span> <span class="variable">codisExternal</span> <span class="operator">=</span> map.get(AthenaExternalEnum.POST_CACHE_EVENT);</span><br><span class="line">        postCodisClient = codisExternal.getClient();</span><br><span class="line">        <span class="keyword">return</span> postCodisClient;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> CodisExternalClient&lt;String, Long&gt; <span class="title function_">getShunCodisClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(shunCodisClient != <span class="literal">null</span>) <span class="keyword">return</span> shunCodisClient;</span><br><span class="line">        Map&lt;AthenaExternalEnum, CodisExternal&gt; map = external.getCodis();</span><br><span class="line">        <span class="type">CodisExternal</span> <span class="variable">codisExternal</span> <span class="operator">=</span> map.get(AthenaExternalEnum.SHUN_CACHE_EVENT);</span><br><span class="line">        shunCodisClient = codisExternal.getClient();</span><br><span class="line">        <span class="keyword">return</span> shunCodisClient;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> JdbcExternalClient&lt;String, MediaPostEventMessage&gt; <span class="title function_">getWeMediaJdbcClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(weMediaJdbcClient != <span class="literal">null</span>) <span class="keyword">return</span> weMediaJdbcClient;</span><br><span class="line">        Map&lt;AthenaExternalEnum, JdbcExternal&gt; map = external.getJdbc();</span><br><span class="line">        <span class="type">JdbcExternal</span> <span class="variable">jdbcExternal</span> <span class="operator">=</span> map.get(AthenaExternalEnum.WEMEDIA_MYSQL_EVENT);</span><br><span class="line">        <span class="keyword">return</span> jdbcExternal.getClient();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> HbaseExternalClient&lt;String, PostMessage&gt; <span class="title function_">getPostHbaseClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> external.getHbase().get(AthenaExternalEnum.POST_HBASE_EVENT).getClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HbaseExternalClient&lt;String, MediaMessage&gt; <span class="title function_">getMediaHbaseClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> external.getHbase().get(AthenaExternalEnum.MEDIA_HBASE_EVENT).getClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RichFlatMapFunction</span>&lt;IN, OUT&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRichFunction</span> <span class="keyword">implements</span> <span class="title class_">FlatMapFunction</span>&lt;IN, OUT&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(IN value, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostMapFunction</span> <span class="keyword">extends</span> <span class="title class_">RichFlatMapFunction</span>&lt;PostFactEventMessage, PostFactEventMessage&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(PostFactMsgMapFunction.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HbaseExternalClient&lt;String, PostMessage&gt; postHbaseClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> LoadingCache&lt;String, PostMessage&gt; loadingCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">codisCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">hbaseCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open0</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        postHbaseClient = getPostHbaseClient();</span><br><span class="line"></span><br><span class="line">        loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">5000000</span>)</span><br><span class="line">                .expireAfterWrite(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, PostMessage&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> PostMessage <span class="title function_">load</span><span class="params">(String docId)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="type">PostMessage</span> <span class="variable">postMessage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            postMessage = getPostCodisClient().getObject(docId);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            LOG.warn(<span class="string">&quot;codis error&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        LOG.error(<span class="string">&quot;load postMessage from codis count=&#123;&#125;&quot;</span>, codisCount.addAndGet(<span class="number">1</span>));</span><br><span class="line">                        <span class="keyword">if</span> (Objects.isNull(postMessage) &amp;&amp; StringUtils.isNotBlank(docId)) &#123;</span><br><span class="line">                            postMessage = postHbaseClient.getObject(docId);</span><br><span class="line">                            LOG.error(<span class="string">&quot;load postMessage from hbase count=&#123;&#125;&quot;</span>, hbaseCount.addAndGet(<span class="number">1</span>));</span><br><span class="line">                            LOG.error(<span class="string">&quot;load postMessage from hbase finish&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (Objects.isNull(postMessage)) &#123;</span><br><span class="line">                            postMessage = <span class="keyword">new</span> <span class="title class_">PostMessage</span>();</span><br><span class="line">                            postMessage.setNewsId(docId);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> postMessage;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(PostFactEventMessage value, Collector&lt;PostFactEventMessage&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">PostMessage</span> <span class="variable">postMessage</span> <span class="operator">=</span> loadingCache.get(value.getDocId());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(postMessage)) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;postMessage=null, docId = &#123;&#125;&quot;</span>, value.getDocId());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(postMessage.getMediaId() == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        value.loadPostMessage(postMessage);</span><br><span class="line">        out.collect(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，PostMapFunction类在open0中初始化了postHbaseClient资源，并包装成guava缓存读取器。由于open0被父类调用，postHbaseClient会被加载到open函数里，并被flink作为分布式资源使用</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装python3</title>
      <link href="/2020/07/20/Centos7%E5%AE%89%E8%A3%85python3/"/>
      <url>/2020/07/20/Centos7%E5%AE%89%E8%A3%85python3/</url>
      
        <content type="html"><![CDATA[<h2 id="下载python3安装包"><a href="#下载python3安装包" class="headerlink" title="下载python3安装包"></a>下载python3安装包</h2><p>wget -c <a href="https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz">https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz</a></p><h2 id="安装linux依赖"><a href="#安装linux依赖" class="headerlink" title="安装linux依赖"></a>安装linux依赖</h2><p>yum install libffi-devel openssl openssl-devel sqlite-devel bzip2-devel -y</p><p>在源码安装文件中编辑文件Modules&#x2F;Setup.dist</p><h2 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h2><p>在源码安装文件中编辑文件Modules&#x2F;Setup.dist</p><p>去掉如下注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SSL=/usr/local/ssl</span></span><br><span class="line">_ssl _ssl.c \</span><br><span class="line"> -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \</span><br><span class="line"> -L$(SSL)/lib -lssl -lcrypto</span><br></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>mkdir &#x2F;usr&#x2F;python3</p><p>cd Python-3.7.3</p><p>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;python3 –enable-loadable-sqlite-extensions &amp;&amp; make &amp;&amp; make install</p><p>ln -s &#x2F;usr&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</p><p>ln -s &#x2F;usr&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建个人仓库</title>
      <link href="/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BB%93%E5%BA%93/"/>
      <url>/2020/07/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh端口为22情况"><a href="#ssh端口为22情况" class="headerlink" title="ssh端口为22情况"></a>ssh端口为22情况</h1><p>在服务器端172.27.9.121搭建仓库</p><p>1.在仓库目录&#x2F;tmp&#x2F;myproject.git输入git init</p><p>2.允许上传代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config receive.denyCurrentBranch ignore</span><br></pre></td></tr></table></figure><span id="more"></span><p>3.在本地clone远程仓库代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone root@172.27.9.121:/tmp/myproject.git</span><br></pre></td></tr></table></figure><p>4.向121服务器~&#x2F;.ssh&#x2F;authxxx 添加私钥，免密码认证</p><h1 id="如何上传非ssh端口代码"><a href="#如何上传非ssh端口代码" class="headerlink" title="如何上传非ssh端口代码"></a>如何上传非ssh端口代码</h1><p>编辑本地文件~&#x2F;.ssh&#x2F;config，增加如下内容,remotevps代表的是远端服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># For all hosts</span><br><span class="line">ServerAliveInterval 10</span><br><span class="line"></span><br><span class="line">Host remotevps</span><br><span class="line">HostName 107.123.123.123</span><br><span class="line">Port 12345</span><br><span class="line">User root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>设置远程push链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin root@remotevps:/opt/git/resumegit remote add origin </span><br></pre></td></tr></table></figure><p>克隆远端代码仓库命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone root@remotevps:/home/yKF6600/OasisSpark2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试-Kafka专题</title>
      <link href="/2020/07/11/%E9%9D%A2%E8%AF%95-kafka%E4%B8%93%E9%A2%98/"/>
      <url>/2020/07/11/%E9%9D%A2%E8%AF%95-kafka%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Kafka时会遇到的问题"><a href="#使用Kafka时会遇到的问题" class="headerlink" title="使用Kafka时会遇到的问题"></a>使用Kafka时会遇到的问题</h1><ol><li>Kafka速度很快的原因</li><li>如何保证消息不丢失</li><li>Consumer重复消费怎么处理</li><li>如何保证消息的有序性</li></ol><span id="more"></span><p>TODO: 待增加问题</p><ol><li>Offset怎么保存</li><li>数据倾斜怎么处理</li><li>一个Topic分配多少个Partition合适以及修改Partition的限制有哪些</li></ol><h1 id="Kafka速度很快的原因"><a href="#Kafka速度很快的原因" class="headerlink" title="Kafka速度很快的原因"></a>Kafka速度很快的原因</h1><ol><li>磁盘的顺序读写</li><li>使用操作系统的Page Cache，而不是jvm内存，这样能极大加快读写速度。避免Object对象比在Linux对象更大的消耗，避免jvm数据增多GC变慢的问题</li><li>零拷贝，Page Cache 结合 sendfile 方法，避免拷贝到用户态内存操作，Kafka消费端的性能也大幅提升。这也是为什么有时候消费端在不断消费数据时，我们并没有看到磁盘io比较高，此刻正是操作系统缓存在提供数据。</li><li>批量读写，批量压缩：把所有消息都变成一个批量文件，并且执行合理的批量压缩，减少网络IO消耗</li></ol><h1 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h1><h2 id="消息发布的可靠性"><a href="#消息发布的可靠性" class="headerlink" title="消息发布的可靠性"></a>消息发布的可靠性</h2><p>Producer向Topic发送消息，此时网络存在异常，producer无法得知broker是否接收到该消息，网络异常可能有两种情况：</p><ol><li>在消息传递过程中出现了网络出错</li><li>在broker已经接受到了消息，返回ack给producer的过程中网络存异常</li></ol><p>此时可以通过producer重发消息，保证at least once</p><p>0.11.0的版本通过给每个producer一个唯一ID，并且在每个消息生成一个版本号，以对消息去重，以达到producer端的exactly once</p><p>Kafka存在如下概念来保证producer端消息的可靠性</p><h3 id="TOPIC和日志"><a href="#TOPIC和日志" class="headerlink" title="TOPIC和日志"></a>TOPIC和日志</h3><p>TOPIC指的是一个订阅主题，是数据被发布的地方，可以被多个消费者订阅</p><p>对于每个主题，kafka集群都维护了一个分区日志，如下所示</p><p><img src="/images/log_anatomy.png" alt="log_anatomy"></p><p>每个分区都是有序的，不可变的记录集，并且不断追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，<em>offset</em>用来唯一的标识分区中每一条记录。</p><h3 id="消费者、消费组、消息有序性"><a href="#消费者、消费组、消息有序性" class="headerlink" title="消费者、消费组、消息有序性"></a>消费者、消费组、消息有序性</h3><p>消费者使用一个 <em>消费组</em> 名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例.消费者实例可以分布在多个进程中或者多个机器上。</p><p>如果所有的消费者实例在同一消费组中，消息记录会负载平衡到每一个消费者实例.</p><p>如果所有的消费者实例在不同的消费组中，每条消息记录会广播到所有的消费者进程.</p><p><img src="/images/consumer-groups.png" alt="consumer-groups"></p><p>如图，这个 Kafka 集群有两台 server 的，四个分区(p0-p3)和两个消费者组。消费组A有两个消费者，消费组B有四个消费者。</p><p>通常情况下，每个 topic 都会有一些消费组，一个消费组对应一个”逻辑订阅者”。一个消费组由许多消费者实例组成，便于扩展和容错。这就是发布和订阅的概念，只不过订阅者是一组消费者而不是单个的进程。</p><p>在Kafka中实现消费的方式是将日志中的分区划分到每一个消费者实例上，以便在任何时间，每个实例都是分区唯一的消费者。维护消费组中的消费关系由Kafka协议动态处理。如果新的实例加入组，他们将从组中其他成员处接管一些 partition 分区;如果一个实例消失，拥有的分区将被分发到剩余的实例。</p><p>Kafka 只保证分区内的记录是有序的，而不保证主题中不同分区的顺序。每个 partition 分区按照key值排序足以满足大多数应用程序的需求。但如果你需要总记录在所有记录的上面，可使用仅有一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程。</p><h3 id="分布式、分区"><a href="#分布式、分区" class="headerlink" title="分布式、分区"></a>分布式、分区</h3><p>日志的分区partition分布在kafka集群的服务器上，每个服务器在处理数据和请求时，共享这些分区，每个分区都会在已配置的服务器上进行备份，以确保容错性。</p><p>每个分区都一个server作为leader，0个或者多个server作为follower，leader server处理一切对分区的读写请求，而follower只处理被动同步leader上的数据。</p><h3 id="ACK和副本数"><a href="#ACK和副本数" class="headerlink" title="ACK和副本数"></a>ACK和副本数</h3><p>副本数保证数据高可用，ACK保证Producer接受消息策略</p><p>acks&#x3D;0 ，则 producer 不会等待服务器的反馈。该方式效率最高但存在消息丢失风险</p><p>acks&#x3D;1 ，leader接受到消息返回确认后，就被认为消息发布成功。但此时leader宕机存在消息丢失风险</p><p>acks&#x3D;-1 ，消息在所有副本都返回成功之后才被认为消息写入成功，此种方式性能比较差，但稳定性时最高的</p><h2 id="消息接收的可靠性"><a href="#消息接收的可靠性" class="headerlink" title="消息接收的可靠性"></a>消息接收的可靠性</h2><p>暂时不支持，只能使用事务且手动提交offset方式来实现</p><h1 id="Consumer重复消费怎么处理"><a href="#Consumer重复消费怎么处理" class="headerlink" title="Consumer重复消费怎么处理"></a>Consumer重复消费怎么处理</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>笔者基于java做了一个动态添加topic，并落地数据到Hbase的功能，其他同事在复用消费topic代码做实时统计时，出现重复消费，导致统计结果不准的现象，因为写入数据到Hbase是幂等的，重复消费所以未出现问题，但是重复消费会影响到统计结果</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>使用Kafka时，禁止offset自动提交，消费者每次poll的数据业务处理时间超过kafka的max.poll.interval.ms，默认是300秒，导致kafka的broker认为consumer挂掉，触发kafka进行rebalance动作，导致重新消费</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>一般消费方式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer<span class="selector-class">.subscribe</span>(topicName,rebalance)</span><br><span class="line">consumer<span class="selector-class">.poll</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>上述消费方式都会存在处理消息时长超过max.poll.interval.ms配置值风险，导致rebalance，所以最根本的解决方式，就是避免kafka进行rebalance动作，消费代码可使用如下方式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;TopicPartition&gt; newPartitionAssignments =</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;(newPartitions.size() + oldPartitionAssignmentsToPosition.size());</span><br><span class="line">newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet());</span><br><span class="line">newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions));</span><br><span class="line"></span><br><span class="line"><span class="comment">// reassign with the new partitions</span></span><br><span class="line">consumer.assign(newPartitionAssignments);</span><br><span class="line">consumer.seek(topicPartition, offset)</span><br></pre></td></tr></table></figure><p>主要思想是consumer指定消费topic的对应的分区，并从指定offset进行消费，来避免kafka的rebalance动作，引起重复消费，当然这会增加消费逻辑的复杂度，需考虑很多异常情况，如consumer实例下线怎么处理，新增consumer实例，超过topic分区数怎么处理等等，可参照spark structure streaming,flink消费kafka源码实现</p><p>参考<a href="https://www.jianshu.com/p/c358a78bc92c">https://www.jianshu.com/p/c358a78bc92c</a></p><h1 id="Kafka在分布式情况下如何保证消息的有序性"><a href="#Kafka在分布式情况下如何保证消息的有序性" class="headerlink" title="Kafka在分布式情况下如何保证消息的有序性"></a>Kafka在分布式情况下如何保证消息的有序性</h1><ol><li><p>同一个partition消息是有序的</p></li><li><p>Kafka 中发送1条消息的时候，可以指定(topic, partition, key) 3个参数</p><p>指定partition参数，则发往同一个partition的消息是有序的</p><p>指定key，具有同一个key的所有消息都会发送到一个partiton，也能够保证局部有序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3下配置spark环境</title>
      <link href="/2020/07/10/ambari%E6%98%BE%E7%A4%BAheartbeat_lost%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/10/ambari%E6%98%BE%E7%A4%BAheartbeat_lost%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在&#x2F;etc&#x2F;profile中增加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_191</span><br><span class="line">export PYSPARK_PYTHON=/usr/python3/bin/python3</span><br><span class="line">export PYSPARK_DRIVER_PYTHON=/usr/python3/bin/python3</span><br><span class="line">export PYSPARK_SUBMIT_ARGS=&quot;--master local pyspark-shell&quot;</span><br><span class="line">export HADOOP_USER_CLASSPATH_FIRST=true</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export MAVEN_HOME=/usr/local/maven/apache-maven-3.5.4</span><br><span class="line">export SPARK_HOME=/usr/hdp/2.6.5.0-292/spark2</span><br><span class="line">export HADOOP_HOME=/usr/hdp/current/hadoop-client</span><br><span class="line">export HIVE_HOME=/usr/hdp/current/hive-server2-hive2</span><br><span class="line">export PATH=$SPARK_HOME/bin:$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>再执行</p><p>source &#x2F;etc&#x2F;profile</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3下配置spark环境</title>
      <link href="/2020/07/10/centos7%E8%BF%9E%E6%8E%A5wpa%20enterprise%E4%BC%81%E4%B8%9A%E7%BA%A7wifi/"/>
      <url>/2020/07/10/centos7%E8%BF%9E%E6%8E%A5wpa%20enterprise%E4%BC%81%E4%B8%9A%E7%BA%A7wifi/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">network-manager.nmcli connection edit <span class="built_in">type</span> 802-11-wireless</span></span><br><span class="line"><span class="meta prompt_">nmcli&gt; </span><span class="language-bash">goto 802-11-wireless</span></span><br><span class="line">nmcli 802-11-wireless&gt; set ssid &lt;your_ssid&gt;</span><br><span class="line">nmcli 802-11-wireless&gt; back</span><br><span class="line"><span class="meta prompt_">nmcli&gt; </span><span class="language-bash">goto 802-11-wireless-security</span></span><br><span class="line">nmcli 802-11-wireless-security&gt; set key-mgmt wpa-eap</span><br><span class="line">nmcli 802-11-wireless-security&gt; set auth-alg open</span><br><span class="line">nmcli 802-11-wireless-security&gt; back</span><br><span class="line"><span class="meta prompt_">nmcli&gt; </span><span class="language-bash">goto 802-1x</span></span><br><span class="line">nmcli 802-1x&gt; set eap peap</span><br><span class="line">nmcli 802-1x&gt; set identity &lt;your_identity&gt;</span><br><span class="line">nmcli 802-1x&gt; set password &lt;your_password&gt;</span><br><span class="line">nmcli 802-1x&gt; set phase2-auth mschapv2</span><br><span class="line">nmcli 802-1x&gt; back</span><br><span class="line"><span class="meta prompt_">nmcli&gt; </span><span class="language-bash">verify</span></span><br><span class="line"><span class="meta prompt_">nmcli&gt; </span><span class="language-bash">save</span></span><br><span class="line">Saving the connection with &#x27;autoconnect=yes&#x27;. That might result in an immediate activation of the connection.</span><br><span class="line">Do you still want to save? (yes/no) [yes] yes</span><br><span class="line">Connection &#x27;wifi&#x27; (20e7bab0-6780-45a7-b650-eafb28e7912a) successfully saved.</span><br></pre></td></tr></table></figure><p> 保存后就自动连上了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-无重复最长子串</title>
      <link href="/2020/07/07/%E7%AE%97%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/07/07/%E7%AE%97%E6%B3%95-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h1 id="首次代码"><a href="#首次代码" class="headerlink" title="首次代码"></a>首次代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.leetcode.leetcode_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/7/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.该题可以用动态划块解决，startIndex表示划块起始位置，endIndex为结束为止</span></span><br><span class="line"><span class="comment"> * 2.stringBuffer为动态划块中字符串的内容</span></span><br><span class="line"><span class="comment"> * 3.每次循环endIndex加1，如果stringBuffer包含sArr[endIndex]，使用for循环查找最后一次该值在sArr中出现的位置，并将startIndex+1作为该值的起始位（substr时候去掉该值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">aStr</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="type">char</span>[] sArr = aStr.toCharArray();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">max</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sArr.length) &#123;</span><br><span class="line">      maxLength = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == sArr.length) &#123;</span><br><span class="line">      maxLength = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sArr.length) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!stringBuffer.toString().contains(sArr[i] + <span class="string">&quot;&quot;</span>)) &#123; <span class="comment">//不包含sArr[endIndex]，增加划块长度</span></span><br><span class="line">        endIndex++;</span><br><span class="line">        <span class="keyword">if</span> (endIndex - startIndex &gt; maxLength) &#123;</span><br><span class="line">          maxLength = endIndex - startIndex;</span><br><span class="line">          max = aStr.substring(startIndex, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuffer.delete(<span class="number">0</span>, stringBuffer.length()).append(aStr.substring(startIndex, endIndex));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//包含startIndex增加，直到sArr[i]不再被包含</span></span><br><span class="line">        <span class="keyword">while</span> (endIndex &lt;= i &amp;&amp; startIndex &lt; endIndex) &#123; <span class="comment">//endIndex表示新加入的char，用循环获取最后一次出现的位置</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> endIndex - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sArr[j] == sArr[endIndex]) &#123;</span><br><span class="line">              startIndex = j + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          endIndex++;</span><br><span class="line">          stringBuffer.delete(<span class="number">0</span>, stringBuffer.length()).append(aStr.substring(startIndex, endIndex));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最长连续</span></span><br><span class="line">    <span class="comment">//System.out.println(max);</span></span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.lengthOfLongestSubstring(<span class="string">&quot;aab&quot;</span>);</span><br><span class="line">    System.out.println(len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见OOM及原因分析</title>
      <link href="/2020/07/06/LinkedMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84/"/>
      <url>/2020/07/06/LinkedMap%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h3 id="LinkedMap为什么是有序Map"><a href="#LinkedMap为什么是有序Map" class="headerlink" title="LinkedMap为什么是有序Map"></a>LinkedMap为什么是有序Map</h3><p>LinkedMap底层存储是数组，初始大小为16</p><p>LinkedMap返回的set是有序的，是因为KeySet中的iterator是有序的</p><p>LinkedMap在put时候，使用for循环，且起始位置用hashIndex算出来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashIndex</span><span class="params">(<span class="type">int</span> hashCode, <span class="type">int</span> dataSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hashCode &amp; dataSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        key = <span class="built_in">this</span>.convertKey(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> <span class="built_in">this</span>.hash(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.hashIndex(hashCode, <span class="built_in">this</span>.data.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(AbstractHashedMap.<span class="type">HashEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="built_in">this</span>.data[index]; entry != <span class="literal">null</span>; entry =    entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.hashCode == hashCode &amp;&amp; <span class="built_in">this</span>.isEqualKey(key, entry.key)) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                <span class="built_in">this</span>.updateEntry(entry, value);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.addMapping(index, hashCode, key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见OOM及原因分析</title>
      <link href="/2020/07/06/OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2020/07/06/OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="常见OOM类型"><a href="#常见OOM类型" class="headerlink" title="常见OOM类型"></a>常见OOM类型</h1><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>错误信息：java.lang.OutOfMemoryError: Java heap space </p><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。 </p><span id="more"></span><h3 id="Java-堆溢出排查解决思路"><a href="#Java-堆溢出排查解决思路" class="headerlink" title="Java 堆溢出排查解决思路"></a>Java 堆溢出排查解决思路</h3><ol><li>查找关键报错信息，如</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><ol><li>使用内存映像分析工具（如Eclipsc Memory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链，修复应用程序中的内存泄漏。</li><li>如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 -Xmx 增加堆大小。</li></ol><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create <span class="keyword">new</span> <span class="title class_">native</span> thread</span><br></pre></td></tr></table></figure><p>关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；</li><li>如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</li></ul><h3 id="栈溢出原因"><a href="#栈溢出原因" class="headerlink" title="栈溢出原因"></a>栈溢出原因</h3><ul><li>在单个线程下，栈帧太大，或者虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出StackOverflowError 异常。</li><li>不断地建立线程的方式会导致内存溢出</li></ul><h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace </span><br></pre></td></tr></table></figure><p> 方法区，（又叫永久代，JDK8后，元空间替换了永久代），用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。运行时产生大量的类，会填满方法区，造成溢出。 </p><h3 id="方法区溢出原因"><a href="#方法区溢出原因" class="headerlink" title="方法区溢出原因"></a>方法区溢出原因</h3><ul><li>使用CGLib生成了大量的代理类，导致方法区被撑爆</li><li>在Java7之前，频繁的错误使用String.intern方法</li><li>大量jsp和动态产生jsp</li><li>应用长时间运行，没有重启</li></ul><h3 id="方法区溢出排查解决思路"><a href="#方法区溢出排查解决思路" class="headerlink" title="方法区溢出排查解决思路"></a>方法区溢出排查解决思路</h3><ul><li>检查是否永久代空间设置得过小</li><li>检查代码是否频繁错误得使用String.intern方法</li><li>检查是否跟jsp有关。</li><li>检查是否使用CGLib生成了大量的代理类</li><li>重启大法，重启JVM</li></ul><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Direct buffer memory</span><br></pre></td></tr></table></figure><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。但是，这部分内存也被频繁地使用，而且也可能导致OOM。</p><p>在JDK1.4 中新加入了NIO(New Input&#x2F;Output)类，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><h3 id="直接内存溢出原因"><a href="#直接内存溢出原因" class="headerlink" title="直接内存溢出原因"></a>直接内存溢出原因</h3><ul><li>本机直接内存的分配虽然不会受到Java 堆大小的限制，但是受到本机总内存大小限制。</li><li>直接内存由 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</li><li>NIO程序中，使用ByteBuffer.allocteDirect(capability)分配的是直接内存，可能导致直接内存溢出。</li></ul><h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><ul><li>检查代码是否恰当</li><li>检查JVM参数-Xmx，-XX:MaxDirectMemorySize 是否合理</li></ul><h2 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded </span><br></pre></td></tr></table></figure><ul><li>这个是JDK6新加的错误类型，一般都是堆太小导致的。</li><li>Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。</li><li>检查JVM参数-Xmx -Xms是否合理</li><li>dump内存，检查是否存在内存泄露，如果没有，加大内存。</li></ul><h1 id="OOM常见原因分析"><a href="#OOM常见原因分析" class="headerlink" title="OOM常见原因分析"></a>OOM常见原因分析</h1><p>Java服务出现OOM，最常见的原因是：</p><ol><li>内存确实分配过小，内存确实不够用；</li><li>某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽；</li><li>某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接；更具体的，可以按照以下步骤，使用以下工具排查。</li></ol><h2 id="确认是不是内存本身就分配过小"><a href="#确认是不是内存本身就分配过小" class="headerlink" title="确认是不是内存本身就分配过小"></a><strong>确认是不是内存本身就分配过小</strong></h2><p> jmap -heap 10765 </p><p> <img src="/images/oom.png" alt="image"> </p><p> 如上图，可以查看新生代，老生代堆内存的分配大小以及使用情况，看是否本身分配过小。 </p><h2 id="找到最耗内存的对象"><a href="#找到最耗内存的对象" class="headerlink" title="找到最耗内存的对象"></a>找到最耗内存的对象</h2><p> jmap -histo:live 10765 | more </p><p> <img src="/images/OOM2.png" alt="image"> </p><p> 需要说明的是，jmap -histo:live 会执行一次FGC，如果仍无法定位，可dump内存，通过Java内存分析工具MAT<strong>（Memory Analyzer Tool</strong>）线下进行分析。 </p><p> 上图中占内存最多的对象是RingBufferLogEvent，共占用内存18M，属于正常使用范围。如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放 </p><p>例如：<br>1.申请完资源后，未调用close()或dispose()释放资源；<br>2.消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多； </p><h2 id="确认是否是资源耗尽工具"><a href="#确认是否是资源耗尽工具" class="headerlink" title="确认是否是资源耗尽工具"></a><strong>确认是否是资源耗尽</strong>工具</h2><ol><li>pstree </li><li>netstat</li></ol><p>查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM。这里介绍另一种方法，通过&#x2F;proc&#x2F;${PID}&#x2F;fd 和 &#x2F;proc&#x2F;${PID}&#x2F;task </p><p> <img src="/images/oom3.png" alt="image"> </p><p>如上图，sshd共占用了四个句柄<br>（1）0 -&gt; 标准输入；<br>（2）1 -&gt; 标准输出；<br>（3）2 -&gt; 标准错误输出；<br>（4）3 -&gt; socket（容易想到是监听端口）；</p><p>sshd只有一个主线程PID为9339，并没有多线程。所以，只要</p><p>ll &#x2F;proc&#x2F;${PID}&#x2F;fd | wc -l<br>ll &#x2F;proc&#x2F;${PID}&#x2F;task | wc -l （效果等同pstree -p | wc -l）<br>就能知道进程打开的句柄数和线程数。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark专项训练</title>
      <link href="/2020/07/06/Spark%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/07/06/Spark%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark部署模式"><a href="#Spark部署模式" class="headerlink" title="Spark部署模式"></a>Spark部署模式</h1><ol><li>standalone模式，开启7077端口提供服务</li><li>spark on yarn模式 ：</li><li>client 模式， driver运行在客户端，调试用 </li><li>cluster模式， 分布式运行，driver运行在集群子节点</li></ol><span id="more"></span><h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><h2 id="什么是RDD"><a href="#什么是RDD" class="headerlink" title="什么是RDD"></a>什么是RDD</h2><p>弹性分布式数据集（RDD），Spark中的基本抽象。 </p><p>代表着一种不可变的，可以被并行操作的集合， 这个类包含RDD所有的基本操作，例如map,filter,perssist</p><h2 id="RDD有什么属性"><a href="#RDD有什么属性" class="headerlink" title="RDD有什么属性"></a>RDD有什么属性</h2><p> 一组分片</p><p> 一个计算每个分区的函数 </p><p> RDD之间的依赖关系 </p><p> 一个Partitioner，即RDD的分片函数。 </p><p> 一个列表，存储存取每个Partition的优先位置（preferred location） </p><h2 id="RDD弹性表现在那哪些方面"><a href="#RDD弹性表现在那哪些方面" class="headerlink" title="RDD弹性表现在那哪些方面"></a>RDD弹性表现在那哪些方面</h2><p> 自动进行磁盘和内存存储的切换 </p><p> 基于lineage的高效容错 </p><p> task执行失败会进行重试 </p><p> stage执行失败会进行重试，并且只重试失败的分片 </p><p> checkpoint和persist数据的持久化缓存 </p><h2 id="RDD的宽依赖窄依赖，stage划分"><a href="#RDD的宽依赖窄依赖，stage划分" class="headerlink" title="RDD的宽依赖窄依赖，stage划分"></a>RDD的宽依赖窄依赖，stage划分</h2><p>窄依赖： 窄依赖就是指父RDD的每个分区只被一个子RDD分区使用 </p><p>宽依赖： 宽依赖就是指父RDD的每个分区都有可能被多个子RDD分区使用， 宽依赖（shuffle）由于依赖的上游RDD不止一个，所以往往需要跨节点传输数据。 </p><p>stage： 窄依赖会被划分到同一个Stage中，这样它们就能以管道的方式迭代执行 ， 宽依赖往往对应着shuffle操作，当执行算子有shuffle操作的时候，就划分一个Stage，宽依赖是划分stage的依据 </p><p>stage容灾： 窄依赖只需要重新执行父RDD的丢失分区的计算即可恢复。 宽依赖则需要考虑恢复所有父RDD的丢失分区，并且同一RDD下的其他分区数据也重新计算了一次。  ，</p><h2 id="RDD持久化"><a href="#RDD持久化" class="headerlink" title="RDD持久化"></a>RDD持久化</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>cache是persist(STORAGE_LEVEL&#x3D;MEMORY_ONLY) </p><h3 id="Persist持久化策略"><a href="#Persist持久化策略" class="headerlink" title="Persist持久化策略"></a>Persist持久化策略</h3><p>MEMORY_ONLY ： 使用未序列化的Java对象格式，将数据保存在内存中。如果内存不够存放所有的数据，则数据可能就不会进行持久化。那么下次对这个RDD执行算子操作时，那些没有被持久化的数据，需要从源头处重新计算一遍。这是默认的持久化策略，使用cache()方法时，实际就是使用的这种持久化策略。 </p><p>MEMORY_ONLY_SER： 基本含义同MEMORY_ONLY。唯一的区别是，会将RDD中的数据进行序列化，RDD的每个partition会被序列化成一个字节数组。这种方式更加节省内存，从而可以避免持久化的数据占用过多内存导致频繁GC。 </p><p>MEMORY_AND_DISK ： 使用未序列化的Java对象格式，优先尝试将数据保存在内存中。如果内存不够存放所有的数据，会将数据写入磁盘文件中，下次对这个RDD执行算子时，持久化在磁盘文件中的数据会被读取出来使用。 </p><p>MEMORY_AND_DISK_SER ： 基本含义同MEMORY_AND_DISK。唯一的区别是，会将RDD中的数据进行序列化，RDD的每个partition会被序列化成一个字节数组。这种方式更加节省内存，从而可以避免持久化的数据占用过多内存导致频繁GC。 </p><p>DISK_ONLY： 使用未序列化的Java对象格式，将数据全部写入磁盘文件中。 </p><p>MEMORY_ONLY_2,MEMORY_AND_DISK_2 ： 对于上述任意一种持久化策略，如果加上后缀_2，代表的是将每个持久化的数据，都复制一份副本，并将副本保存到其他节点上。这种基于副本的持久化机制主要用于进行容错。假如某个节点挂掉，节点的内存或磁盘中的持久化数据丢失了，那么后续对RDD计算时还可以使用该数据在其他节点上的副本。如果没有副本的话，就只能将这些数据从源头处重新计算一遍了。 </p><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><h4 id="哪些-RDD-需要-checkpoint？"><a href="#哪些-RDD-需要-checkpoint？" class="headerlink" title="哪些 RDD 需要 checkpoint？"></a>哪些 RDD 需要 checkpoint？</h4><p> 运算时间很长或运算量太大才能得到的 RDD 或是计算链过长或依赖其他 RDD 很多的 RDD </p><h4 id="什么时候进行checkpoint"><a href="#什么时候进行checkpoint" class="headerlink" title="什么时候进行checkpoint"></a>什么时候进行checkpoint</h4><p>cache 机制是每计算出一个要 cache 的 partition 就直接将其 cache 到内存了。但 checkpoint 没有类似的方法，而是等到 job 结束后另外启动专门的 job 去完成 checkpoint 。  </p><p>因此 checkpoint 的 RDD 会被计算两次。因此，在使用 rdd.checkpoint() 的时候，建议在该语句前面加上 rdd.cache()，这样第二次运行的 job 就不用再去计算该 rdd 了，直接读取 cache 写磁盘。 </p><h4 id="Checkpoint和Cache，Persist区别"><a href="#Checkpoint和Cache，Persist区别" class="headerlink" title="Checkpoint和Cache，Persist区别"></a>Checkpoint和Cache，Persist区别</h4><h5 id="Checkpoint与Cache的区别"><a href="#Checkpoint与Cache的区别" class="headerlink" title="Checkpoint与Cache的区别"></a>Checkpoint与Cache的区别</h5><p>cache把 RDD 计算出来然后放在内存中， 但是RDD 的依赖链也不能丢掉， 当某个点某个 executor 宕了， 上面cache 的RDD就会丢掉， 需要通过依赖链重新计算出来；</p><p>checkpoint 是把 RDD 保存在 HDFS中， 是多副本可靠存储，所以依赖链就可以丢掉了，就斩断了依赖链，因为checkpoint是需要把 job 重新从头算一遍， 最好先cache一下， checkpoint就可以直接保存缓存中的 RDD 了， 就不需要重头计算一遍了， 对性能有极大的提升。 </p><h5 id="Checkpoint与Persist区别"><a href="#Checkpoint与Persist区别" class="headerlink" title="Checkpoint与Persist区别"></a>Checkpoint与Persist区别</h5><p>rdd.persist(StorageLevel.DISK_ONLY) 与 checkpoint 区别的是：前者虽然可以将 RDD 的 partition 持久化到磁盘，但该 partition 由 blockManager 管理。一旦 driver program 执行结束，也就是 executor 所在进程 CoarseGrainedExecutorBackend stop，blockManager 也会 stop，被 cache 到磁盘上的 RDD 也会被清空（整个 blockManager 使用的 local 文件夹被删除）。而 checkpoint 将 RDD 持久化到 HDFS 或本地文件夹，如果不被手动 remove 掉（ 话说怎么 remove checkpoint 过的 RDD？ ），是一直存在的，也就是说可以被下一个 driver program 使用，而 cached RDD 不能被其他 dirver program 使用。 </p><h1 id="Spark工作流"><a href="#Spark工作流" class="headerlink" title="Spark工作流"></a>Spark工作流</h1><h2 id="提交任务之后发生了什么"><a href="#提交任务之后发生了什么" class="headerlink" title="提交任务之后发生了什么"></a>提交任务之后发生了什么</h2><ol><li><p>构建Spark Application的运行环境（启动SparkContext） </p></li><li><p>SparkContext向资源管理器（可以是Standalone、Mesos或YARN）注册并申请运行Executor资源； </p></li><li><p>资源管理器分配Executor资源，Executor运行情况将随着心跳发送到资源管理器上；（yarn会分配worker上的资源，worker将运行情况随心跳发送给executor） </p></li><li><p>SparkContext构建成DAG图，将DAG图分解成Stage，并把Taskset发送给Task Scheduler </p></li><li><p>Executor向SparkContext申请Task，Task Scheduler将Task发放给Executor运行，SparkContext将应用程序代码发放给Executor。 </p></li><li><p>Task在Executor上运行，运行完毕释放所有资源。</p></li></ol><h2 id="Spark组件作用"><a href="#Spark组件作用" class="headerlink" title="Spark组件作用"></a>Spark组件作用</h2><p>master : 管理节点不参与运算 </p><p>worker : 分配任务给executor，向master汇报资源使用情况 </p><p>driver : 一个Spark作业运行时包括一个Driver进程，也是作业的主进程，具有main函数，并且有SparkContext的实例，是程序的人口点 , 作用：向集群申请资源，向master注册信息，负责作业调度（生成stage层，并将task任务分配到executor上） </p><p>sparkContext : 向yarn申请资源 </p><p>client : 提交程序的入口 </p><h2 id="对于-Spark-中的数据倾斜问题你有什么好的方案？"><a href="#对于-Spark-中的数据倾斜问题你有什么好的方案？" class="headerlink" title="对于 Spark 中的数据倾斜问题你有什么好的方案？"></a>对于 Spark 中的数据倾斜问题你有什么好的方案？</h2><h3 id="什么是数据倾斜"><a href="#什么是数据倾斜" class="headerlink" title="什么是数据倾斜"></a>什么是数据倾斜</h3><p>对 Spark&#x2F;Hadoop 这样的大数据系统来讲，数据量大并不可怕，可怕的是数据倾斜。数据倾斜指的是，并行处理的数据集中，某一部分（如 Spark 或 Kafka 的一个 Partition）的数据显著多于其它部分，从而使得该部分的处理速度成为整个数据集处理的瓶颈（木桶效应）。 </p><h3 id="数据倾斜是如何造成的"><a href="#数据倾斜是如何造成的" class="headerlink" title="数据倾斜是如何造成的"></a>数据倾斜是如何造成的</h3><p>某个stage中，包含N个task，前N-1个任务执行耗时很短，第N个执行耗时很长，这样导致无法很好利用并行，造成所有任务都在等第N个任务执行完成 </p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="调整并行度，发生数据倾斜的任务分成多个任务并行执行"><a href="#调整并行度，发生数据倾斜的任务分成多个任务并行执行" class="headerlink" title="调整并行度，发生数据倾斜的任务分成多个任务并行执行"></a>调整并行度，发生数据倾斜的任务分成多个任务并行执行</h4><p>Spark 在做 Shuffle 时，默认使用 HashPartitioner对数据进行分区。如果并行度设置的不合适，可能造成大量不相同的 Key 对应的数据被分配到了同一个 Task 上，造成该 Task 所处理的数据远大于其它 Task，从而造成数据倾斜。</p><h4 id="自定义Partitioner"><a href="#自定义Partitioner" class="headerlink" title="自定义Partitioner"></a>自定义Partitioner</h4><p>使用自定义的 Partitioner（默认为 HashPartitioner），将原本被分配到同一个 Task 的不同 Key 分配到不同 Task </p><h4 id="将-Reduce-side（侧）-Join-转变为-Map-side（侧）-Join"><a href="#将-Reduce-side（侧）-Join-转变为-Map-side（侧）-Join" class="headerlink" title="将 Reduce side（侧） Join 转变为 Map side（侧） Join"></a>将 Reduce side（侧） Join 转变为 Map side（侧） Join</h4><p>通过 Spark 的 Broadcast 机制，将 Reduce 侧 Join 转化为 Map 侧 Join，避免 Shuffle 从而完全消除 Shuffle 带来的数据倾斜。 </p><h4 id="为数据量特别大的-Key-增加随机前-x2F-后缀"><a href="#为数据量特别大的-Key-增加随机前-x2F-后缀" class="headerlink" title="为数据量特别大的 Key 增加随机前&#x2F;后缀"></a>为数据量特别大的 Key 增加随机前&#x2F;后缀</h4><p>为数据量特别大的 Key 增加随机前&#x2F;后缀，使得原来 Key 相同的数据变为 Key 不相同的数据，从而使倾斜的数据集分散到不同的 Task 中，彻底解决数据倾斜问题。Join 另一则的数据中，与倾斜 Key 对应的部分数据，与随机前缀集作笛卡尔乘积，从而保证无论数据倾斜侧倾斜 Key 如何加前缀，都能与之正常 Join。 </p><h1 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h1><h2 id="什么是Shuffle"><a href="#什么是Shuffle" class="headerlink" title="什么是Shuffle"></a>什么是Shuffle</h2><p>某种具有共同特征的数据汇聚到一个计算节点上进行计算</p><p>另一种说法： 将相同的 Key 分发至同一个 Reducer上进行处理 </p><h2 id="如何避免shuffle"><a href="#如何避免shuffle" class="headerlink" title="如何避免shuffle"></a>如何避免shuffle</h2><p>能避免则尽可能避免使用 reduceByKey、join、distinct、repartition 等会进行 shuffle 的算子, 尽量使用 map 类的非 shuffle 算子 </p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink窗口</title>
      <link href="/2020/07/03/Flink%E7%AA%97%E5%8F%A3/"/>
      <url>/2020/07/03/Flink%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是窗口"><a href="#什么是窗口" class="headerlink" title="什么是窗口"></a>什么是窗口</h1><p>Windows是处理流试计算的核心。 Windows将流分成有限个大小的“存储桶”，我们可以在“存储桶”上应用计算。</p><h1 id="窗口类型"><a href="#窗口类型" class="headerlink" title="窗口类型"></a>窗口类型</h1><h2 id="Tumbling-Window"><a href="#Tumbling-Window" class="headerlink" title="Tumbling Window"></a>Tumbling Window</h2><p>翻滚窗口，无数据重叠</p><p>滚动窗口分配器将每个元素分配给指定窗口大小的窗口。 滚动窗口具有固定的大小，并且不重叠。 例如，如果您指定大小为5分钟的翻滚窗口，则将评估当前窗口，并且每五分钟将启动一个新窗口，如下图所示。</p><span id="more"></span><p><img src="/images/tumbling-windows.svg" alt="tumbling-windows"></p><h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><p>滑动窗口，可数据重叠</p><p>滑动窗口分配器将元素分配给固定长度的窗口。和滚动窗口相比，窗口大小可以被windows param参数控制，一个额外的滑动参数控制滑动窗口的滑动频率。因此滑动窗口是可以重复的当滑动大小小于窗口大小。在这种情况下，元素可以被分配给多个窗口（可以重复）</p><p>例如：你可以存在一组长度为10分钟的窗口集合，这样你可以每隔5分钟就得到下一个窗口，且包含最近10分钟的所有事件，示意图如下所示</p><p><img src="/images/sliding-windows.svg" alt="sliding-windows"></p><h2 id="Session-Window"><a href="#Session-Window" class="headerlink" title="Session Window"></a>Session Window</h2><p>Session Window，活动时间间隙相等的窗口</p><p>会话窗口分配器按活动会话对元素进行分组。与滚动窗口和滑动窗口相比，会话窗口不重叠且没有固定的开始和结束时间。 相反，当会话窗口在一定时间段内未接收到元素时（即，发生不活动间隙时），它将关闭。 会话窗口分配器可以配置有静态会话间隔，也可以配置有会话间隔提取器功能，该功能定义不活动的时间长度。 当该时间段到期时，当前会话将关闭，随后的元素将分配给新的会话窗口。</p><p><img src="/images/session-windows.svg" alt="sliding-windows"></p><h2 id="Global-Windows"><a href="#Global-Windows" class="headerlink" title="Global Windows"></a>Global Windows</h2><p>Global Windows 全局窗口</p><p>全局窗口分配器将具有相同键的所有元素分配给同一单个全局窗口。 仅当您还指定自定义触发器时，此窗口方案才有用。 否则，将不会执行任何计算，因为全局窗口没有可以处理聚合元素的自然终点。</p><h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>在定义窗口分配器后，我们需要指定每个窗口上执行的计算。一旦系统处于就绪状态，就可以处理每个（可能是键控）窗口中的元素，这是窗口函数的职能所在（请参阅Flink如何确定窗口何时准备就绪的触发器）</p><p>窗口函数可以是ReduceFunction, AggregateFunction, FoldFunction or ProcessWindowFunction中的一种，前两个性能更高，因为在每个窗口中元素到达的时候flink是增量聚合的。一个ProcessWindowFunction函数可以为窗口中的元素获取一个迭代器，该迭代器包含一个窗口且包含窗口中元素的额外信息</p><p>使用ProcessWindowFunction进行窗口转换不能像其他情况一样有效地执行，因为Flink必须在调用函数之前在内部缓冲窗口的所有元素。可以通过将ProcessWindowFunction与ReduceFunction，AggregateFunction或FoldFunction组合使用来获得窗口元素的增量聚合以及ProcessWindowFunction接收的其他窗口元数据，从而缓解这种情况。代码示例如下。</p><h2 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h2><p>一个ReduceFunction函数指定了如何将输入中的两个元素组合，且输出一个相同类型的结果。Flink使用ReduceFunction来增量聚合窗口中的元素。</p><p>一个ReduceFunction函数可以这样来使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce(<span class="keyword">new</span> <span class="title class_">ReduceFunction</span>&lt;Tuple2&lt;String, Long&gt;&gt; &#123;</span><br><span class="line">      <span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title function_">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(v1.f0, v1.f1 + v2.f1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面的例子操作是将Tuple第二个位置上的元素相加</p><h2 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h2><p>AggregateFunction是ReduceFunction的通用版本，具有三种类型：输入类型（IN），累加器类型（ACC）和输出类型（OUT）。输入类型是输入流中元素的类型，AggregateFunction具有一种将一个输入元素添加到累加器的方法。 该接口还具有创建初始累加器，将两个累加器合并为一个累加器以及从累加器提取输出（OUT类型）的方法。 我们将在下面的示例中看到它的工作原理。</p><p>与ReduceFunction相同，Flink将在窗口的输入元素到达时对其进行增量聚合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算窗口中元素的第二个字段的平均值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AverageAggregate</span></span><br><span class="line">         <span class="keyword">implements</span> <span class="title class_">AggregateFunction</span>&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">add</span><span class="params">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Double <span class="title function_">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .aggregate(<span class="keyword">new</span> <span class="title class_">AverageAggregate</span>());</span><br></pre></td></tr></table></figure><h2 id="FoldFunction"><a href="#FoldFunction" class="headerlink" title="FoldFunction"></a>FoldFunction</h2><h2 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h2><p>ProcessWindowFunction获取一个Iterable，该Iterable包含窗口的所有元素，以及一个Context对象，该对象可以访问时间和状态信息，从而使其比其他窗口函数更具灵活性。 这是以性能和资源消耗为代价的，因为无法增量聚合元素，而是需要在内部对其进行缓冲，直到将窗口视为已准备好进行处理为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(t -&gt; t.f0)</span><br><span class="line">  .timeWindow(Time.minutes(<span class="number">5</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProcessWindowFunction</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;Tuple2&lt;String, Long&gt;, String, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tuple2&lt;String, Long&gt; in: input) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    out.collect(<span class="string">&quot;Window: &quot;</span> + context.window() + <span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例显示了一个ProcessWindowFunction，它对窗口中的元素进行计数。 另外，窗口功能将有关窗口的信息添加到输出中。</p><p>注意请注意，将ProcessWindowFunction用于简单的聚合（如count）效率很低。 下一节说明如何将ReduceFunction或AggregateFunction与ProcessWindowFunction结合使用，以获取增量聚合和ProcessWindowFunction的附加信息。</p><h2 id="ProcessWindowFunction-with-Incremental-Aggregation"><a href="#ProcessWindowFunction-with-Incremental-Aggregation" class="headerlink" title="ProcessWindowFunction with Incremental Aggregation"></a>ProcessWindowFunction with Incremental Aggregation</h2><p>可以将ProcessWindowFunction与ReduceFunction，AggregateFunction或FoldFunction组合以在元素到达窗口时对其进行增量聚合。 当窗口关闭时，将向ProcessWindowFunction提供聚合结果。 这使得它可以递增地计算窗口，同时可以访问ProcessWindowFunction的其他窗口元信息。</p><h4 id="使用ReduceFunction的增量窗口聚合"><a href="#使用ReduceFunction的增量窗口聚合" class="headerlink" title="使用ReduceFunction的增量窗口聚合"></a>使用ReduceFunction的增量窗口聚合</h4><p>以下示例显示了如何将增量ReduceFunction与ProcessWindowFunction结合使用以返回窗口中的最小事件以及该窗口的开始时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(&lt;key selector&gt;)</span><br><span class="line">  .timeWindow(&lt;duration&gt;)</span><br><span class="line">  .reduce(<span class="keyword">new</span> <span class="title class_">MyReduceFunction</span>(), <span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definitions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReduceFunction</span> <span class="keyword">implements</span> <span class="title class_">ReduceFunction</span>&lt;SensorReading&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SensorReading <span class="title function_">reduce</span><span class="params">(SensorReading r1, SensorReading r2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> r1.value() &gt; r2.value() ? r2 : r1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProcessWindowFunction</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;SensorReading, Tuple2&lt;Long, SensorReading&gt;, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String key,</span></span><br><span class="line"><span class="params">                    Context context,</span></span><br><span class="line"><span class="params">                    Iterable&lt;SensorReading&gt; minReadings,</span></span><br><span class="line"><span class="params">                    Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out)</span> &#123;</span><br><span class="line">      <span class="type">SensorReading</span> <span class="variable">min</span> <span class="operator">=</span> minReadings.iterator().next();</span><br><span class="line">      out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;Long, SensorReading&gt;(context.window().getStart(), min));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-per-window-state-in-ProcessWindowFunction"><a href="#Using-per-window-state-in-ProcessWindowFunction" class="headerlink" title="Using per-window state in ProcessWindowFunction"></a>Using per-window state in ProcessWindowFunction</h2><h1 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h1><h1 id="Evictors"><a href="#Evictors" class="headerlink" title="Evictors"></a>Evictors</h1><h1 id="Allowed-Lateness"><a href="#Allowed-Lateness" class="headerlink" title="Allowed Lateness"></a>Allowed Lateness</h1>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap如何实现的</title>
      <link href="/2020/06/30/ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/06/30/ConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Jdk1-7的ConcurrentHashMap"><a href="#Jdk1-7的ConcurrentHashMap" class="headerlink" title="Jdk1.7的ConcurrentHashMap"></a>Jdk1.7的ConcurrentHashMap</h1><p>jdk1.7中采用<code>Segment</code> + <code>HashEntry</code>的方式进行实现，结构如下：</p><p><img src="/images/jdk1.7_ConcurrentHashMap.png" alt="concurrenthashmap_java8"></p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，因为ssize用位于运算来计算（<code>ssize &lt;&lt;=1</code>），所以Segment的大小取值都是以2的N次方，无关concurrencyLevel的取值，当然concurrencyLevel最大只能用16位的二进制来表示，即65536，换句话说，Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16</p><p>每一个Segment元素下的HashEntry的初始化也是按照位于运算来计算，用cap来表示，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如上所示，HashEntry大小的计算也是2的N次方（cap &lt;&lt;&#x3D;1）， cap的初始值为1，所以HashEntry最小的容量为2</p><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置</p><p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒</p><h1 id="Jdk1-8-ConcurrentHashMap"><a href="#Jdk1-8-ConcurrentHashMap" class="headerlink" title="Jdk1.8 ConcurrentHashMap"></a>Jdk1.8 ConcurrentHashMap</h1><p>Java 8为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）。其数据结构如下图所示</p><span id="more"></span><p><img src="/images/concurrenthashmap_java8.png" alt="concurrenthashmap_java8"></p><h2 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h2><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink提交任务</title>
      <link href="/2020/06/26/Flink%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/"/>
      <url>/2020/06/26/Flink%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Flink以YarnCluster模式提交任务，且指定任务名和队列</p><p>flink run -m yarn-cluster -ynm PROD-fink-data-gather  –yarnqueue CClient &#x2F;home&#x2F;cclient&#x2F;danke-flink-data-gather-prod.jar</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink中的并行度</title>
      <link href="/2020/06/25/Flink%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6/"/>
      <url>/2020/06/25/Flink%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Parallel-Execution（并行执行）"><a href="#Parallel-Execution（并行执行）" class="headerlink" title="Parallel Execution（并行执行）"></a>Parallel Execution（并行执行）</h1><p>一个任务被切分成几个并行实例执行，且每个并行实例处理输入任务的一部分数据，并行度会导致乱序问题，任务的并行实力数称为并行性</p><p>可以从三个层面限制并行度</p><h2 id="Execution-Environment-Level"><a href="#Execution-Environment-Level" class="headerlink" title="Execution Environment Level"></a>Execution Environment Level</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.setParallelism(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Client-Level"><a href="#Client-Level" class="headerlink" title="Client Level"></a>Client Level</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Client</span>(jobManagerAddress, config, program.getUserCodeClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the parallelism to 10 here</span></span><br><span class="line">client.run(program, <span class="number">10</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="System-Level"><a href="#System-Level" class="headerlink" title="System Level"></a>System Level</h2><p>在.&#x2F;conf&#x2F;flink-conf.yaml中配置parallelism.default来设置并行度</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>如果使用checkpoint的话需要设置一个最大并行度，避免从savepoint恢复时候导致性能问题</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink中的水印与时间</title>
      <link href="/2020/06/25/Flink%E6%97%B6%E9%97%B4/"/>
      <url>/2020/06/25/Flink%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="watermark-水印）"><a href="#watermark-水印）" class="headerlink" title="watermark(水印）"></a>watermark(水印）</h1><p>Flink中用于衡量event time进度的机制叫做水印</p><span id="more"></span><h2 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h2><p>watermark流(水印流)作为数据流的一部分，并带有一个时间戳t，当watermark t声明event time达到了t时刻，表名该数据流中不存在时间戳t&#96;&lt;&#x3D; t的元素</p><h2 id="对于watermark的理解"><a href="#对于watermark的理解" class="headerlink" title="对于watermark的理解"></a>对于watermark的理解</h2><p>在下文中的例子中，我们有一个带有时间戳的事件流，但是由于某种原因它们并不是按顺序到达的。图中的数字代表事件发生的时间戳。第一个到达的事件发生在时间 4，然后它后面跟着的是发生在更早时间（时间 2）的事件，以此类推：</p><p><img src="/images/warter_mark.png" alt="warter_mark"></p><p>注意这是一个按照事件时间处理的例子，这意味着时间戳反映的是事件发生的时间，而不是处理事件的时间。事件时间（Event-Time）处理的强大之处在于，无论是在处理实时的数据还是重新处理历史的数据，基于事件时间创建的流计算应用都能保证结果是一样的。</p><p>现在假设我们正在尝试创建一个流计算排序算子。也就是处理一个乱序到达的事件流，并按照事件时间的顺序输出事件。</p><h3 id="理解1"><a href="#理解1" class="headerlink" title="理解1"></a>理解1</h3><p>数据流中的第一个元素的时间是 4，但是我们不能直接将它作为排序后数据流的第一个元素并输出它。因为数据是乱序到达的，也许有一个更早发生的数据还没有到达。事实上，我们能预见一些这个流的未来，也就是我们的排序算子至少要等到 2 这条数据的到达再输出结果。</p><p><em>有缓存，就必然有延迟。</em></p><h3 id="理解2"><a href="#理解2" class="headerlink" title="理解2"></a>理解2</h3><p>如果我们做错了，我们可能会永远等待下去。首先，我们的应用程序从看到时间 4 的数据，然后看到时间 2 的数据。是否会有一个比时间 2 更早的数据到达呢？也许会，也许不会。我们可以一直等下去，但可能永远看不到 1 。</p><p><em>最终，我们必须勇敢地输出 2 作为排序流的第一个结果。</em></p><h3 id="理解3"><a href="#理解3" class="headerlink" title="理解3"></a>理解3</h3><p>我们需要的是某种策略，它定义了对于任何带时间戳的事件流，何时停止等待更早数据的到来。</p><p><em>这正是 watermark 的作用，他们定义了何时不再等待更早的数据。</em></p><p>Flink 中的事件时间处理依赖于一种特殊的带时间戳的元素，成为 watermark，它们会由数据源或是 watermark 生成器插入数据流中。具有时间戳 t 的 watermark 可以被理解为断言了所有时间戳小于或等于 t 的事件都（在某种合理的概率上）已经到达了。</p><p>何时我们的排序算子应该停止等待，然后将事件 2 作为首个元素输出？答案是当收到时间戳为 2（或更大）的 watermark 时。</p><h3 id="理解4"><a href="#理解4" class="headerlink" title="理解4"></a>理解4</h3><p><em>我们可以设想不同的策略来生成 watermark。</em></p><p>我们知道每个事件都会延迟一段时间才到达，而这些延迟差异会比较大，所以有些事件会比其他事件延迟更多。一种简单的方法是假设这些延迟不会超过某个最大值。Flink 把这种策略称作 “有界无序生成策略”（bounded-out-of-orderness）。当然也有很多更复杂的方式去生成 watermark，但是对于大多数应用来说，固定延迟的方式已经足够了。</p><h1 id="Flink中的时间"><a href="#Flink中的时间" class="headerlink" title="Flink中的时间"></a>Flink中的时间</h1><h2 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h2><p>事件时间指事件在设备上的发生时间，该时间通常在消息进入Flink之前发生，且该事件发生的时间戳可以从每条记录单独提取</p><h2 id="Ingestion-Time-摄取时间"><a href="#Ingestion-Time-摄取时间" class="headerlink" title="Ingestion Time(摄取时间)"></a>Ingestion Time(摄取时间)</h2><p>摄取时间指的是消息进入flink的时间</p><h2 id="Processing-Time"><a href="#Processing-Time" class="headerlink" title="Processing Time"></a>Processing Time</h2><p>处理时间指的是执行某个任务时的系统时间，在消息进入flink且被window处理时发生</p><h2 id="三种时间关系示意图"><a href="#三种时间关系示意图" class="headerlink" title="三种时间关系示意图"></a>三种时间关系示意图</h2><p><img src="/images/times_clocks.svg" alt="times_clocks"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用arthas分析presto宕机原因</title>
      <link href="/2020/06/20/arthas/"/>
      <url>/2020/06/20/arthas/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Presto半夜总是宕机</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>使用arthas分析jvm使用情况</p><span id="more"></span><h2 id="下载arthas"><a href="#下载arthas" class="headerlink" title="下载arthas"></a>下载arthas</h2><p> curl -O <a href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a> </p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="thread命令查看最占CPU的线程"><a href="#thread命令查看最占CPU的线程" class="headerlink" title="thread命令查看最占CPU的线程"></a>thread命令查看最占CPU的线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#展示当前最忙的前N个线程并打印堆栈</span><br><span class="line">thread -n 3 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql迁移数据目录解决磁盘不足问题</title>
      <link href="/2020/06/18/mysql%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/18/mysql%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A7%A3%E5%86%B3%E7%A3%81%E7%9B%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>先关闭mysql数据库</p><p>mv &#x2F;var&#x2F;lib&#x2F;mysql &#x2F;data&#x2F;mysql_data</p><span id="more"></span><p>创建目录</p><p>mkdir &#x2F;data&#x2F;mysql_data</p><p>chown mysql:mysql &#x2F;data&#x2F;mysql_data</p><p>做软连接</p><p>ln -s &#x2F;data&#x2F;mysql_data&#x2F;mysql &#x2F;var&#x2F;lib&#x2F;mysql</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-相交链表</title>
      <link href="/2020/06/17/%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/06/17/%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p> 编写一个程序，找到两个单链表相交的起始节点。 </p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针</p><p>因为两个链表长度可能不一样，但是相交后的元素都是一样的，可以使用快慢指针</p><p>***** 分别遍历链表，获取其长度，长链表命名为quickNode，短链表命名为slowNode，二者长度差为quickStep</p><p>***** quickNode先运行quickStep步之后，此时两个链表长度相等，用一个循环就能找到相同起始节点</p><span id="more"></span><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">aLength</span> <span class="operator">=</span> getLength(headA);</span><br><span class="line">        <span class="type">int</span> <span class="variable">bLength</span> <span class="operator">=</span> getLength(headB);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">quickNode</span> <span class="operator">=</span> aLength &gt; bLength ? headA : headB;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slowNode</span> <span class="operator">=</span> aLength &gt; bLength ? headB : headA;</span><br><span class="line">        <span class="type">int</span> <span class="variable">quickStep</span> <span class="operator">=</span> aLength &gt; bLength ? aLength - bLength : bLength - aLength;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> quickStep; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            quickNode = quickNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (quickNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (quickNode == slowNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> quickNode;</span><br><span class="line">            &#125;</span><br><span class="line">            quickNode = quickNode.next;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">aNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (aNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            aNode = aNode.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inode磁盘清理</title>
      <link href="/2020/06/15/inode%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/"/>
      <url>/2020/06/15/inode%E7%A3%81%E7%9B%98%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>硬盘有剩余空间但一直提示no device space left，使用df -hl查看磁盘还有空间</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>使用df -i查看inode，发现占用率100%，说明碎片文件过多超过linux的文件数量的限制，使用如下命令查找碎片文件文件，并清理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -xdev -printf &#x27;%h\n&#x27; | sort | uniq -c | sort -k 1 -n</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建落地临时表写入很慢导致异常的解决方法</title>
      <link href="/2020/06/15/%E5%BB%BA%E8%90%BD%E5%9C%B0%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%86%99%E5%85%A5%E5%BE%88%E6%85%A2%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/15/%E5%BB%BA%E8%90%BD%E5%9C%B0%E4%B8%B4%E6%97%B6%E8%A1%A8%E5%86%99%E5%85%A5%E5%BE%88%E6%85%A2%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><p>建表时候指定为ORC格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orc_table_with_null STORED <span class="keyword">AS</span> ORC <span class="keyword">AS</span> <span class="keyword">SELECT</span> x,nullFROM <span class="keyword">empty</span>;</span><br></pre></td></tr></table></figure><p>Hive命令行调试模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive --hiveconf hive.root.logger=DEBUG,console</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beeline请求被提交到已经删除的hiveserver2节点</title>
      <link href="/2020/06/15/%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8F%90%E4%BA%A4%E5%88%B0%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84hiveserver2/"/>
      <url>/2020/06/15/%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8F%90%E4%BA%A4%E5%88%B0%E5%B7%B2%E7%BB%8F%E5%88%A0%E9%99%A4%E7%9A%84hiveserver2/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在ambari集群上bigdata-client节点做hiveserver2自动拉起测试，增加了一个hiveserver2，然后再ambari删除该hiveserver2</p><p>然后出现请求被提交到已经删除的hiveserver2节点</p><p><img src="/images/image-20200614163951660.png" alt="image-20200614163951660"></p><p>在zookeeper节点上执行zookeeper-cli.sh进入zookeeper命令行</p><p>执行删除无效的节点命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete /hiveserver2/serverUri=bigdata-client:10000;version=1.2.1000.2.6.5.1175-1;sequence=0000000010</span><br></pre></td></tr></table></figure><p>过一段时间还是会出现上述错误，之后发现自动拉起服务没删除……</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 2.两数相加</title>
      <link href="/2020/06/14/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2020/06/14/%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h1><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><span id="more"></span><p>链表ListNode结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.leetcode.leetcode_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第一次实现代码"><a href="#第一次实现代码" class="headerlink" title="第一次实现代码"></a>第一次实现代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bd.leetcode.leetcode_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode l1)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">arr2ListNode</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                firstNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">oldNode</span> <span class="operator">=</span> firstNode;</span><br><span class="line">                firstNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>(arr[i]);</span><br><span class="line">                firstNode.next = oldNode;</span><br><span class="line"><span class="comment">//                ListNode oldNode = firstNode;</span></span><br><span class="line"><span class="comment">//                firstNode = new ListNode(arr[i],oldNode);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode a)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> a;</span><br><span class="line">        ListNode tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != cur) &#123;</span><br><span class="line">            tmp = cur.next; <span class="comment">// 保存当前节点的下一个节点</span></span><br><span class="line">            cur.next = pre; <span class="comment">// 把当前节点的下一个节点重置为上一个节点</span></span><br><span class="line">            pre = cur; <span class="comment">//下次遍历时候需要使用的上一个节点</span></span><br><span class="line">            cur = tmp; <span class="comment">//下次遍历时候需要的当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1Len</span> <span class="operator">=</span> getLength(l1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2Len</span> <span class="operator">=</span> getLength(l2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> l1Len &gt;= l2Len ? l1Len : l2Len;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l1Value</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l2Value</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1Value + l2Value + flag &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                currVal = l1Value + l2Value + flag - <span class="number">10</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currVal = l1Value + l2Value + flag;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">                first = <span class="keyword">new</span> <span class="title class_">ListNode</span>(currVal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">oldFirst</span> <span class="operator">=</span> first;</span><br><span class="line">                first = <span class="keyword">new</span> <span class="title class_">ListNode</span>(currVal);</span><br><span class="line">                first.next = oldFirst;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            l1 = l1 != <span class="literal">null</span> ? l1.next : <span class="literal">null</span>;</span><br><span class="line">            l2 = l2 != <span class="literal">null</span> ? l2.next : <span class="literal">null</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; len || flag &gt; <span class="number">0</span>);<span class="comment">//flag&gt;0说明有进位需要再次执行一边</span></span><br><span class="line">        <span class="keyword">return</span> reverse(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">(ListNode a)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">            s.append(a.val).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> s.arr2ListNode(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> s.arr2ListNode(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">9</span>, <span class="number">9</span>&#125;);</span><br><span class="line">        s.walk(a);</span><br><span class="line">        s.walk(b);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">c</span> <span class="operator">=</span> s.addTwoNumbers(a, b);</span><br><span class="line">        s.walk(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化后代码"><a href="#优化后代码" class="headerlink" title="优化后代码"></a>优化后代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">//记录假head节点位置，真head为root.next</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cursor</span> <span class="operator">=</span> root; </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span> || flag &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l1Value</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l2Value</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1Value + l2Value + flag &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                currVal = l1Value + l2Value + flag - <span class="number">10</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currVal = l1Value + l2Value + flag;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cursor.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(currVal);</span><br><span class="line">            cursor = cursor.next;  <span class="comment">// 指针后移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            l1 = l1 != <span class="literal">null</span> ? l1.next : <span class="literal">null</span>;</span><br><span class="line">            l2 = l2 != <span class="literal">null</span> ? l2.next : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ambari集群安装</title>
      <link href="/2020/06/03/Ambari%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/"/>
      <url>/2020/06/03/Ambari%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h2 id="目前的机器"><a href="#目前的机器" class="headerlink" title="目前的机器"></a>目前的机器</h2><p>172.22.222.109</p><h2 id="安装ambari-server"><a href="#安装ambari-server" class="headerlink" title="安装ambari-server"></a>安装ambari-server</h2><p>在&#x2F;etc&#x2F;yum.repos.d&#x2F;ambari.repo中新增ambari源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/yum.repos.d/ambari.repo</span><br><span class="line">#VERSION_NUMBER=2.6.2.2-1</span><br><span class="line">[ambari-2.6.2.2]</span><br><span class="line">name=ambari Version - ambari-2.6.2.2</span><br><span class="line">baseurl=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.2</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.6.2.2/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</span><br><span class="line">enabled=1</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure><p>执行安装命令</p><p>yum install install ambari-server</p><h2 id="安装MariaDB-10-1"><a href="#安装MariaDB-10-1" class="headerlink" title="安装MariaDB 10.1"></a>安装MariaDB 10.1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/yum.repos.d/Mariadb.repo</span><br><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = https://mirrors.tuna.tsinghua.edu.cn/mariadb/yum/10.1/centos7-amd64</span><br><span class="line">gpgkey = https://mirrors.tuna.tsinghua.edu.cn/mariadb/yum//RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck=1</span><br><span class="line"></span><br><span class="line">yum install mariadb-server mariadb mariadb-client mariadb-devel</span><br></pre></td></tr></table></figure><h2 id="部署的目录"><a href="#部署的目录" class="headerlink" title="部署的目录"></a>部署的目录</h2><p>&#x2F;var&#x2F;lib&#x2F;ambari-server</p><h2 id="web访问地址"><a href="#web访问地址" class="headerlink" title="web访问地址"></a>web访问地址</h2><p><a href="http://172.22.222.109:9090/">http://172.22.222.109:9090</a></p><h2 id="配置文件的位置"><a href="#配置文件的位置" class="headerlink" title="配置文件的位置"></a>配置文件的位置</h2><p>&#x2F;etc&#x2F;ambari-server&#x2F;conf</p><h2 id="管理脚本"><a href="#管理脚本" class="headerlink" title="管理脚本"></a>管理脚本</h2><p>service ambari-server status</p><p>service ambari-server restart</p><p>service ambari-server stop</p><p>service ambari-server start</p><h2 id="添加Client机器报SSL错误问题"><a href="#添加Client机器报SSL错误问题" class="headerlink" title="添加Client机器报SSL错误问题"></a>添加Client机器报SSL错误问题</h2><p>编辑要增加的客户端机器&#x2F;etc&#x2F;ambari-agent&#x2F;conf&#x2F;ambari-agent.ini</p><p>在security标签增加</p><p>force_https_protocol&#x3D;PROTOCOL_TLSv1_2</p><h2 id="安装时报删除服务失败问题"><a href="#安装时报删除服务失败问题" class="headerlink" title="安装时报删除服务失败问题"></a>安装时报删除服务失败问题</h2><p>查看&#x2F;var&#x2F;log&#x2F;ambari-server&#x2F;ambari-server.log日志报</p><p><em>Caught AmbariException when modifying a resource</em><br><em>org.apache.ambari.server.AmbariException: Could not delete cluster, clusterName&#x3D;localvps</em></p><p><em>01 Apr 2020 12:26:06,836 WARN [ambari-client-thread-34] ServiceComponentImpl:492 - Found non removable hostcomponent when trying to delete service component, clusterName&#x3D;localvps, serviceName&#x3D;HIVE, componentName&#x3D;MYSQL_SERVER, state&#x3D;STARTED, hostname&#x3D;localvps</em><br><em>01 Apr 2020 12:26:06,836 WARN [ambari-client-thread-34] ServiceImpl:509 - Found non removable component when trying to delete service, clusterName&#x3D;localvps, serviceName&#x3D;HIVE, componentName&#x3D;MYSQL_SERVER</em></p><p>这个问题是由于安装hive时候选择New Database，之后又选择exist Database导致的，删除mysql数据库后重新安装MariaDB 10.1之后该问题消失</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装superset</title>
      <link href="/2020/06/03/Docker%E5%AE%89%E8%A3%85superset/"/>
      <url>/2020/06/03/Docker%E5%AE%89%E8%A3%85superset/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="挂载目录到本地"><a href="#挂载目录到本地" class="headerlink" title="挂载目录到本地"></a>挂载目录到本地</h1><p>mkdir &#x2F;Users&#x2F;yangaipeng&#x2F;Desktop&#x2F;incubator-superset&#x2F;docker_superset&#x2F;superset</p><h1 id="启动docker-superset"><a href="#启动docker-superset" class="headerlink" title="启动docker superset"></a>启动docker superset</h1><p>docker run -d -p 8088:8088 -v &#x2F;Users&#x2F;yangaipeng&#x2F;Desktop&#x2F;incubator-superset&#x2F;docker_superset&#x2F;superset:&#x2F;home&#x2F;superset –name superset2 superset-release-tag</p><h1 id="增加配置文件"><a href="#增加配置文件" class="headerlink" title="增加配置文件"></a>增加配置文件</h1><p>将配置文件superset_config.py放到&#x2F;Users&#x2F;yangaipeng&#x2F;Desktop&#x2F;incubator-superset&#x2F;docker_superset&#x2F;superset目录下</p><p>在superset_config.py将mysql地址配置为host.docker.internal，表示让docker中的superset访问本机数据库</p><h1 id="设置用户名和密码"><a href="#设置用户名和密码" class="headerlink" title="设置用户名和密码"></a>设置用户名和密码</h1><p>docker exec -it 2326fa0a7d8b fabmanager create-admin –app superset</p><h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><p>docker exec -it 2326fa0a7d8b superset db upgrade</p><h1 id="superset初始化"><a href="#superset初始化" class="headerlink" title="superset初始化"></a>superset初始化</h1><p>docker exec -it 2326fa0a7d8b superset init</p><h1 id="开启superset服务"><a href="#开启superset服务" class="headerlink" title="开启superset服务"></a>开启superset服务</h1><p>docker exec -it 2326fa0a7d8b superset runserver</p><h1 id="使用root用户运行docker-bash"><a href="#使用root用户运行docker-bash" class="headerlink" title="使用root用户运行docker bash"></a>使用root用户运行docker bash</h1><p>docker –user root -it exec 1b9e081ef94f bash</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hue配置Presto</title>
      <link href="/2020/06/03/Hue%E9%85%8D%E7%BD%AEPresto/"/>
      <url>/2020/06/03/Hue%E9%85%8D%E7%BD%AEPresto/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="python3安装pyhive"><a href="#python3安装pyhive" class="headerlink" title="python3安装pyhive"></a>python3安装pyhive</h1><p>进入hue安装目录&#x2F;usr&#x2F;local&#x2F;hue&#x2F;hue-4.3.0&#x2F;</p><p>.&#x2F;build&#x2F;env&#x2F;bin&#x2F;pip install pyhive</p><p>在&#x2F;usr&#x2F;local&#x2F;hue&#x2F;hue-4.3.0&#x2F;desktop目录编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim desktop/conf/hue.ini</span><br><span class="line">[[[presto]]]</span><br><span class="line">      name = Presto</span><br><span class="line">      interface=sqlalchemy</span><br><span class="line">      options=&#x27;&#123;&quot;url&quot;: &quot;presto://172.22.222.89:9090/hive_danke/default&quot;&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重启hue"><a href="#重启hue" class="headerlink" title="重启hue"></a>重启hue</h1><p>kill pid </p><p>&#x2F;usr&#x2F;local&#x2F;hue&#x2F;hue-4.3.0&#x2F;build&#x2F;env&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;local&#x2F;hue&#x2F;hue-4.3.0&#x2F;build&#x2F;env&#x2F;bin&#x2F;hue runcherrypyserver</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收算法与收集器</title>
      <link href="/2020/06/03/JVM%E7%AE%97%E6%B3%95/"/>
      <url>/2020/06/03/JVM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="垃圾回收方法"><a href="#垃圾回收方法" class="headerlink" title="垃圾回收方法"></a>垃圾回收方法</h1><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>适用：年轻带，年老带</p><p>缺点：不连续内存碎片，导致大对象直接进入年老带或者直接触发下一次GC</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>适用：年轻带（更适合“朝生夕死”），不适用于年老带，因为可能存在100%存活的极端情况</p><p>缺点：复制算法会导致浪费一定的survivor内存空间，现在内存算法都是经过改良更适合年轻带，且堆中的Eden和2个survivor比例是 8：1：1</p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p>适用：年老带（更适合“朝生夕死”）</p><h2 id="分带收集算法"><a href="#分带收集算法" class="headerlink" title="分带收集算法"></a>分带收集算法</h2><p>适用：根据各个年代的特点使用最适当的收集算法</p><h1 id="部分垃圾回收器"><a href="#部分垃圾回收器" class="headerlink" title="部分垃圾回收器"></a>部分垃圾回收器</h1><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>初始标记（此处会stop-the-world）</p><p>并发标记</p><p>重新标记（此处会stop-the-world）</p><p>并发清除</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-线程池</title>
      <link href="/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="TheadPoolExecutor"><a href="#TheadPoolExecutor" class="headerlink" title="TheadPoolExecutor"></a>TheadPoolExecutor</h1><h2 id="队列满时候的丢弃策略"><a href="#队列满时候的丢弃策略" class="headerlink" title="队列满时候的丢弃策略"></a>队列满时候的丢弃策略</h2><p>DiscardPolicy：不处理，直接丢弃掉；<br>AbortPolicy：直接抛出 RejectedExecutionException 异常，这是默认的拒绝策略；<br>DiscardOldestPolicy：丢弃最老的任务，并执行当前任务；<br>CallerRunsPolicy：由调用线程本身运行任务，以减缓提交速度，会阻塞主线程；</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux挂载分区parted命令</title>
      <link href="/2020/06/03/Linux%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BAparted%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/03/Linux%E6%8C%82%E8%BD%BD%E5%88%86%E5%8C%BAparted%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><p>分区命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data1</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">mkdir /data2</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /data3</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /data4</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /data5</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /data6</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /data7</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /data8</span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute b 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vdb mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdb1</span><br><span class="line"></span><br><span class="line">mount /dev/vdb1 /data1</span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdb|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data1 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute c 2</span><br><span class="line"></span><br><span class="line">parted /dev/vdc mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdc1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line">mount /dev/vdc1 /data2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdc|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data2 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute d 3</span><br><span class="line"></span><br><span class="line">parted /dev/vdd mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdd1</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vdd1 /data3</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdd|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data3 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute e 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vde mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vde1</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vde1 /data4</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vde|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data4 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute f 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vdf mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdf1</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vdf1 /data5</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vde|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data5 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute g 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vdg mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdg1</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vdg1 /data6</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdg|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data6 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute h 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vdh mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdh1</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vdh1 /data7</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdh|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data7 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute i 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vdi mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdi1</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vdi1 /data8</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdi|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data8 xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\#execute j 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parted /dev/vdj mklabel gpt mkpart primary 0% 100%</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkfs.xfs /dev/vdij</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mount /dev/vdij /data</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uuid=`blkid |grep /dev/vdj|awk &#x27;&#123;print $2&#125;&#x27; | xargs echo`</span><br><span class="line"></span><br><span class="line">echo $uuid&quot; /data xfs defaults 1 1&quot;&gt;&gt;/etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Presto导出到csv</title>
      <link href="/2020/06/03/Presto%E5%AF%BC%E5%87%BA%E5%88%B0csv/"/>
      <url>/2020/06/03/Presto%E5%AF%BC%E5%87%BA%E5%88%B0csv/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><p>nohup presto –server localhost:9090 –catalog hive_danke –schema default -f &#x2F;tmp&#x2F;tmp.sql –output-format CSV &amp;&gt; &#x2F;data&#x2F;xiongyan_yanzheng.csv &amp;</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark-submit时候添加jars</title>
      <link href="/2020/06/03/spark-submit%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0jars/"/>
      <url>/2020/06/03/spark-submit%E6%97%B6%E5%80%99%E6%B7%BB%E5%8A%A0jars/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="spark-submit时单独添加jars"><a href="#spark-submit时单独添加jars" class="headerlink" title="spark-submit时单独添加jars"></a>spark-submit时单独添加jars</h1><p>spark-submit –jars app-util-1.0.0.jar –class com.dankegongyu.dailyremain.DailyRemain –master yarn –deploy-mode client &#x2F;data&#x2F;bigdata&#x2F;app-daily-remain-1.0.0.jar $yesterday</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Macpro创建centos7启动盘</title>
      <link href="/2020/06/03/%E4%BD%BF%E7%94%A8Macpro%E5%88%9B%E5%BB%BAcentos7%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
      <url>/2020/06/03/%E4%BD%BF%E7%94%A8Macpro%E5%88%9B%E5%BB%BAcentos7%E5%90%AF%E5%8A%A8%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="Macpro-查看新增优盘"><a href="#Macpro-查看新增优盘" class="headerlink" title="Macpro 查看新增优盘"></a>Macpro 查看新增优盘</h1><p>diskutil list</p><p>umount u盘</p><p>diskutil unmountDisk &#x2F;dev&#x2F;disk2</p><h1 id="Macpro-dd命令写入"><a href="#Macpro-dd命令写入" class="headerlink" title="Macpro dd命令写入"></a>Macpro dd命令写入</h1><p>sudo dd if&#x3D;&#x2F;Users&#x2F;yxs1112003&#x2F;Downloads&#x2F;CentOS-7-x86_64-DVD-1503-01.iso of&#x3D;&#x2F;dev&#x2F;disk2 bs&#x3D;4m</p><p>centos7 显示进度条的dd命令</p><p>dd if&#x3D;.&#x2F;centos7.1.iso of&#x3D;&#x2F;dev&#x2F;sdb1 status&#x3D;progress</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动编译安装flink，适配ambari hdp版本hadoop</title>
      <link href="/2020/06/03/%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85flink%EF%BC%8C%E9%80%82%E9%85%8Dhdp%E7%89%88%E6%9C%AChadoop/"/>
      <url>/2020/06/03/%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85flink%EF%BC%8C%E9%80%82%E9%85%8Dhdp%E7%89%88%E6%9C%AChadoop/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="找到ambari-hadoop版本"><a href="#找到ambari-hadoop版本" class="headerlink" title="找到ambari hadoop版本"></a>找到ambari hadoop版本</h1><p>在hdp下载目录找到当前hadoop版本</p><p><a href="http://repo.hortonworks.com/content/repositories/releases/org/apache/hadoop/hadoop-common/">http://repo.hortonworks.com/content/repositories/releases/org/apache/hadoop/hadoop-common/</a></p><p>前面是hadoop版本，后面是hdp版本</p><h1 id="clone-flink"><a href="#clone-flink" class="headerlink" title="clone flink"></a>clone flink</h1><p>clone flink源码</p><p>git clone <a href="https://github.com/apache/flink.git">https://github.com/apache/flink.git</a></p><p>切换分支</p><h1 id="手动编译"><a href="#手动编译" class="headerlink" title="手动编译"></a>手动编译</h1><p>在工程目录执行 git checkout release-1.6.4-rc1</p><p>Flink编译安装</p><p>mvn clean install -DskipTests -Drat.skip&#x3D;true -Pvendor-repos -Dhadoop.version&#x3D;2.7.3.2.6.5.0-292</p><p>参考：</p><p><a href="https://www.bbsmax.com/A/B0zqV4OnJv/">https://www.bbsmax.com/A/B0zqV4OnJv/</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ambari集群datanode出现OOM问题</title>
      <link href="/2012/06/15/ambari%E9%9B%86%E7%BE%A4datanode%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98/"/>
      <url>/2012/06/15/ambari%E9%9B%86%E7%BE%A4datanode%E5%87%BA%E7%8E%B0OOM%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>文章内容</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>hadoop-worker004、hadoop-worker005有时候会断连接，ambari显示datanode dead，看日志里提示datanode OOM</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>查看是由于hadoop-worker004、hadoop-worker005 CPU和IO负载压力太大导致的</p><p>经调查由于sql查询的数据在hadoop-worker004、hadoop-worker005上属于热点数据，且这两个节点数据比较多，需要做rebalance</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="查看IO负载命令"><a href="#查看IO负载命令" class="headerlink" title="查看IO负载命令"></a>查看IO负载命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utity占比，越接近100%，磁盘IO压力越大</span><br><span class="line">iostat -dmx 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
